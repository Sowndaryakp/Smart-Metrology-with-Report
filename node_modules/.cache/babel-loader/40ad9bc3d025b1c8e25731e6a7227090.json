{"remainingRequest":"C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\node_modules\\dxf-viewer\\src\\DxfScene.js","dependencies":[{"path":"C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\node_modules\\dxf-viewer\\src\\DxfScene.js","mtime":1704432456000},{"path":"C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\babel.config.js","mtime":1694764762000},{"path":"C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1704432454000},{"path":"C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\node_modules\\babel-loader\\lib\\index.js","mtime":1704432454000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IHsgRHluYW1pY0J1ZmZlciwgTmF0aXZlVHlwZSB9IGZyb20gIi4vRHluYW1pY0J1ZmZlciI7CmltcG9ydCB7IEJhdGNoaW5nS2V5IH0gZnJvbSAiLi9CYXRjaGluZ0tleSI7CmltcG9ydCB7IE1hdHJpeDMsIFZlY3RvcjIgfSBmcm9tICJ0aHJlZSI7CmltcG9ydCB7IFRleHRSZW5kZXJlciwgUGFyc2VTcGVjaWFsQ2hhcnMsIEhBbGlnbiwgVkFsaWduIH0gZnJvbSAiLi9UZXh0UmVuZGVyZXIiOwppbXBvcnQgeyBSQlRyZWUgfSBmcm9tICIuL1JCVHJlZSI7CmltcG9ydCB7IE1UZXh0Rm9ybWF0UGFyc2VyIH0gZnJvbSAiLi9NVGV4dEZvcm1hdFBhcnNlciI7CmltcG9ydCBkaW1TdHlsZUNvZGVzIGZyb20gJy4vcGFyc2VyL0RpbVN0eWxlQ29kZXMnOwppbXBvcnQgeyBMaW5lYXJEaW1lbnNpb24gfSBmcm9tICIuL0xpbmVhckRpbWVuc2lvbiI7CmltcG9ydCB7IEhhdGNoQ2FsY3VsYXRvciwgSGF0Y2hTdHlsZSB9IGZyb20gIi4vSGF0Y2hDYWxjdWxhdG9yIjsKaW1wb3J0IHsgTG9va3VwUGF0dGVybiwgUGF0dGVybiB9IGZyb20gIi4vUGF0dGVybiI7CmltcG9ydCAiLi9wYXR0ZXJucyI7CgovKiogVXNlIDE2LWJpdCBpbmRpY2VzIGZvciBpbmRleGVkIGdlb21ldHJ5LiAqLwpjb25zdCBJTkRFWEVEX0NIVU5LX1NJWkUgPSAweDEwMDAwOwovKiogQXJjIGFuZ2xlIGZvciB0ZXNzZWxsYXRpbmcgcG9pbnQgY2lyY2xlIHNoYXBlLiAqLwpjb25zdCBQT0lOVF9DSVJDTEVfVEVTU0VMTEFUSU9OX0FOR0xFID0gMTUgKiBNYXRoLlBJIC8gMTgwOwpjb25zdCBQT0lOVF9TSEFQRV9CTE9DS19OQU1FID0gIl9fcG9pbnRfc2hhcGUiOwovKiogRmxhdHRlbiBhIGJsb2NrIGlmIGl0cyB0b3RhbCB2ZXJ0aWNlcyBjb3VudCBpbiBhbGwgaW5zdGFuY2VzIGlzIGxlc3MgdGhhbiB0aGlzIHZhbHVlLiAqLwpjb25zdCBCTE9DS19GTEFUVEVOSU5HX1ZFUlRJQ0VTX1RIUkVTSE9MRCA9IDEwMjQ7Ci8qKiBOdW1iZXIgb2Ygc3ViZGl2aXNpb25zIHBlciBzcGxpbmUgcG9pbnQuICovCmNvbnN0IFNQTElORV9TVUJESVZJU0lPTiA9IDQ7Ci8qKiBMaW1pdCBoYXRjaCBsaW5lcyBudW1iZXIgdG8gc29tZSByZWFzb25hYmxlIHZhbHVlIHRvIG1pdGlnYXRlIGhhbmdpbmcgYW5kIG91dC1vZi1tZW1vcnkgaXNzdWVzCiAqIG9uIGJhZCBmaWxlcy4KICovCmNvbnN0IE1BWF9IQVRDSF9MSU5FUyA9IDIwMDAwOwovKiogTGltaXQgaGF0Y2ggc2VnbWVudHMgbnVtYmVyIHBlciBsaW5lIHRvIHNvbWUgcmVhc29uYWJsZSB2YWx1ZSB0byBtaXRpZ2F0ZSBoYW5naW5nIGFuZAogKiBvdXQtb2YtbWVtb3J5IGlzc3VlcyBvbiBiYWQgZmlsZXMuCiAqLwpjb25zdCBNQVhfSEFUQ0hfU0VHTUVOVFMgPSAyMDAwMDsKCi8qKiBEZWZhdWx0IHZhbHVlcyBmb3Igc3lzdGVtIHZhcmlhYmxlcy4gRW50cnkgbWF5IGJlIGVpdGhlciB2YWx1ZSBvciBmdW5jdGlvbiB0byBjYWxsIGZvciBvYnRhaW5pbmcKICogYSB2YWx1ZSwgdGhlIGZ1bmN0aW9uIGB0aGlzYCBhcmd1bWVudCBpcyBEeGZTY2VuZS4KICovCmNvbnN0IERFRkFVTFRfVkFSUyA9IHsKICAvKiBodHRwczovL2tub3dsZWRnZS5hdXRvZGVzay5jb20vc3VwcG9ydC9hdXRvY2FkL2xlYXJuLWV4cGxvcmUvY2Fhcy9DbG91ZEhlbHAvY2xvdWRoZWxwLzIwMTYvRU5VL0F1dG9DQUQtQ29yZS9maWxlcy9HVUlELUExN0E2OUQ3LTI1RUYtNEY1Ny1CNEVCLUQ1M0E1NkFCOTA5Qy1odG0uaHRtbCAqLwogIERJTVRYVDogZnVuY3Rpb24gKCkgewogICAgLy9YWFggc2hvdWxkIHNlbGVjdCB2YWx1ZSBmb3IgaW1wZXJpYWwgb3IgbWV0cmljIHVuaXRzCiAgICByZXR1cm4gMi41OyAvL1hYWCAwLjE4IGZvciBpbXBlcmlhbAogIH0sCgogIERJTUFTWjogMi41LAogIC8vWFhYIDAuMTggZm9yIGltcGVyaWFsCiAgRElNQ0xSRDogMCwKICBESU1DTFJFOiAwLAogIERJTUNMUlQ6IDAsCiAgRElNREVDOiAyLAogIC8vWFhYIDQgZm9yIGltcGVyaWFsLAogIERJTURMRTogMCwKICBESU1EU0VQOiAiLiIuY2hhckNvZGVBdCgwKSwKICAvL1hYWCAiLCIgZm9yIGltcGVyaWFsLAogIERJTUVYRTogMS4yNSwKICAvL1hYWCAwLjE4IGZvciBpbXBlcmlhbAogIERJTUVYTzogMC42MjUsCiAgLy8gWFhYIDAuMDYyNSBmb3IgaW1wZXJpYWwKICBESU1GWEw6IDEsCiAgRElNRlhMT046IGZhbHNlLAogIERJTUdBUDogMC42MjUsCiAgLy9YWFggZm9yIGltcGVyaWFsCiAgRElNTEZBQzogMSwKICBESU1STkQ6IDAsCiAgRElNU0FIOiAwLAogIERJTVNDQUxFOiAxLAogIERJTVNEMTogMCwKICBESU1TRDI6IDAsCiAgRElNU0UxOiAwLAogIERJTVNFMjogMCwKICBESU1TT1hEOiBmYWxzZSwKICBESU1UU1o6IDAsCiAgRElNWklOOiA4IC8vWFhYIDAgZm9yIGltcGVyaWFsLAp9OwoKLyoqIFRoaXMgY2xhc3MgcHJlcGFyZXMgYW4gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBEWEYgZmlsZSwgb3B0aW1pemVkIGZvIFdlYkdMIHJlbmRlcmluZy4gSXQKICogaXMgZGVjb3VwbGVkIGluIHN1Y2ggYSB3YXkgc28gdGhhdCBpdCBzaG91bGQgYmUgcG9zc2libGUgdG8gYnVpbGQgaXQgaW4gYSB3ZWItd29ya2VyLCBlZmZlY3RpdmVseQogKiB0cmFuc2ZlciBpdCB0byB0aGUgbWFpbiB0aHJlYWQsIGFuZCBlYXNpbHkgYXBwbHkgaXQgdG8gYSBUaHJlZS5qcyBzY2VuZSB0aGVyZS4KICovCmV4cG9ydCBjbGFzcyBEeGZTY2VuZSB7CiAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShEeGZTY2VuZS5EZWZhdWx0T3B0aW9ucyk7CiAgICBpZiAob3B0aW9ucykgewogICAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucy5zY2VuZU9wdGlvbnMpOwogICAgfQoKICAgIC8qIFNjZW5lIG9yaWdpbi4gQWxsIGlucHV0IGNvb3JkaW5hdGVzIGFyZSBtYWRlIGxvY2FsIHRvIHRoaXMgcG9pbnQgdG8gbWluaW1pemUgcHJlY2lzaW9uCiAgICAqIGxvc3MuCiAgICAqLwogICAgdGhpcy5vcmlnaW4gPSBudWxsOwogICAgLyogUkJUcmVlPEJhdGNoaW5nS2V5LCBSZW5kZXJCYXRjaD4gKi8KICAgIHRoaXMuYmF0Y2hlcyA9IG5ldyBSQlRyZWUoKGIxLCBiMikgPT4gYjEua2V5LkNvbXBhcmUoYjIua2V5KSk7CiAgICAvKiBJbmRleGVkIGJ5IGxheWVyIG5hbWUsIHZhbHVlIGlzIGxheWVyIG9iamVjdCBmcm9tIHBhcnNlZCBEWEYuICovCiAgICB0aGlzLmxheWVycyA9IG5ldyBNYXAoKTsKICAgIC8qIEluZGV4ZWQgYnkgYmxvY2sgbmFtZSwgdmFsdWUgaXMgQmxvY2suICovCiAgICB0aGlzLmJsb2NrcyA9IG5ldyBNYXAoKTsKICAgIC8qKiBJbmRleGVkIGJ5IGRpbWVuc2lvbiBzdHlsZSBuYW1lLCB2YWx1ZSBpcyBESU1TVFlMRSBvYmplY3QgZnJvbSBwYXJzZWQgRFhGLiAqLwogICAgdGhpcy5kaW1TdHlsZXMgPSBuZXcgTWFwKCk7CiAgICAvKiogSW5kZXhlZCBieSB2YXJpYWJsZSBuYW1lICh3aXRob3V0IGxlYWRpbmcgJyQnKS4gKi8KICAgIHRoaXMudmFycyA9IG5ldyBNYXAoKTsKICAgIHRoaXMuZm9udFN0eWxlcyA9IG5ldyBNYXAoKTsKICAgIC8qIEluZGV4ZWQgYnkgZW50aXR5IGhhbmRsZS4gKi8KICAgIHRoaXMuaW5zZXJ0cyA9IG5ldyBNYXAoKTsKICAgIHRoaXMuYm91bmRzID0gbnVsbDsKICAgIHRoaXMucG9pbnRTaGFwZUJsb2NrID0gbnVsbDsKICAgIHRoaXMubnVtQmxvY2tzRmxhdHRlbmVkID0gMDsKICAgIHRoaXMubnVtRW50aXRpZXNGaWx0ZXJlZCA9IDA7CiAgfQoKICAvKiogQnVpbGQgdGhlIHNjZW5lIGZyb20gdGhlIHByb3ZpZGVkIHBhcnNlZCBEWEYuCiAgICogQHBhcmFtIGR4ZiB7e319IFBhcnNlZCBEWEYgZmlsZS4KICAgKiBAcGFyYW0gZm9udEZldGNoZXJzIHs/RnVuY3Rpb25bXX0gTGlzdCBvZiBmb250IGZldGNoZXJzLiBGZXRjaGVyIHNob3VsZCByZXR1cm4gcHJvbWlzZSB3aXRoCiAgICogIGxvYWRlZCBmb250IG9iamVjdCAob3BlbnR5cGUuanMpLiBUaGV5IGFyZSBpbnZva2VkIG9ubHkgd2hlbiBuZWNlc3NhcnkuIEVhY2ggZ2x5cGggaXMgYmVpbmcKICAgKiAgc2VhcmNoZWQgc2VxdWVudGlhbGx5IGluIGVhY2ggcHJvdmlkZWQgZm9udC4KICAgKi8KICBhc3luYyBCdWlsZChkeGYsIGZvbnRGZXRjaGVycykgewogICAgdmFyIF90aGlzJHZhcnMkZ2V0LCBfdGhpcyR2YXJzJGdldDIsIF90aGlzJHZhcnMkZ2V0MywgX3RoaXMkdmFycyRnZXQ0OwogICAgY29uc3QgaGVhZGVyID0gZHhmLmhlYWRlciB8fCB7fTsKICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXIpKSB7CiAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoIiQiKSkgewogICAgICAgIHRoaXMudmFycy5zZXQobmFtZS5zbGljZSgxKSwgdmFsdWUpOwogICAgICB9CiAgICB9CgogICAgLyogWmVybyBhbmdsZSBkaXJlY3Rpb24sIDAgaXMgK1guICovCiAgICB0aGlzLmFuZ0Jhc2UgPSAoX3RoaXMkdmFycyRnZXQgPSB0aGlzLnZhcnMuZ2V0KCJBTkdCQVNFIikpICE9PSBudWxsICYmIF90aGlzJHZhcnMkZ2V0ICE9PSB2b2lkIDAgPyBfdGhpcyR2YXJzJGdldCA6IDA7CiAgICAvKiAwIC0gQ0NXLCAxIC0gQ1cgKi8KICAgIHRoaXMuYW5nRGlyID0gKF90aGlzJHZhcnMkZ2V0MiA9IHRoaXMudmFycy5nZXQoIkFOR0RJUiIpKSAhPT0gbnVsbCAmJiBfdGhpcyR2YXJzJGdldDIgIT09IHZvaWQgMCA/IF90aGlzJHZhcnMkZ2V0MiA6IDA7CiAgICB0aGlzLnBkU2l6ZSA9IChfdGhpcyR2YXJzJGdldDMgPSB0aGlzLnZhcnMuZ2V0KCJQRFNJWkUiKSkgIT09IG51bGwgJiYgX3RoaXMkdmFycyRnZXQzICE9PSB2b2lkIDAgPyBfdGhpcyR2YXJzJGdldDMgOiAwOwogICAgdGhpcy5pc01ldHJpYyA9ICgoX3RoaXMkdmFycyRnZXQ0ID0gdGhpcy52YXJzLmdldCgiTUVBU1VSRU1FTlQiKSkgIT09IG51bGwgJiYgX3RoaXMkdmFycyRnZXQ0ICE9PSB2b2lkIDAgPyBfdGhpcyR2YXJzJGdldDQgOiAxKSA9PSAxOwogICAgaWYgKGR4Zi50YWJsZXMgJiYgZHhmLnRhYmxlcy5sYXllcikgewogICAgICBmb3IgKGNvbnN0IFssIGxheWVyXSBvZiBPYmplY3QuZW50cmllcyhkeGYudGFibGVzLmxheWVyLmxheWVycykpIHsKICAgICAgICBsYXllci5kaXNwbGF5TmFtZSA9IFBhcnNlU3BlY2lhbENoYXJzKGxheWVyLm5hbWUpOwogICAgICAgIHRoaXMubGF5ZXJzLnNldChsYXllci5uYW1lLCBsYXllcik7CiAgICAgIH0KICAgIH0KICAgIGlmIChkeGYudGFibGVzICYmIGR4Zi50YWJsZXMuZGltc3R5bGUpIHsKICAgICAgZm9yIChjb25zdCBbLCBzdHlsZV0gb2YgT2JqZWN0LmVudHJpZXMoZHhmLnRhYmxlcy5kaW1zdHlsZS5kaW1TdHlsZXMpKSB7CiAgICAgICAgdGhpcy5kaW1TdHlsZXMuc2V0KHN0eWxlLm5hbWUsIHN0eWxlKTsKICAgICAgfQogICAgfQogICAgaWYgKGR4Zi50YWJsZXMgJiYgZHhmLnRhYmxlcy5zdHlsZSkgewogICAgICBmb3IgKGNvbnN0IFssIHN0eWxlXSBvZiBPYmplY3QuZW50cmllcyhkeGYudGFibGVzLnN0eWxlLnN0eWxlcykpIHsKICAgICAgICB0aGlzLmZvbnRTdHlsZXMuc2V0KHN0eWxlLnN0eWxlTmFtZSwgc3R5bGUpOwogICAgICB9CiAgICB9CiAgICBpZiAoZHhmLmJsb2NrcykgewogICAgICBmb3IgKGNvbnN0IFssIGJsb2NrXSBvZiBPYmplY3QuZW50cmllcyhkeGYuYmxvY2tzKSkgewogICAgICAgIHRoaXMuYmxvY2tzLnNldChibG9jay5uYW1lLCBuZXcgQmxvY2soYmxvY2spKTsKICAgICAgfQogICAgfQogICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgVGV4dFJlbmRlcmVyKGZvbnRGZXRjaGVycywgdGhpcy5vcHRpb25zLnRleHRPcHRpb25zKTsKICAgIHRoaXMuaGFzTWlzc2luZ0NoYXJzID0gZmFsc2U7CiAgICBhd2FpdCB0aGlzLl9GZXRjaEZvbnRzKGR4Zik7CgogICAgLyogU2NhbiBhbGwgZW50aXRpZXMgdG8gYW5hbHl6ZSBibG9jayB1c2FnZSBzdGF0aXN0aWNzLiAqLwogICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZHhmLmVudGl0aWVzKSB7CiAgICAgIGlmICghdGhpcy5fRmlsdGVyRW50aXR5KGVudGl0eSkpIHsKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZiAoZW50aXR5LnR5cGUgPT09ICJJTlNFUlQiKSB7CiAgICAgICAgdGhpcy5pbnNlcnRzLnNldChlbnRpdHkuaGFuZGxlLCBlbnRpdHkpOwogICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5ibG9ja3MuZ2V0KGVudGl0eS5uYW1lKTsKICAgICAgICBibG9jayA9PT0gbnVsbCB8fCBibG9jayA9PT0gdm9pZCAwIHx8IGJsb2NrLlJlZ2lzdGVySW5zZXJ0KGVudGl0eSk7CiAgICAgIH0gZWxzZSBpZiAoZW50aXR5LnR5cGUgPT0gIkRJTUVOU0lPTiIpIHsKICAgICAgICB2YXIgX2VudGl0eSRibG9jazsKICAgICAgICBpZiAoKChfZW50aXR5JGJsb2NrID0gZW50aXR5LmJsb2NrKSAhPT0gbnVsbCAmJiBfZW50aXR5JGJsb2NrICE9PSB2b2lkIDAgPyBfZW50aXR5JGJsb2NrIDogbnVsbCkgIT09IG51bGwpIHsKICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5ibG9ja3MuZ2V0KGVudGl0eS5ibG9jayk7CiAgICAgICAgICBibG9jayA9PT0gbnVsbCB8fCBibG9jayA9PT0gdm9pZCAwIHx8IGJsb2NrLlJlZ2lzdGVySW5zZXJ0KGVudGl0eSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIHRoaXMuYmxvY2tzLnZhbHVlcygpKSB7CiAgICAgIGlmIChibG9jay5kYXRhLmhhc093blByb3BlcnR5KCJlbnRpdGllcyIpKSB7CiAgICAgICAgY29uc3QgYmxvY2tDdHggPSBibG9jay5EZWZpbml0aW9uQ29udGV4dCgpOwogICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGJsb2NrLmRhdGEuZW50aXRpZXMpIHsKICAgICAgICAgIGlmICghdGhpcy5fRmlsdGVyRW50aXR5KGVudGl0eSkpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICB0aGlzLl9Qcm9jZXNzRHhmRW50aXR5KGVudGl0eSwgYmxvY2tDdHgpOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoYmxvY2suU2V0RmxhdHRlbigpKSB7CiAgICAgICAgdGhpcy5udW1CbG9ja3NGbGF0dGVuZWQrKzsKICAgICAgfQogICAgfQogICAgY29uc29sZS5sb2coYCR7dGhpcy5udW1CbG9ja3NGbGF0dGVuZWR9IGJsb2NrcyBmbGF0dGVuZWRgKTsKICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGR4Zi5lbnRpdGllcykgewogICAgICBpZiAoIXRoaXMuX0ZpbHRlckVudGl0eShlbnRpdHkpKSB7CiAgICAgICAgdGhpcy5udW1FbnRpdGllc0ZpbHRlcmVkKys7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgdGhpcy5fUHJvY2Vzc0R4ZkVudGl0eShlbnRpdHkpOwogICAgfQogICAgY29uc29sZS5sb2coYCR7dGhpcy5udW1FbnRpdGllc0ZpbHRlcmVkfSBlbnRpdGllcyBmaWx0ZXJlZGApOwogICAgdGhpcy5zY2VuZSA9IHRoaXMuX0J1aWxkU2NlbmUoKTsKICAgIGRlbGV0ZSB0aGlzLmJhdGNoZXM7CiAgICBkZWxldGUgdGhpcy5sYXllcnM7CiAgICBkZWxldGUgdGhpcy5ibG9ja3M7CiAgICBkZWxldGUgdGhpcy50ZXh0UmVuZGVyZXI7CiAgfQoKICAvKiogQHJldHVybiBGYWxzZSB0byBzdXBwcmVzcyB0aGUgc3BlY2lmaWVkIGVudGl0eSwgdHJ1ZSB0byBwZXJtaXQgcmVuZGVyaW5nLiAqLwogIF9GaWx0ZXJFbnRpdHkoZW50aXR5KSB7CiAgICByZXR1cm4gIXRoaXMub3B0aW9ucy5zdXBwcmVzc1BhcGVyU3BhY2UgfHwgIWVudGl0eS5pblBhcGVyU3BhY2U7CiAgfQogIGFzeW5jIF9GZXRjaEZvbnRzKGR4ZikgewogICAgZnVuY3Rpb24gSXNUZXh0RW50aXR5KGVudGl0eSkgewogICAgICByZXR1cm4gZW50aXR5LnR5cGUgPT09ICJURVhUIiB8fCBlbnRpdHkudHlwZSA9PT0gIk1URVhUIiB8fCBlbnRpdHkudHlwZSA9PT0gIkRJTUVOU0lPTiIgfHwgZW50aXR5LnR5cGUgPT09ICJBVFRERUYiIHx8IGVudGl0eS50eXBlID09PSAiQVRUUklCIjsKICAgIH0KICAgIGNvbnN0IFByb2Nlc3NFbnRpdHkgPSBhc3luYyBlbnRpdHkgPT4gewogICAgICBpZiAoIXRoaXMuX0ZpbHRlckVudGl0eShlbnRpdHkpKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGxldCByZXQ7CiAgICAgIGlmIChlbnRpdHkudHlwZSA9PT0gIlRFWFQiIHx8IGVudGl0eS50eXBlID09PSAiQVRUUklCIiB8fCBlbnRpdHkudHlwZSA9PT0gIkFUVERFRiIpIHsKICAgICAgICByZXQgPSBhd2FpdCB0aGlzLnRleHRSZW5kZXJlci5GZXRjaEZvbnRzKFBhcnNlU3BlY2lhbENoYXJzKGVudGl0eS50ZXh0KSk7CiAgICAgIH0gZWxzZSBpZiAoZW50aXR5LnR5cGUgPT09ICJNVEVYVCIpIHsKICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgTVRleHRGb3JtYXRQYXJzZXIoKTsKICAgICAgICBwYXJzZXIuUGFyc2UoZW50aXR5LnRleHQpOwogICAgICAgIHJldCA9IHRydWU7CiAgICAgICAgLy9YWFggZm9ybWF0dGVkIE1URVhUIG1heSBzcGVjaWZ5IHNvbWUgZm9udHMgZXhwbGljaXRseSwgdGhpcyBpcyBub3QgeWV0IHN1cHBvcnRlZAogICAgICAgIGZvciAoY29uc3QgdGV4dCBvZiBwYXJzZXIuR2V0VGV4dCgpKSB7CiAgICAgICAgICBpZiAoIShhd2FpdCB0aGlzLnRleHRSZW5kZXJlci5GZXRjaEZvbnRzKFBhcnNlU3BlY2lhbENoYXJzKHRleHQpKSkpIHsKICAgICAgICAgICAgcmV0ID0gZmFsc2U7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChlbnRpdHkudHlwZSA9PT0gIkRJTUVOU0lPTiIpIHsKICAgICAgICByZXQgPSB0cnVlOwogICAgICAgIGNvbnN0IGRpbSA9IHRoaXMuX0NyZWF0ZUxpbmVhckRpbWVuc2lvbihlbnRpdHkpOwogICAgICAgIGlmIChkaW0pIHsKICAgICAgICAgIGZvciAoY29uc3QgdGV4dCBvZiBkaW0uR2V0VGV4dHMoKSkgewogICAgICAgICAgICBpZiAoIShhd2FpdCB0aGlzLnRleHRSZW5kZXJlci5GZXRjaEZvbnRzKHRleHQpKSkgewogICAgICAgICAgICAgIHJldCA9IGZhbHNlOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiQmFkIGVudGl0eSB0eXBlIik7CiAgICAgIH0KICAgICAgaWYgKCFyZXQpIHsKICAgICAgICB0aGlzLmhhc01pc3NpbmdDaGFycyA9IHRydWU7CiAgICAgIH0KICAgICAgcmV0dXJuIHJldDsKICAgIH07CiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBkeGYuZW50aXRpZXMpIHsKICAgICAgaWYgKElzVGV4dEVudGl0eShlbnRpdHkpKSB7CiAgICAgICAgaWYgKCEoYXdhaXQgUHJvY2Vzc0VudGl0eShlbnRpdHkpKSkgewogICAgICAgICAgLyogRmFpbGluZyB0byByZXNvbHZlIHNvbWUgY2hhcmFjdGVyIG1lYW5zIHRoYXQgYWxsIGZvbnRzIGhhdmUgYmVlbiBsb2FkZWQgYW5kCiAgICAgICAgICAgKiBjaGVja2VkLiBObyBtZWFuIHRvIGNoZWNrIHRoZSByZXN0IHN0cmluZ3MuIEhvd2V2ZXIgdW50aWwgaXQgaXMgZW5jb3VudGVyZWQsCiAgICAgICAgICAgKiBhbGwgc3RyaW5ncyBzaG91bGQgYmUgY2hlY2tlZCwgZXZlbiBpZiBhbGwgZm9udHMgYWxyZWFkeSBsb2FkZWQuIFRoaXMgbmVlZGVkCiAgICAgICAgICAgKiB0byBwcm9wZXJseSBzZXQgaGFzTWlzc2luZ0NoYXJzIHdoaWNoIGFsbG93cyBkaXNwbGF5aW5nIHNvbWUgd2FybmluZyBpbiBhCiAgICAgICAgICAgKiB2aWV3ZXIuCiAgICAgICAgICAgKi8KICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGZvciAoY29uc3QgYmxvY2sgb2YgdGhpcy5ibG9ja3MudmFsdWVzKCkpIHsKICAgICAgaWYgKGJsb2NrLmRhdGEuaGFzT3duUHJvcGVydHkoImVudGl0aWVzIikpIHsKICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBibG9jay5kYXRhLmVudGl0aWVzKSB7CiAgICAgICAgICBpZiAoSXNUZXh0RW50aXR5KGVudGl0eSkpIHsKICAgICAgICAgICAgaWYgKCEoYXdhaXQgUHJvY2Vzc0VudGl0eShlbnRpdHkpKSkgewogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQogIH0KICBfUHJvY2Vzc0R4ZkVudGl0eShlbnRpdHksIGJsb2NrQ3R4ID0gbnVsbCkgewogICAgbGV0IHJlbmRlckVudGl0aWVzOwogICAgc3dpdGNoIChlbnRpdHkudHlwZSkgewogICAgICBjYXNlICJMSU5FIjoKICAgICAgICByZW5kZXJFbnRpdGllcyA9IHRoaXMuX0RlY29tcG9zZUxpbmUoZW50aXR5LCBibG9ja0N0eCk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIlBPTFlMSU5FIjoKICAgICAgY2FzZSAiTFdQT0xZTElORSI6CiAgICAgICAgcmVuZGVyRW50aXRpZXMgPSB0aGlzLl9EZWNvbXBvc2VQb2x5bGluZShlbnRpdHksIGJsb2NrQ3R4KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiQVJDIjoKICAgICAgICByZW5kZXJFbnRpdGllcyA9IHRoaXMuX0RlY29tcG9zZUFyYyhlbnRpdHksIGJsb2NrQ3R4KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiQ0lSQ0xFIjoKICAgICAgICByZW5kZXJFbnRpdGllcyA9IHRoaXMuX0RlY29tcG9zZUNpcmNsZShlbnRpdHksIGJsb2NrQ3R4KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiRUxMSVBTRSI6CiAgICAgICAgcmVuZGVyRW50aXRpZXMgPSB0aGlzLl9EZWNvbXBvc2VFbGxpcHNlKGVudGl0eSwgYmxvY2tDdHgpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJQT0lOVCI6CiAgICAgICAgcmVuZGVyRW50aXRpZXMgPSB0aGlzLl9EZWNvbXBvc2VQb2ludChlbnRpdHksIGJsb2NrQ3R4KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiU1BMSU5FIjoKICAgICAgICByZW5kZXJFbnRpdGllcyA9IHRoaXMuX0RlY29tcG9zZVNwbGluZShlbnRpdHksIGJsb2NrQ3R4KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiSU5TRVJUIjoKICAgICAgICAvKiBXb3JrcyB3aXRoIHJlbmRlcmluZyBiYXRjaGVzIHdpdGhvdXQgaW50ZXJtZWRpYXRlIGVudGl0aWVzLiAqLwogICAgICAgIHRoaXMuX1Byb2Nlc3NJbnNlcnQoZW50aXR5LCBibG9ja0N0eCk7CiAgICAgICAgcmV0dXJuOwogICAgICBjYXNlICJURVhUIjoKICAgICAgICByZW5kZXJFbnRpdGllcyA9IHRoaXMuX0RlY29tcG9zZVRleHQoZW50aXR5LCBibG9ja0N0eCk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIk1URVhUIjoKICAgICAgICByZW5kZXJFbnRpdGllcyA9IHRoaXMuX0RlY29tcG9zZU1UZXh0KGVudGl0eSwgYmxvY2tDdHgpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICIzREZBQ0UiOgogICAgICAgIHJlbmRlckVudGl0aWVzID0gdGhpcy5fRGVjb21wb3NlM0RGYWNlKGVudGl0eSwgYmxvY2tDdHgpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJTT0xJRCI6CiAgICAgICAgcmVuZGVyRW50aXRpZXMgPSB0aGlzLl9EZWNvbXBvc2VTb2xpZChlbnRpdHksIGJsb2NrQ3R4KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiRElNRU5TSU9OIjoKICAgICAgICByZW5kZXJFbnRpdGllcyA9IHRoaXMuX0RlY29tcG9zZURpbWVuc2lvbihlbnRpdHksIGJsb2NrQ3R4KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiQVRUUklCIjoKICAgICAgICByZW5kZXJFbnRpdGllcyA9IHRoaXMuX0RlY29tcG9zZUF0dHJpYnV0ZShlbnRpdHksIGJsb2NrQ3R4KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiSEFUQ0giOgogICAgICAgIHJlbmRlckVudGl0aWVzID0gdGhpcy5fRGVjb21wb3NlSGF0Y2goZW50aXR5LCBibG9ja0N0eCk7CiAgICAgICAgYnJlYWs7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgY29uc29sZS5sb2coIlVuaGFuZGxlZCBlbnRpdHkgdHlwZTogIiArIGVudGl0eS50eXBlKTsKICAgICAgICByZXR1cm47CiAgICB9CiAgICBmb3IgKGNvbnN0IHJlbmRlckVudGl0eSBvZiByZW5kZXJFbnRpdGllcykgewogICAgICB0aGlzLl9Qcm9jZXNzRW50aXR5KHJlbmRlckVudGl0eSwgYmxvY2tDdHgpOwogICAgfQogIH0KICAvKioKICAgKiBAcGFyYW0gZW50aXR5IHtFbnRpdHl9CiAgICogQHBhcmFtIGJsb2NrQ3R4IHs/QmxvY2tDb250ZXh0fQogICAqLwogIF9Qcm9jZXNzRW50aXR5KGVudGl0eSwgYmxvY2tDdHggPSBudWxsKSB7CiAgICBzd2l0Y2ggKGVudGl0eS50eXBlKSB7CiAgICAgIGNhc2UgRW50aXR5LlR5cGUuUE9JTlRTOgogICAgICAgIHRoaXMuX1Byb2Nlc3NQb2ludHMoZW50aXR5LCBibG9ja0N0eCk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgRW50aXR5LlR5cGUuTElORV9TRUdNRU5UUzoKICAgICAgICB0aGlzLl9Qcm9jZXNzTGluZVNlZ21lbnRzKGVudGl0eSwgYmxvY2tDdHgpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIEVudGl0eS5UeXBlLlBPTFlMSU5FOgogICAgICAgIHRoaXMuX1Byb2Nlc3NQb2x5bGluZShlbnRpdHksIGJsb2NrQ3R4KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSBFbnRpdHkuVHlwZS5UUklBTkdMRVM6CiAgICAgICAgdGhpcy5fUHJvY2Vzc1RyaWFuZ2xlcyhlbnRpdHksIGJsb2NrQ3R4KTsKICAgICAgICBicmVhazsKICAgICAgZGVmYXVsdDoKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlVuaGFuZGxlZCBlbnRpdHkgdHlwZTogIiArIGVudGl0eS50eXBlKTsKICAgIH0KICB9CgogIC8qKgogICAqIEBwYXJhbSBlbnRpdHkKICAgKiBAcGFyYW0gdmVydGV4CiAgICogQHBhcmFtIGJsb2NrQ3R4IHs/QmxvY2tDb250ZXh0fQogICAqIEByZXR1cm4ge251bWJlcn0KICAgKi8KICBfR2V0TGluZVR5cGUoZW50aXR5LCB2ZXJ0ZXggPSBudWxsLCBibG9ja0N0eCA9IG51bGwpIHsKICAgIC8vWFhYIGxvb2t1cAogICAgcmV0dXJuIDA7CiAgfQoKICAvKiogQ2hlY2sgaWYgc3RhcnQvZW5kIHdpdGggYXJlIG5vdCBzcGVjaWZpZWQuICovCiAgX0lzUGxhaW5MaW5lKGVudGl0eSkgewogICAgcmV0dXJuICFCb29sZWFuKGVudGl0eS5zdGFydFdpZHRoIHx8IGVudGl0eS5lbmRXaWR0aCk7CiAgfQogICpfRGVjb21wb3NlTGluZShlbnRpdHksIGJsb2NrQ3R4KSB7CiAgICAvKiBzdGFydC9lbmQgd2lkdGgsIGJ1bGdlIC0gc2VlbXMgY2Fubm90IGJlIHByZXNlbnQsIGF0IGxlYXN0IHdpdGggY3VycmVudCBwYXJzZXIgKi8KICAgIGlmIChlbnRpdHkudmVydGljZXMubGVuZ3RoICE9PSAyKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IGxheWVyID0gdGhpcy5fR2V0RW50aXR5TGF5ZXIoZW50aXR5LCBibG9ja0N0eCk7CiAgICBjb25zdCBjb2xvciA9IHRoaXMuX0dldEVudGl0eUNvbG9yKGVudGl0eSwgYmxvY2tDdHgpOwogICAgeWllbGQgbmV3IEVudGl0eSh7CiAgICAgIHR5cGU6IEVudGl0eS5UeXBlLkxJTkVfU0VHTUVOVFMsCiAgICAgIHZlcnRpY2VzOiBlbnRpdHkudmVydGljZXMsCiAgICAgIGxheWVyLAogICAgICBjb2xvciwKICAgICAgbGluZVR5cGU6IHRoaXMuX0dldExpbmVUeXBlKGVudGl0eSwgZW50aXR5LnZlcnRpY2VzWzBdKQogICAgfSk7CiAgfQoKICAvKiogR2VuZXJhdGUgdmVydGljZXMgZm9yIGJ1bGdlZCBsaW5lIHNlZ21lbnQuCiAgICoKICAgKiBAcGFyYW0gdmVydGljZXMgR2VuZXJhdGVkIHZlcnRpY2VzIHB1c2hlZCBoZXJlLgogICAqIEBwYXJhbSBzdGFydFZ0eCBTdGFydGluZyB2ZXJ0ZXguIEFzc3VtaW5nIGl0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgdmVydGljZXMgYXJyYXkuCiAgICogQHBhcmFtIGVuZFZ0eCBFbmRpbmcgdmVydGV4LgogICAqIEBwYXJhbSBidWxnZSBCdWxnZSB2YWx1ZSAoc2VlIERYRiBzcGVjaWZpY2F0aW9uKS4KICAgKi8KICBfR2VuZXJhdGVCdWxnZVZlcnRpY2VzKHZlcnRpY2VzLCBzdGFydFZ0eCwgZW5kVnR4LCBidWxnZSkgewogICAgY29uc3QgYSA9IDQgKiBNYXRoLmF0YW4oYnVsZ2UpOwogICAgY29uc3QgYUFicyA9IE1hdGguYWJzKGEpOwogICAgaWYgKGFBYnMgPCB0aGlzLm9wdGlvbnMuYXJjVGVzc2VsbGF0aW9uQW5nbGUpIHsKICAgICAgdmVydGljZXMucHVzaChuZXcgVmVjdG9yMihlbmRWdHgueCwgZW5kVnR4LnkpKTsKICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3QgaGEgPSBhIC8gMjsKICAgIGNvbnN0IHNoYSA9IE1hdGguc2luKGhhKTsKICAgIGNvbnN0IGNoYSA9IE1hdGguY29zKGhhKTsKICAgIGNvbnN0IGQgPSB7CiAgICAgIHg6IGVuZFZ0eC54IC0gc3RhcnRWdHgueCwKICAgICAgeTogZW5kVnR4LnkgLSBzdGFydFZ0eC55CiAgICB9OwogICAgY29uc3QgZFNxID0gZC54ICogZC54ICsgZC55ICogZC55OwogICAgaWYgKGRTcSA8IE51bWJlci5NSU5fVkFMVUUgKiAyKSB7CiAgICAgIC8qIE5vIHZlcnRleCBpcyBwdXNoZWQgc2luY2UgZW5kIHZlcnRleCBpcyBkdXBsaWNhdGUgb2Ygc3RhcnQgdmVydGV4LiAqLwogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCBEID0gTWF0aC5zcXJ0KGRTcSk7CiAgICBsZXQgUiA9IEQgLyAyIC8gc2hhOwogICAgZC54IC89IEQ7CiAgICBkLnkgLz0gRDsKICAgIGNvbnN0IGNlbnRlciA9IHsKICAgICAgeDogKGQueCAqIHNoYSAtIGQueSAqIGNoYSkgKiBSICsgc3RhcnRWdHgueCwKICAgICAgeTogKGQueCAqIGNoYSArIGQueSAqIHNoYSkgKiBSICsgc3RhcnRWdHgueQogICAgfTsKICAgIGxldCBudW1TZWdtZW50cyA9IE1hdGguZmxvb3IoYUFicyAvIHRoaXMub3B0aW9ucy5hcmNUZXNzZWxsYXRpb25BbmdsZSk7CiAgICBpZiAobnVtU2VnbWVudHMgPCB0aGlzLm9wdGlvbnMubWluQXJjVGVzc2VsbGF0aW9uU3ViZGl2aXNpb25zKSB7CiAgICAgIG51bVNlZ21lbnRzID0gdGhpcy5vcHRpb25zLm1pbkFyY1Rlc3NlbGxhdGlvblN1YmRpdmlzaW9uczsKICAgIH0KICAgIGlmIChudW1TZWdtZW50cyA+IDEpIHsKICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIoc3RhcnRWdHgueSAtIGNlbnRlci55LCBzdGFydFZ0eC54IC0gY2VudGVyLngpOwogICAgICBjb25zdCBzdGVwID0gYSAvIG51bVNlZ21lbnRzOwogICAgICBpZiAoYSA8IDApIHsKICAgICAgICBSID0gLVI7CiAgICAgIH0KICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7CiAgICAgICAgY29uc3QgYSA9IHN0YXJ0QW5nbGUgKyBpICogc3RlcDsKICAgICAgICBjb25zdCB2ID0gbmV3IFZlY3RvcjIoY2VudGVyLnggKyBSICogTWF0aC5jb3MoYSksIGNlbnRlci55ICsgUiAqIE1hdGguc2luKGEpKTsKICAgICAgICB2ZXJ0aWNlcy5wdXNoKHYpOwogICAgICB9CiAgICB9CiAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWN0b3IyKGVuZFZ0eC54LCBlbmRWdHgueSkpOwogIH0KCiAgLyoqIEdlbmVyYXRlIHZlcnRpY2VzIGZvciBhcmMgc2VnbWVudC4KICAgKgogICAqIEBwYXJhbSB2ZXJ0aWNlcyBHZW5lcmF0ZWQgdmVydGljZXMgcHVzaGVkIGhlcmUuCiAgICogQHBhcmFtIHt7eCwgeX19IGNlbnRlciAgQ2VudGVyIHZlY3Rvci4KICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzCiAgICogQHBhcmFtIHs/bnVtYmVyfSBzdGFydEFuZ2xlIFN0YXJ0IGFuZ2xlIGluIHJhZGlhbnMuIFplcm8gaWYgbm90IHNwZWNpZmllZC4gQXJjIGlzIGRyYXduIGluCiAgICogIENDVyBkaXJlY3Rpb24gZnJvbSBzdGFydCBhbmdsZSB0b3dhcmRzIGVuZCBhbmdsZS4KICAgKiBAcGFyYW0gez9udW1iZXJ9IGVuZEFuZ2xlIE9wdGlvbmFsIGVuZCBhbmdsZSBpbiByYWRpYW5zLiBGdWxsIGNpcmNsZSBpcyBkcmF3biBpZiBub3QKICAgKiAgc3BlY2lmaWVkLgogICAqIEBwYXJhbSB7P251bWJlcn0gdGVzc2VsbGF0aW9uQW5nbGUgQXJjIHRlc3NlbGxhdGlvbiBhbmdsZSBpbiByYWRpYW5zLCBkZWZhdWx0IHZhbHVlIGlzIHRha2VuCiAgICogIGZyb20gc2NlbmUgb3B0aW9ucy4KICAgKiBAcGFyYW0gez9udW1iZXJ9IHlSYWRpdXMgU3BlY2lmeSB0byBnZXQgZWxsaXBzZSBhcmMuIGByYWRpdXNgIHBhcmFtZXRlciB1c2VkIGFzIFggcmFkaXVzLgogICAqIEBwYXJhbSB7P01hdHJpeDN9IHRyYW5zZm9ybSBPcHRpb25hbCB0cmFuc2Zvcm0gbWF0cml4IGZvciB0aGUgYXJjLiBBcHBsaWVkIGFzIGxhc3Qgb3BlcmF0aW9uLgogICAqIEBwYXJhbSB7P251bWJlcn0gcm90YXRpb24gT3B0aW9uYWwgcm90YXRpb24gYW5nbGUgZm9yIGdlbmVyYXRlZCBhcmMuIE1vc3RseSBmb3IgZWxsaXBzZXMuCiAgICogQHBhcmFtIHs/Ym9vbGVhbn0gY3dBbmdsZURpciBBbmdsZXMgY291bnRlZCBpbiBjbG9ja3dpc2UgZGlyZWN0aW9uIGZyb20gWCBwb3NpdGl2ZSBkaXJlY3Rpb24uCiAgICogQHJldHVybiB7VmVjdG9yMltdfSBMaXN0IG9mIGdlbmVyYXRlZCB2ZXJ0aWNlcy4KICAgKi8KICBfR2VuZXJhdGVBcmNWZXJ0aWNlcyh7CiAgICB2ZXJ0aWNlcywKICAgIGNlbnRlciwKICAgIHJhZGl1cywKICAgIHN0YXJ0QW5nbGUgPSBudWxsLAogICAgZW5kQW5nbGUgPSBudWxsLAogICAgdGVzc2VsbGF0aW9uQW5nbGUgPSBudWxsLAogICAgeVJhZGl1cyA9IG51bGwsCiAgICB0cmFuc2Zvcm0gPSBudWxsLAogICAgcm90YXRpb24gPSBudWxsLAogICAgY2N3QW5nbGVEaXIgPSB0cnVlCiAgfSkgewogICAgaWYgKCFjZW50ZXIgfHwgIXJhZGl1cykgewogICAgICByZXR1cm47CiAgICB9CiAgICBpZiAoIXRlc3NlbGxhdGlvbkFuZ2xlKSB7CiAgICAgIHRlc3NlbGxhdGlvbkFuZ2xlID0gdGhpcy5vcHRpb25zLmFyY1Rlc3NlbGxhdGlvbkFuZ2xlOwogICAgfQogICAgaWYgKHlSYWRpdXMgPT09IG51bGwpIHsKICAgICAgeVJhZGl1cyA9IHJhZGl1czsKICAgIH0KICAgIC8qIE5vcm1hbGl6ZSBhbmdsZXMgLSBtYWtlIHRoZW0gc3RhcnRpbmcgZnJvbSArWCBpbiBDQ1cgZGlyZWN0aW9uLiBFbmQgYW5nbGUgc2hvdWxkIGJlCiAgICAgKiBncmVhdGVyIHRoYW4gc3RhcnQgYW5nbGUuCiAgICAgKi8KICAgIGlmIChzdGFydEFuZ2xlID09PSB1bmRlZmluZWQgfHwgc3RhcnRBbmdsZSA9PT0gbnVsbCkgewogICAgICBzdGFydEFuZ2xlID0gMDsKICAgIH0gZWxzZSB7CiAgICAgIHN0YXJ0QW5nbGUgKz0gdGhpcy5hbmdCYXNlOwogICAgfQogICAgbGV0IGlzQ2xvc2VkID0gZmFsc2U7CiAgICBpZiAoZW5kQW5nbGUgPT09IHVuZGVmaW5lZCB8fCBlbmRBbmdsZSA9PT0gbnVsbCkgewogICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAyICogTWF0aC5QSTsKICAgICAgaXNDbG9zZWQgPSB0cnVlOwogICAgfSBlbHNlIHsKICAgICAgZW5kQW5nbGUgKz0gdGhpcy5hbmdCYXNlOwogICAgfQoKICAgIC8vWFhYIHRoaXMuYW5nRGlyIC0gbm90IGNsZWFyLCBzZWVtIGluIHByYWN0aWNlIGl0IGRvZXMgbm90IGFsdGVyIGFyY3MgcmVuZGVyaW5nLgogICAgaWYgKCFjY3dBbmdsZURpcikgewogICAgICBjb25zdCB0bXAgPSBzdGFydEFuZ2xlOwogICAgICBzdGFydEFuZ2xlID0gLWVuZEFuZ2xlOwogICAgICBlbmRBbmdsZSA9IC10bXA7CiAgICB9CiAgICB3aGlsZSAoZW5kQW5nbGUgPD0gc3RhcnRBbmdsZSkgewogICAgICBlbmRBbmdsZSArPSBNYXRoLlBJICogMjsKICAgIH0KICAgIGNvbnN0IGFyY0FuZ2xlID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlOwogICAgbGV0IG51bVNlZ21lbnRzID0gTWF0aC5mbG9vcihhcmNBbmdsZSAvIHRlc3NlbGxhdGlvbkFuZ2xlKTsKICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgewogICAgICBudW1TZWdtZW50cyA9IDE7CiAgICB9CiAgICBjb25zdCBzdGVwID0gYXJjQW5nbGUgLyBudW1TZWdtZW50czsKICAgIGxldCByb3RhdGlvblRyYW5zZm9ybSA9IG51bGw7CiAgICBpZiAocm90YXRpb24pIHsKICAgICAgcm90YXRpb25UcmFuc2Zvcm0gPSBuZXcgTWF0cml4MygpLm1ha2VSb3RhdGlvbihyb3RhdGlvbik7CiAgICB9CiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBudW1TZWdtZW50czsgaSsrKSB7CiAgICAgIGlmIChpID09PSBudW1TZWdtZW50cyAmJiBpc0Nsb3NlZCkgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGxldCBhOwogICAgICBpZiAoY2N3QW5nbGVEaXIpIHsKICAgICAgICBhID0gc3RhcnRBbmdsZSArIGkgKiBzdGVwOwogICAgICB9IGVsc2UgewogICAgICAgIGEgPSBzdGFydEFuZ2xlICsgKG51bVNlZ21lbnRzIC0gaSkgKiBzdGVwOwogICAgICB9CiAgICAgIGNvbnN0IHYgPSBuZXcgVmVjdG9yMihyYWRpdXMgKiBNYXRoLmNvcyhhKSwgeVJhZGl1cyAqIE1hdGguc2luKGEpKTsKICAgICAgaWYgKHJvdGF0aW9uVHJhbnNmb3JtKSB7CiAgICAgICAgdi5hcHBseU1hdHJpeDMocm90YXRpb25UcmFuc2Zvcm0pOwogICAgICB9CiAgICAgIHYuYWRkKGNlbnRlcik7CiAgICAgIGlmICh0cmFuc2Zvcm0pIHsKICAgICAgICB2LmFwcGx5TWF0cml4Myh0cmFuc2Zvcm0pOwogICAgICB9CiAgICAgIHZlcnRpY2VzLnB1c2godik7CiAgICB9CiAgfQogICpfRGVjb21wb3NlQXJjKGVudGl0eSwgYmxvY2tDdHgpIHsKICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fR2V0RW50aXR5Q29sb3IoZW50aXR5LCBibG9ja0N0eCk7CiAgICBjb25zdCBsYXllciA9IHRoaXMuX0dldEVudGl0eUxheWVyKGVudGl0eSwgYmxvY2tDdHgpOwogICAgY29uc3QgbGluZVR5cGUgPSB0aGlzLl9HZXRMaW5lVHlwZShlbnRpdHksIG51bGwsIGJsb2NrQ3R4KTsKICAgIGNvbnN0IHZlcnRpY2VzID0gW107CiAgICB0aGlzLl9HZW5lcmF0ZUFyY1ZlcnRpY2VzKHsKICAgICAgdmVydGljZXMsCiAgICAgIGNlbnRlcjogZW50aXR5LmNlbnRlciwKICAgICAgcmFkaXVzOiBlbnRpdHkucmFkaXVzLAogICAgICBzdGFydEFuZ2xlOiBlbnRpdHkuc3RhcnRBbmdsZSwKICAgICAgZW5kQW5nbGU6IGVudGl0eS5lbmRBbmdsZSwKICAgICAgdHJhbnNmb3JtOiB0aGlzLl9HZXRFbnRpdHlFeHRydXNpb25UcmFuc2Zvcm0oZW50aXR5KQogICAgfSk7CiAgICB5aWVsZCBuZXcgRW50aXR5KHsKICAgICAgdHlwZTogRW50aXR5LlR5cGUuUE9MWUxJTkUsCiAgICAgIHZlcnRpY2VzLAogICAgICBsYXllciwKICAgICAgY29sb3IsCiAgICAgIGxpbmVUeXBlLAogICAgICBzaGFwZTogZW50aXR5LmVuZEFuZ2xlID09PSB1bmRlZmluZWQKICAgIH0pOwogIH0KICAqX0RlY29tcG9zZUNpcmNsZShlbnRpdHksIGJsb2NrQ3R4KSB7CiAgICBjb25zdCBjb2xvciA9IHRoaXMuX0dldEVudGl0eUNvbG9yKGVudGl0eSwgYmxvY2tDdHgpOwogICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9HZXRFbnRpdHlMYXllcihlbnRpdHksIGJsb2NrQ3R4KTsKICAgIGNvbnN0IGxpbmVUeXBlID0gdGhpcy5fR2V0TGluZVR5cGUoZW50aXR5LCBudWxsLCBibG9ja0N0eCk7CiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdOwogICAgdGhpcy5fR2VuZXJhdGVBcmNWZXJ0aWNlcyh7CiAgICAgIHZlcnRpY2VzLAogICAgICBjZW50ZXI6IGVudGl0eS5jZW50ZXIsCiAgICAgIHJhZGl1czogZW50aXR5LnJhZGl1cywKICAgICAgdHJhbnNmb3JtOiB0aGlzLl9HZXRFbnRpdHlFeHRydXNpb25UcmFuc2Zvcm0oZW50aXR5KQogICAgfSk7CiAgICB5aWVsZCBuZXcgRW50aXR5KHsKICAgICAgdHlwZTogRW50aXR5LlR5cGUuUE9MWUxJTkUsCiAgICAgIHZlcnRpY2VzLAogICAgICBsYXllciwKICAgICAgY29sb3IsCiAgICAgIGxpbmVUeXBlLAogICAgICBzaGFwZTogdHJ1ZQogICAgfSk7CiAgfQogICpfRGVjb21wb3NlRWxsaXBzZShlbnRpdHksIGJsb2NrQ3R4KSB7CiAgICB2YXIgX2VudGl0eSRzdGFydEFuZ2xlLCBfZW50aXR5JGVuZEFuZ2xlLCBfZW50aXR5JGVuZEFuZ2xlMjsKICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fR2V0RW50aXR5Q29sb3IoZW50aXR5LCBibG9ja0N0eCk7CiAgICBjb25zdCBsYXllciA9IHRoaXMuX0dldEVudGl0eUxheWVyKGVudGl0eSwgYmxvY2tDdHgpOwogICAgY29uc3QgbGluZVR5cGUgPSB0aGlzLl9HZXRMaW5lVHlwZShlbnRpdHksIG51bGwsIGJsb2NrQ3R4KTsKICAgIGNvbnN0IHZlcnRpY2VzID0gW107CiAgICBjb25zdCB4UiA9IE1hdGguc3FydChlbnRpdHkubWFqb3JBeGlzRW5kUG9pbnQueCAqIGVudGl0eS5tYWpvckF4aXNFbmRQb2ludC54ICsgZW50aXR5Lm1ham9yQXhpc0VuZFBvaW50LnkgKiBlbnRpdHkubWFqb3JBeGlzRW5kUG9pbnQueSk7CiAgICBjb25zdCB5UiA9IHhSICogZW50aXR5LmF4aXNSYXRpbzsKICAgIGNvbnN0IHJvdGF0aW9uID0gTWF0aC5hdGFuMihlbnRpdHkubWFqb3JBeGlzRW5kUG9pbnQueSwgZW50aXR5Lm1ham9yQXhpc0VuZFBvaW50LngpOwogICAgY29uc3Qgc3RhcnRBbmdsZSA9IChfZW50aXR5JHN0YXJ0QW5nbGUgPSBlbnRpdHkuc3RhcnRBbmdsZSkgIT09IG51bGwgJiYgX2VudGl0eSRzdGFydEFuZ2xlICE9PSB2b2lkIDAgPyBfZW50aXR5JHN0YXJ0QW5nbGUgOiAwOwogICAgbGV0IGVuZEFuZ2xlID0gKF9lbnRpdHkkZW5kQW5nbGUgPSBlbnRpdHkuZW5kQW5nbGUpICE9PSBudWxsICYmIF9lbnRpdHkkZW5kQW5nbGUgIT09IHZvaWQgMCA/IF9lbnRpdHkkZW5kQW5nbGUgOiBzdGFydEFuZ2xlICsgMiAqIE1hdGguUEk7CiAgICB3aGlsZSAoZW5kQW5nbGUgPD0gc3RhcnRBbmdsZSkgewogICAgICBlbmRBbmdsZSArPSBNYXRoLlBJICogMjsKICAgIH0KICAgIGNvbnN0IGlzQ2xvc2VkID0gKChfZW50aXR5JGVuZEFuZ2xlMiA9IGVudGl0eS5lbmRBbmdsZSkgIT09IG51bGwgJiYgX2VudGl0eSRlbmRBbmdsZTIgIT09IHZvaWQgMCA/IF9lbnRpdHkkZW5kQW5nbGUyIDogbnVsbCkgPT09IG51bGwgfHwgTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlIC0gMiAqIE1hdGguUEkpIDwgMWUtNjsKICAgIHRoaXMuX0dlbmVyYXRlQXJjVmVydGljZXMoewogICAgICB2ZXJ0aWNlcywKICAgICAgY2VudGVyOiBlbnRpdHkuY2VudGVyLAogICAgICByYWRpdXM6IHhSLAogICAgICBzdGFydEFuZ2xlOiBlbnRpdHkuc3RhcnRBbmdsZSwKICAgICAgZW5kQW5nbGU6IGlzQ2xvc2VkID8gbnVsbCA6IGVudGl0eS5lbmRBbmdsZSwKICAgICAgeVJhZGl1czogeVIsCiAgICAgIHJvdGF0aW9uLAogICAgICAvKiBBc3N1bWluZyBtaXJyb3IgdHJhbnNmb3JtIGlmIHByZXNlbnQsIGZvciBlbGxpcHNlIGl0IGp1c3QKICAgICAgICogcmV2ZXJzZXMgYW5nbGUgZGlyZWN0aW9uLgogICAgICAgKi8KICAgICAgY2N3QW5nbGVEaXI6ICF0aGlzLl9HZXRFbnRpdHlFeHRydXNpb25UcmFuc2Zvcm0oZW50aXR5KQogICAgfSk7CiAgICB5aWVsZCBuZXcgRW50aXR5KHsKICAgICAgdHlwZTogRW50aXR5LlR5cGUuUE9MWUxJTkUsCiAgICAgIHZlcnRpY2VzLAogICAgICBsYXllciwKICAgICAgY29sb3IsCiAgICAgIGxpbmVUeXBlLAogICAgICBzaGFwZTogaXNDbG9zZWQKICAgIH0pOwogIH0KICAqX0RlY29tcG9zZVBvaW50KGVudGl0eSwgYmxvY2tDdHgpIHsKICAgIGlmICh0aGlzLnBkTW9kZSA9PT0gUGRNb2RlLk5PTkUpIHsKICAgICAgLyogUG9pbnRzIG5vdCBkaXNwbGF5ZWQuICovCiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmICh0aGlzLnBkTW9kZSAhPT0gUGRNb2RlLkRPVCAmJiB0aGlzLnBkU2l6ZSA8PSAwKSB7CiAgICAgIC8qIEN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLiAqLwogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCBjb2xvciA9IHRoaXMuX0dldEVudGl0eUNvbG9yKGVudGl0eSwgYmxvY2tDdHgpOwogICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9HZXRFbnRpdHlMYXllcihlbnRpdHksIGJsb2NrQ3R4KTsKICAgIGNvbnN0IG1hcmtUeXBlID0gdGhpcy5wZE1vZGUgJiBQZE1vZGUuTUFSS19NQVNLOwogICAgY29uc3QgaXNTaGFwZWQgPSAodGhpcy5wZE1vZGUgJiBQZE1vZGUuU0hBUEVfTUFTSykgIT09IDA7CiAgICBpZiAoaXNTaGFwZWQpIHsKICAgICAgLyogU2hhcGVkIG1hcmsgc2hvdWxkIGJlIGluc3RhbmNlZC4gKi8KICAgICAgY29uc3Qga2V5ID0gbmV3IEJhdGNoaW5nS2V5KGxheWVyLCBQT0lOVF9TSEFQRV9CTE9DS19OQU1FLCBCYXRjaGluZ0tleS5HZW9tZXRyeVR5cGUuUE9JTlRfSU5TVEFOQ0UsIGNvbG9yLCAwKTsKICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLl9HZXRCYXRjaChrZXkpOwogICAgICBiYXRjaC5QdXNoVmVydGV4KHRoaXMuX1RyYW5zZm9ybVZlcnRleChlbnRpdHkucG9zaXRpb24pKTsKICAgICAgdGhpcy5fQ3JlYXRlUG9pbnRTaGFwZUJsb2NrKCk7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmIChtYXJrVHlwZSA9PT0gUGRNb2RlLkRPVCkgewogICAgICB5aWVsZCBuZXcgRW50aXR5KHsKICAgICAgICB0eXBlOiBFbnRpdHkuVHlwZS5QT0lOVFMsCiAgICAgICAgdmVydGljZXM6IFtlbnRpdHkucG9zaXRpb25dLAogICAgICAgIGxheWVyLAogICAgICAgIGNvbG9yLAogICAgICAgIGxpbmVUeXBlOiBudWxsCiAgICAgIH0pOwogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdOwogICAgdGhpcy5fQ3JlYXRlUG9pbnRNYXJrZXIodmVydGljZXMsIG1hcmtUeXBlLCBlbnRpdHkucG9zaXRpb24pOwogICAgeWllbGQgbmV3IEVudGl0eSh7CiAgICAgIHR5cGU6IEVudGl0eS5UeXBlLkxJTkVfU0VHTUVOVFMsCiAgICAgIHZlcnRpY2VzLAogICAgICBsYXllciwKICAgICAgY29sb3IsCiAgICAgIGxpbmVUeXBlOiBudWxsCiAgICB9KTsKICB9CiAgKl9EZWNvbXBvc2VBdHRyaWJ1dGUoZW50aXR5LCBibG9ja0N0eCkgewogICAgaWYgKCF0aGlzLnRleHRSZW5kZXJlci5jYW5SZW5kZXIpIHsKICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3QgaW5zZXJ0RW50aXR5ID0gdGhpcy5pbnNlcnRzLmdldChlbnRpdHkub3duZXJIYW5kbGUpOwogICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9HZXRFbnRpdHlMYXllcihpbnNlcnRFbnRpdHkgIT09IG51bGwgJiYgaW5zZXJ0RW50aXR5ICE9PSB2b2lkIDAgPyBpbnNlcnRFbnRpdHkgOiBlbnRpdHksIGJsb2NrQ3R4KTsKICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fR2V0RW50aXR5Q29sb3IoaW5zZXJ0RW50aXR5ICE9PSBudWxsICYmIGluc2VydEVudGl0eSAhPT0gdm9pZCAwID8gaW5zZXJ0RW50aXR5IDogZW50aXR5LCBibG9ja0N0eCk7CgogICAgLy9YWFggbG9va3VwIGZvbnQgc3R5bGUgYXR0cmlidXRlcwoKICAgIHlpZWxkKiB0aGlzLnRleHRSZW5kZXJlci5SZW5kZXIoewogICAgICB0ZXh0OiBQYXJzZVNwZWNpYWxDaGFycyhlbnRpdHkudGV4dCksCiAgICAgIGZvbnRTaXplOiBlbnRpdHkudGV4dEhlaWdodCAqIGVudGl0eS5zY2FsZSwKICAgICAgc3RhcnRQb3M6IGVudGl0eS5zdGFydFBvaW50LAogICAgICBlbmRQb3M6IGVudGl0eS5lbmRQb2ludCwKICAgICAgcm90YXRpb246IGVudGl0eS5yb3RhdGlvbiwKICAgICAgaEFsaWduOiBlbnRpdHkuaG9yaXpvbnRhbEp1c3RpZmljYXRpb24sCiAgICAgIHZBbGlnbjogZW50aXR5LnZlcnRpY2FsSnVzdGlmaWNhdGlvbiwKICAgICAgY29sb3IsCiAgICAgIGxheWVyCiAgICB9KTsKICB9CgogIC8qKiBDcmVhdGUgbGluZSBzZWdtZW50cyBmb3IgcG9pbnQgbWFya2VyLgogICAqIEBwYXJhbSB2ZXJ0aWNlcwogICAqIEBwYXJhbSBtYXJrVHlwZQogICAqIEBwYXJhbSBwb3NpdGlvbiB7P3t4LHl9fSBwb2ludCBjZW50ZXIgcG9zaXRpb24sIGRlZmF1bHQgaXMgemVyby4KICAgKi8KICBfQ3JlYXRlUG9pbnRNYXJrZXIodmVydGljZXMsIG1hcmtUeXBlLCBwb3NpdGlvbiA9IG51bGwpIHsKICAgIGNvbnN0IF90aGlzID0gdGhpczsKICAgIGZ1bmN0aW9uIFB1c2hWZXJ0ZXgob2Zmc2V0WCwgb2Zmc2V0WSkgewogICAgICB2YXIgX3Bvc2l0aW9uJHgsIF9wb3NpdGlvbiR5OwogICAgICB2ZXJ0aWNlcy5wdXNoKHsKICAgICAgICB4OiAoKF9wb3NpdGlvbiR4ID0gcG9zaXRpb24gPT09IG51bGwgfHwgcG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvc2l0aW9uLngpICE9PSBudWxsICYmIF9wb3NpdGlvbiR4ICE9PSB2b2lkIDAgPyBfcG9zaXRpb24keCA6IDApICsgb2Zmc2V0WCAqIF90aGlzLnBkU2l6ZSAqIDAuNSwKICAgICAgICB5OiAoKF9wb3NpdGlvbiR5ID0gcG9zaXRpb24gPT09IG51bGwgfHwgcG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvc2l0aW9uLnkpICE9PSBudWxsICYmIF9wb3NpdGlvbiR5ICE9PSB2b2lkIDAgPyBfcG9zaXRpb24keSA6IDApICsgb2Zmc2V0WSAqIF90aGlzLnBkU2l6ZSAqIDAuNQogICAgICB9KTsKICAgIH0KICAgIHN3aXRjaCAobWFya1R5cGUpIHsKICAgICAgY2FzZSBQZE1vZGUuUExVUzoKICAgICAgICBQdXNoVmVydGV4KDAsIDEuNSk7CiAgICAgICAgUHVzaFZlcnRleCgwLCAtMS41KTsKICAgICAgICBQdXNoVmVydGV4KC0xLjUsIDApOwogICAgICAgIFB1c2hWZXJ0ZXgoMS41LCAwKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSBQZE1vZGUuQ1JPU1M6CiAgICAgICAgUHVzaFZlcnRleCgtMSwgMSk7CiAgICAgICAgUHVzaFZlcnRleCgxLCAtMSk7CiAgICAgICAgUHVzaFZlcnRleCgxLCAxKTsKICAgICAgICBQdXNoVmVydGV4KC0xLCAtMSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgUGRNb2RlLlRJQ0s6CiAgICAgICAgUHVzaFZlcnRleCgwLCAxKTsKICAgICAgICBQdXNoVmVydGV4KDAsIDApOwogICAgICAgIGJyZWFrOwogICAgICBkZWZhdWx0OgogICAgICAgIGNvbnNvbGUud2FybigiVW5zdXBwb3J0ZWQgcG9pbnQgZGlzcGxheSB0eXBlOiAiICsgbWFya1R5cGUpOwogICAgfQogIH0KCiAgLyoqIENyZWF0ZSBwb2ludCBzaGFwZSBibG9jayBpZiBub3QgeWV0IGRvbmUuICovCiAgX0NyZWF0ZVBvaW50U2hhcGVCbG9jaygpIHsKICAgIGlmICh0aGlzLnBvaW50U2hhcGVCbG9jaykgewogICAgICByZXR1cm47CiAgICB9CiAgICAvKiBUaGlzIG1pbWljcyBEWEYgYmxvY2sgZW50aXR5LiAqLwogICAgdGhpcy5wb2ludFNoYXBlQmxvY2sgPSBuZXcgQmxvY2soewogICAgICBuYW1lOiBQT0lOVF9TSEFQRV9CTE9DS19OQU1FLAogICAgICBwb3NpdGlvbjogewogICAgICAgIHg6IDAsCiAgICAgICAgeTogMAogICAgICB9CiAgICB9KTsKICAgIC8qIEZpeCBibG9jayBvcmlnaW4gYXQgemVyby4gKi8KICAgIHRoaXMucG9pbnRTaGFwZUJsb2NrLm9mZnNldCA9IG5ldyBWZWN0b3IyKDAsIDApOwogICAgY29uc3QgYmxvY2tDdHggPSB0aGlzLnBvaW50U2hhcGVCbG9jay5EZWZpbml0aW9uQ29udGV4dCgpOwogICAgY29uc3QgbWFya1R5cGUgPSB0aGlzLnBkTW9kZSAmIFBkTW9kZS5NQVJLX01BU0s7CiAgICBpZiAobWFya1R5cGUgIT09IFBkTW9kZS5ET1QgJiYgbWFya1R5cGUgIT09IFBkTW9kZS5OT05FKSB7CiAgICAgIGNvbnN0IHZlcnRpY2VzID0gW107CiAgICAgIHRoaXMuX0NyZWF0ZVBvaW50TWFya2VyKHZlcnRpY2VzLCBtYXJrVHlwZSk7CiAgICAgIGNvbnN0IGVudGl0eSA9IG5ldyBFbnRpdHkoewogICAgICAgIHR5cGU6IEVudGl0eS5UeXBlLkxJTkVfU0VHTUVOVFMsCiAgICAgICAgdmVydGljZXMsCiAgICAgICAgY29sb3I6IENvbG9yQ29kZS5CWV9CTE9DSwogICAgICB9KTsKICAgICAgdGhpcy5fUHJvY2Vzc0VudGl0eShlbnRpdHksIGJsb2NrQ3R4KTsKICAgIH0KICAgIGlmICh0aGlzLnBkTW9kZSAmIFBkTW9kZS5TUVVBUkUpIHsKICAgICAgY29uc3QgciA9IHRoaXMucGRTaXplICogMC41OwogICAgICBjb25zdCB2ZXJ0aWNlcyA9IFt7CiAgICAgICAgeDogLXIsCiAgICAgICAgeTogcgogICAgICB9LCB7CiAgICAgICAgeDogciwKICAgICAgICB5OiByCiAgICAgIH0sIHsKICAgICAgICB4OiByLAogICAgICAgIHk6IC1yCiAgICAgIH0sIHsKICAgICAgICB4OiAtciwKICAgICAgICB5OiAtcgogICAgICB9XTsKICAgICAgY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eSh7CiAgICAgICAgdHlwZTogRW50aXR5LlR5cGUuUE9MWUxJTkUsCiAgICAgICAgdmVydGljZXMsCiAgICAgICAgY29sb3I6IENvbG9yQ29kZS5CWV9CTE9DSywKICAgICAgICBzaGFwZTogdHJ1ZQogICAgICB9KTsKICAgICAgdGhpcy5fUHJvY2Vzc0VudGl0eShlbnRpdHksIGJsb2NrQ3R4KTsKICAgIH0KICAgIGlmICh0aGlzLnBkTW9kZSAmIFBkTW9kZS5DSVJDTEUpIHsKICAgICAgY29uc3QgdmVydGljZXMgPSBbXTsKICAgICAgdGhpcy5fR2VuZXJhdGVBcmNWZXJ0aWNlcyh7CiAgICAgICAgdmVydGljZXMsCiAgICAgICAgY2VudGVyOiB7CiAgICAgICAgICB4OiAwLAogICAgICAgICAgeTogMAogICAgICAgIH0sCiAgICAgICAgcmFkaXVzOiB0aGlzLnBkU2l6ZSAqIDAuNSwKICAgICAgICB0ZXNzZWxsYXRpb25BbmdsZTogUE9JTlRfQ0lSQ0xFX1RFU1NFTExBVElPTl9BTkdMRQogICAgICB9KTsKICAgICAgY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eSh7CiAgICAgICAgdHlwZTogRW50aXR5LlR5cGUuUE9MWUxJTkUsCiAgICAgICAgdmVydGljZXMsCiAgICAgICAgY29sb3I6IENvbG9yQ29kZS5CWV9CTE9DSywKICAgICAgICBzaGFwZTogdHJ1ZQogICAgICB9KTsKICAgICAgdGhpcy5fUHJvY2Vzc0VudGl0eShlbnRpdHksIGJsb2NrQ3R4KTsKICAgIH0KICB9CiAgKl9EZWNvbXBvc2UzREZhY2UoZW50aXR5LCBibG9ja0N0eCkgewogICAgeWllbGQqIHRoaXMuX0RlY29tcG9zZUZhY2UoZW50aXR5LCBlbnRpdHkudmVydGljZXMsIGJsb2NrQ3R4LCB0aGlzLm9wdGlvbnMud2lyZWZyYW1lTWVzaCk7CiAgfQogICpfRGVjb21wb3NlU29saWQoZW50aXR5LCBibG9ja0N0eCkgewogICAgeWllbGQqIHRoaXMuX0RlY29tcG9zZUZhY2UoZW50aXR5LCBlbnRpdHkucG9pbnRzLCBibG9ja0N0eCwgZmFsc2UsIHRoaXMuX0dldEVudGl0eUV4dHJ1c2lvblRyYW5zZm9ybShlbnRpdHkpKTsKICB9CiAgKl9EZWNvbXBvc2VGYWNlKGVudGl0eSwgdmVydGljZXMsIGJsb2NrQ3R4LCB3aXJlZnJhbWUsIHRyYW5zZm9ybSA9IG51bGwpIHsKICAgIGNvbnN0IGxheWVyID0gdGhpcy5fR2V0RW50aXR5TGF5ZXIoZW50aXR5LCBibG9ja0N0eCk7CiAgICBjb25zdCBjb2xvciA9IHRoaXMuX0dldEVudGl0eUNvbG9yKGVudGl0eSwgYmxvY2tDdHgpOwogICAgZnVuY3Rpb24gSXNWYWxpZFRyaWFuZ2xlKHYxLCB2MiwgdjMpIHsKICAgICAgY29uc3QgZTEgPSBuZXcgVmVjdG9yMigpLnN1YlZlY3RvcnModjIsIHYxKTsKICAgICAgY29uc3QgZTIgPSBuZXcgVmVjdG9yMigpLnN1YlZlY3RvcnModjMsIHYxKTsKICAgICAgY29uc3QgYXJlYSA9IE1hdGguYWJzKGUxLmNyb3NzKGUyKSk7CiAgICAgIHJldHVybiBhcmVhID4gTnVtYmVyLkVQU0lMT047CiAgICB9CiAgICBjb25zdCB2MCA9IG5ldyBWZWN0b3IyKHZlcnRpY2VzWzBdLngsIHZlcnRpY2VzWzBdLnkpOwogICAgY29uc3QgdjEgPSBuZXcgVmVjdG9yMih2ZXJ0aWNlc1sxXS54LCB2ZXJ0aWNlc1sxXS55KTsKICAgIGNvbnN0IHYyID0gbmV3IFZlY3RvcjIodmVydGljZXNbMl0ueCwgdmVydGljZXNbMl0ueSk7CiAgICBsZXQgdjMgPSBudWxsOwogICAgbGV0IGhhc0ZpcnN0VHJpYW5nbGUgPSBJc1ZhbGlkVHJpYW5nbGUodjAsIHYxLCB2Mik7CiAgICBsZXQgaGFzU2Vjb25kVHJpYW5nbGUgPSBmYWxzZTsKICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPiAzKSB7CiAgICAgIC8qIEZvdXJ0aCB2ZXJ0ZXggbWF5IGJlIHRoZSBzYW1lIGFzIG9uZSBvZiB0aGUgcHJldmlvdXMgdmVydGljZXMsIHNvIGFkZGl0aW9uYWwgdHJpYW5nbGUKICAgICAgICogZm9yIGRlZ2VuZXJhdGlvbi4KICAgICAgICovCgogICAgICB2MyA9IG5ldyBWZWN0b3IyKHZlcnRpY2VzWzNdLngsIHZlcnRpY2VzWzNdLnkpOwogICAgICBoYXNTZWNvbmRUcmlhbmdsZSA9IElzVmFsaWRUcmlhbmdsZSh2MSwgdjMsIHYyKTsKICAgICAgaWYgKHRyYW5zZm9ybSkgewogICAgICAgIHYzLmFwcGx5TWF0cml4Myh0cmFuc2Zvcm0pOwogICAgICB9CiAgICB9CiAgICBpZiAodHJhbnNmb3JtKSB7CiAgICAgIHYwLmFwcGx5TWF0cml4Myh0cmFuc2Zvcm0pOwogICAgICB2MS5hcHBseU1hdHJpeDModHJhbnNmb3JtKTsKICAgICAgdjIuYXBwbHlNYXRyaXgzKHRyYW5zZm9ybSk7CiAgICB9CiAgICBpZiAoIWhhc0ZpcnN0VHJpYW5nbGUgJiYgIWhhc1NlY29uZFRyaWFuZ2xlKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmICh3aXJlZnJhbWUpIHsKICAgICAgY29uc3QgX3ZlcnRpY2VzID0gW107CiAgICAgIGlmIChoYXNGaXJzdFRyaWFuZ2xlICYmICFoYXNTZWNvbmRUcmlhbmdsZSkgewogICAgICAgIF92ZXJ0aWNlcy5wdXNoKHYwLCB2MSwgdjIpOwogICAgICB9IGVsc2UgaWYgKCFoYXNGaXJzdFRyaWFuZ2xlICYmIGhhc1NlY29uZFRyaWFuZ2xlKSB7CiAgICAgICAgX3ZlcnRpY2VzLnB1c2godjEsIHYzLCB2Mik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgX3ZlcnRpY2VzLnB1c2godjAsIHYxLCB2MywgdjIpOwogICAgICB9CiAgICAgIHlpZWxkIG5ldyBFbnRpdHkoewogICAgICAgIHR5cGU6IEVudGl0eS5UeXBlLlBPTFlMSU5FLAogICAgICAgIHZlcnRpY2VzOiBfdmVydGljZXMsCiAgICAgICAgbGF5ZXIsCiAgICAgICAgY29sb3IsCiAgICAgICAgc2hhcGU6IHRydWUKICAgICAgfSk7CiAgICB9IGVsc2UgewogICAgICBjb25zdCBfdmVydGljZXMgPSBbXTsKICAgICAgY29uc3QgaW5kaWNlcyA9IFtdOwogICAgICBpZiAoaGFzRmlyc3RUcmlhbmdsZSkgewogICAgICAgIF92ZXJ0aWNlcy5wdXNoKHYwLCB2MSwgdjIpOwogICAgICAgIGluZGljZXMucHVzaCgwLCAxLCAyKTsKICAgICAgfQogICAgICBpZiAoaGFzU2Vjb25kVHJpYW5nbGUpIHsKICAgICAgICBpZiAoIWhhc0ZpcnN0VHJpYW5nbGUpIHsKICAgICAgICAgIF92ZXJ0aWNlcy5wdXNoKHYxLCB2Mik7CiAgICAgICAgICBpbmRpY2VzLnB1c2goMCwgMSwgMik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGluZGljZXMucHVzaCgxLCAyLCAzKTsKICAgICAgICB9CiAgICAgICAgX3ZlcnRpY2VzLnB1c2godjMpOwogICAgICB9CiAgICAgIHlpZWxkIG5ldyBFbnRpdHkoewogICAgICAgIHR5cGU6IEVudGl0eS5UeXBlLlRSSUFOR0xFUywKICAgICAgICB2ZXJ0aWNlczogX3ZlcnRpY2VzLAogICAgICAgIGluZGljZXMsCiAgICAgICAgbGF5ZXIsCiAgICAgICAgY29sb3IKICAgICAgfSk7CiAgICB9CiAgfQogICpfRGVjb21wb3NlVGV4dChlbnRpdHksIGJsb2NrQ3R4KSB7CiAgICBpZiAoIXRoaXMudGV4dFJlbmRlcmVyLmNhblJlbmRlcikgewogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCBsYXllciA9IHRoaXMuX0dldEVudGl0eUxheWVyKGVudGl0eSwgYmxvY2tDdHgpOwogICAgY29uc3QgY29sb3IgPSB0aGlzLl9HZXRFbnRpdHlDb2xvcihlbnRpdHksIGJsb2NrQ3R4KTsKICAgIHlpZWxkKiB0aGlzLnRleHRSZW5kZXJlci5SZW5kZXIoewogICAgICB0ZXh0OiBQYXJzZVNwZWNpYWxDaGFycyhlbnRpdHkudGV4dCksCiAgICAgIGZvbnRTaXplOiBlbnRpdHkudGV4dEhlaWdodCwKICAgICAgc3RhcnRQb3M6IGVudGl0eS5zdGFydFBvaW50LAogICAgICBlbmRQb3M6IGVudGl0eS5lbmRQb2ludCwKICAgICAgcm90YXRpb246IGVudGl0eS5yb3RhdGlvbiwKICAgICAgaEFsaWduOiBlbnRpdHkuaGFsaWduLAogICAgICB2QWxpZ246IGVudGl0eS52YWxpZ24sCiAgICAgIHdpZHRoRmFjdG9yOiBlbnRpdHkueFNjYWxlLAogICAgICBjb2xvciwKICAgICAgbGF5ZXIKICAgIH0pOwogIH0KICAqX0RlY29tcG9zZU1UZXh0KGVudGl0eSwgYmxvY2tDdHgpIHsKICAgIGlmICghdGhpcy50ZXh0UmVuZGVyZXIuY2FuUmVuZGVyKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IGxheWVyID0gdGhpcy5fR2V0RW50aXR5TGF5ZXIoZW50aXR5LCBibG9ja0N0eCk7CiAgICBjb25zdCBjb2xvciA9IHRoaXMuX0dldEVudGl0eUNvbG9yKGVudGl0eSwgYmxvY2tDdHgpOwogICAgY29uc3QgcGFyc2VyID0gbmV3IE1UZXh0Rm9ybWF0UGFyc2VyKCk7CiAgICBwYXJzZXIuUGFyc2UoUGFyc2VTcGVjaWFsQ2hhcnMoZW50aXR5LnRleHQpKTsKICAgIHlpZWxkKiB0aGlzLnRleHRSZW5kZXJlci5SZW5kZXJNVGV4dCh7CiAgICAgIGZvcm1hdHRlZFRleHQ6IHBhcnNlci5HZXRDb250ZW50KCksCiAgICAgIGZvbnRTaXplOiBlbnRpdHkuaGVpZ2h0LAogICAgICBwb3NpdGlvbjogZW50aXR5LnBvc2l0aW9uLAogICAgICByb3RhdGlvbjogZW50aXR5LnJvdGF0aW9uLAogICAgICBkaXJlY3Rpb246IGVudGl0eS5kaXJlY3Rpb24sCiAgICAgIGF0dGFjaG1lbnQ6IGVudGl0eS5hdHRhY2htZW50UG9pbnQsCiAgICAgIGxpbmVTcGFjaW5nOiBlbnRpdHkubGluZVNwYWNpbmcsCiAgICAgIHdpZHRoOiBlbnRpdHkud2lkdGgsCiAgICAgIGNvbG9yLAogICAgICBsYXllcgogICAgfSk7CiAgfQoKICAvKioKICAgKiBAcmV0dXJuIHs/TGluZWFyRGltZW5zaW9ufSBEaW1lbnNpb24gaGFuZGxlciBpbnN0YW5jZSwgbnVsbCBpZiBub3QgcG9zc2libGUgdG8gY3JlYXRlIGZyb20KICAgKiB0aGUgcHJvdmlkZWQgZW50aXR5LgogICAqLwogIF9DcmVhdGVMaW5lYXJEaW1lbnNpb24oZW50aXR5KSB7CiAgICBjb25zdCB0eXBlID0gKGVudGl0eS5kaW1lbnNpb25UeXBlIHx8IDApICYgMHhmOwogICAgLyogRm9yIG5vdyBzdXBwb3J0IGxpbmVhciBkaW1lbnNpb25zIG9ubHkuICovCiAgICBpZiAodHlwZSAhPSAwICYmIHR5cGUgIT0gMSB8fCAhZW50aXR5LmxpbmVhck9yQW5ndWxhclBvaW50MSB8fCAhZW50aXR5LmxpbmVhck9yQW5ndWxhclBvaW50MiB8fCAhZW50aXR5LmFuY2hvclBvaW50KSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgbGV0IHN0eWxlID0gbnVsbDsKICAgIGlmIChlbnRpdHkuaGFzT3duUHJvcGVydHkoInN0eWxlTmFtZSIpKSB7CiAgICAgIHN0eWxlID0gdGhpcy5kaW1TdHlsZXMuZ2V0KGVudGl0eS5zdHlsZU5hbWUpOwogICAgfQogICAgY29uc3QgZGltID0gbmV3IExpbmVhckRpbWVuc2lvbih7CiAgICAgIHAxOiBuZXcgVmVjdG9yMigpLmNvcHkoZW50aXR5LmxpbmVhck9yQW5ndWxhclBvaW50MSksCiAgICAgIHAyOiBuZXcgVmVjdG9yMigpLmNvcHkoZW50aXR5LmxpbmVhck9yQW5ndWxhclBvaW50MiksCiAgICAgIGFuY2hvcjogbmV3IFZlY3RvcjIoKS5jb3B5KGVudGl0eS5hbmNob3JQb2ludCksCiAgICAgIGlzQWxpZ25lZDogdHlwZSA9PSAxLAogICAgICBhbmdsZTogZW50aXR5LmFuZ2xlLAogICAgICB0ZXh0OiBlbnRpdHkudGV4dCwKICAgICAgdGV4dEFuY2hvcjogZW50aXR5Lm1pZGRsZU9mVGV4dCA/IG5ldyBWZWN0b3IyKCkuY29weShlbnRpdHkubWlkZGxlT2ZUZXh0KSA6IG51bGwsCiAgICAgIHRleHRSb3RhdGlvbjogZW50aXR5LnRleHRSb3RhdGlvbgoKICAgICAgLyogc3R5bGVSZXNvbHZlciAqLwogICAgfSwgdmFsdWVOYW1lID0+IHsKICAgICAgcmV0dXJuIHRoaXMuX0dldERpbVN0eWxlVmFsdWUodmFsdWVOYW1lLCBlbnRpdHksIHN0eWxlKTsKCiAgICAgIC8qIHRleHRXaWR0aENhbGN1bGF0b3IgKi8KICAgIH0sICh0ZXh0LCBmb250U2l6ZSkgPT4gewogICAgICByZXR1cm4gdGhpcy50ZXh0UmVuZGVyZXIuR2V0TGluZVdpZHRoKHRleHQsIGZvbnRTaXplKTsKICAgIH0pOwogICAgaWYgKCFkaW0uSXNWYWxpZCkgewogICAgICBjb25zb2xlLndhcm4oIkludmFsaWQgZGltZW5zaW9uIGdlb21ldHJ5IGRldGVjdGVkIGZvciAiICsgZW50aXR5LmhhbmRsZSk7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgcmV0dXJuIGRpbTsKICB9CiAgKl9EZWNvbXBvc2VEaW1lbnNpb24oZW50aXR5LCBibG9ja0N0eCkgewogICAgdmFyIF9lbnRpdHkkYmxvY2syOwogICAgaWYgKCgoX2VudGl0eSRibG9jazIgPSBlbnRpdHkuYmxvY2spICE9PSBudWxsICYmIF9lbnRpdHkkYmxvY2syICE9PSB2b2lkIDAgPyBfZW50aXR5JGJsb2NrMiA6IG51bGwpICE9PSBudWxsICYmIHRoaXMuYmxvY2tzLmhhcyhlbnRpdHkuYmxvY2spKSB7CiAgICAgIC8qIERpbWVuc2lvbiBtYXkgaGF2ZSBwcmUtcmVuZGVyZWQgYmxvY2sgYXR0YWNoZWQuIFRoZW4ganVzdCByZW5kZXIgdGhpcyBibG9jayBpbnN0ZWFkCiAgICAgICAqIG9mIHN5bnRoZXNpemluZyBkaW1lbnNpb24gZ2VvbWV0cnkgZnJvbSBwYXJhbWV0ZXJzLgogICAgICAgKgogICAgICAgKiBDcmVhdGUgZHVtbXkgSU5TRVJUIGVudGl0eS4KICAgICAgICovCiAgICAgIGNvbnN0IGluc2VydCA9IHsKICAgICAgICBuYW1lOiBlbnRpdHkuYmxvY2ssCiAgICAgICAgcG9zaXRpb246IHsKICAgICAgICAgIHg6IDAsCiAgICAgICAgICB5OiAwCiAgICAgICAgfSwKICAgICAgICBsYXllcjogZW50aXR5LmxheWVyLAogICAgICAgIGNvbG9yOiBlbnRpdHkuY29sb3IsCiAgICAgICAgY29sb3JJbmRleDogZW50aXR5LmNvbG9ySW5kZXgKICAgICAgfTsKICAgICAgdGhpcy5fUHJvY2Vzc0luc2VydChpbnNlcnQsIGJsb2NrQ3R4KTsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIC8qIGh0dHBzOi8vZXpkeGYucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL3R1dG9yaWFscy9saW5lYXJfZGltZW5zaW9uLmh0bWwKICAgICAqIGh0dHBzOi8vZXpkeGYucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL3RhYmxlcy9kaW1zdHlsZV90YWJsZV9lbnRyeS5odG1sCiAgICAgKi8KCiAgICBjb25zdCBkaW0gPSB0aGlzLl9DcmVhdGVMaW5lYXJEaW1lbnNpb24oZW50aXR5KTsKICAgIGlmICghZGltKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IGxheWVyID0gdGhpcy5fR2V0RW50aXR5TGF5ZXIoZW50aXR5LCBibG9ja0N0eCk7CiAgICBjb25zdCBjb2xvciA9IHRoaXMuX0dldEVudGl0eUNvbG9yKGVudGl0eSwgYmxvY2tDdHgpOwogICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5fR2V0RW50aXR5RXh0cnVzaW9uVHJhbnNmb3JtKGVudGl0eSk7CiAgICBjb25zdCBsYXlvdXQgPSBkaW0uR2VuZXJhdGVMYXlvdXQoKTsKICAgIGZvciAoY29uc3QgbGluZSBvZiBsYXlvdXQubGluZXMpIHsKICAgICAgdmFyIF9saW5lJGNvbG9yOwogICAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdOwogICAgICBpZiAodHJhbnNmb3JtKSB7CiAgICAgICAgbGluZS5zdGFydC5hcHBseU1hdHJpeDModHJhbnNmb3JtKTsKICAgICAgICBsaW5lLmVuZC5hcHBseU1hdHJpeDModHJhbnNmb3JtKTsKICAgICAgfQogICAgICB2ZXJ0aWNlcy5wdXNoKGxpbmUuc3RhcnQsIGxpbmUuZW5kKTsKICAgICAgeWllbGQgbmV3IEVudGl0eSh7CiAgICAgICAgdHlwZTogRW50aXR5LlR5cGUuTElORV9TRUdNRU5UUywKICAgICAgICB2ZXJ0aWNlcywKICAgICAgICBsYXllciwKICAgICAgICBjb2xvcjogKF9saW5lJGNvbG9yID0gbGluZS5jb2xvcikgIT09IG51bGwgJiYgX2xpbmUkY29sb3IgIT09IHZvaWQgMCA/IF9saW5lJGNvbG9yIDogY29sb3IKICAgICAgfSk7CiAgICB9CiAgICBmb3IgKGNvbnN0IHRyaWFuZ2xlIG9mIGxheW91dC50cmlhbmdsZXMpIHsKICAgICAgdmFyIF90cmlhbmdsZSRjb2xvcjsKICAgICAgaWYgKHRyYW5zZm9ybSkgewogICAgICAgIGZvciAoY29uc3QgdiBvZiB0cmlhbmdsZS52ZXJ0aWNlcykgewogICAgICAgICAgdi5hcHBseU1hdHJpeDModHJhbnNmb3JtKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgeWllbGQgbmV3IEVudGl0eSh7CiAgICAgICAgdHlwZTogRW50aXR5LlR5cGUuVFJJQU5HTEVTLAogICAgICAgIHZlcnRpY2VzOiB0cmlhbmdsZS52ZXJ0aWNlcywKICAgICAgICBpbmRpY2VzOiB0cmlhbmdsZS5pbmRpY2VzLAogICAgICAgIGxheWVyLAogICAgICAgIGNvbG9yOiAoX3RyaWFuZ2xlJGNvbG9yID0gdHJpYW5nbGUuY29sb3IpICE9PSBudWxsICYmIF90cmlhbmdsZSRjb2xvciAhPT0gdm9pZCAwID8gX3RyaWFuZ2xlJGNvbG9yIDogY29sb3IKICAgICAgfSk7CiAgICB9CiAgICBpZiAodGhpcy50ZXh0UmVuZGVyZXIuY2FuUmVuZGVyKSB7CiAgICAgIGZvciAoY29uc3QgdGV4dCBvZiBsYXlvdXQudGV4dHMpIHsKICAgICAgICB2YXIgX3RleHQkY29sb3I7CiAgICAgICAgaWYgKHRyYW5zZm9ybSkgewogICAgICAgICAgLy9YWFggZG9lcyBub3QgYWZmZWN0IHRleHQgcm90YXRpb24gYW5kIG1pcnJvcmluZwogICAgICAgICAgdGV4dC5wb3NpdGlvbi5hcHBseU1hdHJpeDModHJhbnNmb3JtKTsKICAgICAgICB9CiAgICAgICAgeWllbGQqIHRoaXMudGV4dFJlbmRlcmVyLlJlbmRlcih7CiAgICAgICAgICB0ZXh0OiB0ZXh0LnRleHQsCiAgICAgICAgICBmb250U2l6ZTogdGV4dC5zaXplLAogICAgICAgICAgc3RhcnRQb3M6IHRleHQucG9zaXRpb24sCiAgICAgICAgICByb3RhdGlvbjogdGV4dC5hbmdsZSwKICAgICAgICAgIGhBbGlnbjogSEFsaWduLkNFTlRFUiwKICAgICAgICAgIHZBbGlnbjogVkFsaWduLk1JRERMRSwKICAgICAgICAgIGNvbG9yOiAoX3RleHQkY29sb3IgPSB0ZXh0LmNvbG9yKSAhPT0gbnVsbCAmJiBfdGV4dCRjb2xvciAhPT0gdm9pZCAwID8gX3RleHQkY29sb3IgOiBjb2xvciwKICAgICAgICAgIGxheWVyCiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICB9CiAgKl9EZWNvbXBvc2VIYXRjaChlbnRpdHksIGJsb2NrQ3R4KSB7CiAgICB2YXIgX2VudGl0eSRoYXRjaFN0eWxlOwogICAgaWYgKGVudGl0eS5pc1NvbGlkKSB7CiAgICAgIC8vWFhYIHNvbGlkIGhhdGNoIG5vdCB5ZXQgc3VwcG9ydGVkCiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IHN0eWxlID0gKF9lbnRpdHkkaGF0Y2hTdHlsZSA9IGVudGl0eS5oYXRjaFN0eWxlKSAhPT0gbnVsbCAmJiBfZW50aXR5JGhhdGNoU3R5bGUgIT09IHZvaWQgMCA/IF9lbnRpdHkkaGF0Y2hTdHlsZSA6IDA7CiAgICBpZiAoc3R5bGUgIT0gSGF0Y2hTdHlsZS5PRERfUEFSSVRZICYmIHN0eWxlICE9IEhhdGNoU3R5bGUuVEhST1VHSF9FTlRJUkVfQVJFQSkgewogICAgICAvL1hYWCBvdGhlciBzdHlsZXMgbm90IHlldCBzdXBwb3J0ZWQKICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3QgYm91bmRhcnlMb29wcyA9IHRoaXMuX0dldEhhdGNoQm91bmRhcnlMb29wcyhlbnRpdHkpOwogICAgaWYgKGJvdW5kYXJ5TG9vcHMubGVuZ3RoID09IDApIHsKICAgICAgY29uc29sZS53YXJuKCJIQVRDSCBlbnRpdHkgd2l0aCBlbXB0eSBib3VuZGFyeSBsb29wcyBhcnJheSAiICsgIihwZXJoYXBzIHNvbWUgbG9vcCB0eXBlcyBhcmUgbm90IGltcGxlbWVudGVkIHlldCkiKTsKICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3QgY2FsYyA9IG5ldyBIYXRjaENhbGN1bGF0b3IoYm91bmRhcnlMb29wcywgc3R5bGUpOwogICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9HZXRFbnRpdHlMYXllcihlbnRpdHksIGJsb2NrQ3R4KTsKICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fR2V0RW50aXR5Q29sb3IoZW50aXR5LCBibG9ja0N0eCk7CiAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLl9HZXRFbnRpdHlFeHRydXNpb25UcmFuc2Zvcm0oZW50aXR5KTsKICAgIGxldCBwYXR0ZXJuID0gbnVsbDsKICAgIGlmIChlbnRpdHkucGF0dGVybk5hbWUpIHsKICAgICAgcGF0dGVybiA9IExvb2t1cFBhdHRlcm4oZW50aXR5LnBhdHRlcm5OYW1lLCB0aGlzLmlzTWV0cmljKTsKICAgICAgaWYgKCFwYXR0ZXJuKSB7CiAgICAgICAgY29uc29sZS5sb2coYEhhdGNoIHBhdHRlcm4gd2l0aCBuYW1lICR7ZW50aXR5LnBhdHRlcm5OYW1lfSBub3QgZm91bmQgYCArIGAobWV0cmljOiAke3RoaXMuaXNNZXRyaWN9KWApOwogICAgICB9CiAgICB9CiAgICBpZiAocGF0dGVybiA9PSBudWxsICYmIGVudGl0eS5kZWZpbml0aW9uTGluZXMpIHsKICAgICAgcGF0dGVybiA9IG5ldyBQYXR0ZXJuKGVudGl0eS5kZWZpbml0aW9uTGluZXMsIG51bGwsIGZhbHNlKTsKICAgIH0KICAgIGlmIChwYXR0ZXJuID09IG51bGwpIHsKICAgICAgcGF0dGVybiA9IExvb2t1cFBhdHRlcm4oIkFOU0kzMSIpOwogICAgfQogICAgaWYgKCFwYXR0ZXJuKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IHNlZWRQb2ludHMgPSBlbnRpdHkuc2VlZFBvaW50cyA/IGVudGl0eS5zZWVkUG9pbnRzIDogW3sKICAgICAgeDogMCwKICAgICAgeTogMAogICAgfV07CiAgICBmb3IgKGNvbnN0IHNlZWRQb2ludCBvZiBzZWVkUG9pbnRzKSB7CiAgICAgIGNvbnN0IHBhdFRyYW5zZm9ybSA9IGNhbGMuR2V0UGF0dGVyblRyYW5zZm9ybSh7CiAgICAgICAgc2VlZFBvaW50LAogICAgICAgIGFuZ2xlOiBlbnRpdHkucGF0dGVybkFuZ2xlLAogICAgICAgIHNjYWxlOiBlbnRpdHkucGF0dGVyblNjYWxlCiAgICAgIH0pOwogICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgcGF0dGVybi5saW5lcykgewogICAgICAgIHZhciBfbGluZSRhbmdsZTM7CiAgICAgICAgbGV0IG9mZnNldFg7CiAgICAgICAgbGV0IG9mZnNldFk7CiAgICAgICAgaWYgKHBhdHRlcm4ub2Zmc2V0SW5MaW5lU3BhY2UpIHsKICAgICAgICAgIG9mZnNldFggPSBsaW5lLm9mZnNldC54OwogICAgICAgICAgb2Zmc2V0WSA9IGxpbmUub2Zmc2V0Lnk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBfbGluZSRhbmdsZSwgX2xpbmUkYW5nbGUyOwogICAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oLSgoX2xpbmUkYW5nbGUgPSBsaW5lLmFuZ2xlKSAhPT0gbnVsbCAmJiBfbGluZSRhbmdsZSAhPT0gdm9pZCAwID8gX2xpbmUkYW5nbGUgOiAwKSk7CiAgICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcygtKChfbGluZSRhbmdsZTIgPSBsaW5lLmFuZ2xlKSAhPT0gbnVsbCAmJiBfbGluZSRhbmdsZTIgIT09IHZvaWQgMCA/IF9saW5lJGFuZ2xlMiA6IDApKTsKICAgICAgICAgIG9mZnNldFggPSBsaW5lLm9mZnNldC54ICogY29zIC0gbGluZS5vZmZzZXQueSAqIHNpbjsKICAgICAgICAgIG9mZnNldFkgPSBsaW5lLm9mZnNldC54ICogc2luICsgbGluZS5vZmZzZXQueSAqIGNvczsKICAgICAgICB9CgogICAgICAgIC8qIE5vcm1hbGl6ZSBvZmZzZXQgc28gdGhhdCBZIGlzIGFsd2F5cyBub24tbmVnYXRpdmUuIEludmVydGluZyBvZmZzZXQgdmVjdG9yCiAgICAgICAgICogZGlyZWN0aW9uIGRvZXMgbm90IGNoYW5nZSBsaW5lcyBwb3NpdGlvbnMuCiAgICAgICAgICovCiAgICAgICAgaWYgKG9mZnNldFkgPCAwKSB7CiAgICAgICAgICBvZmZzZXRZID0gLW9mZnNldFk7CiAgICAgICAgICBvZmZzZXRYID0gLW9mZnNldFg7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGxpbmVUcmFuc2Zvcm0gPSBjYWxjLkdldExpbmVUcmFuc2Zvcm0oewogICAgICAgICAgcGF0VHJhbnNmb3JtLAogICAgICAgICAgYmFzZVBvaW50OiBsaW5lLmJhc2UsCiAgICAgICAgICBhbmdsZTogKF9saW5lJGFuZ2xlMyA9IGxpbmUuYW5nbGUpICE9PSBudWxsICYmIF9saW5lJGFuZ2xlMyAhPT0gdm9pZCAwID8gX2xpbmUkYW5nbGUzIDogMAogICAgICAgIH0pOwogICAgICAgIGNvbnN0IGJib3ggPSBjYWxjLkdldEJvdW5kaW5nQm94KGxpbmVUcmFuc2Zvcm0pOwogICAgICAgIGNvbnN0IG1hcmdpbiA9IChiYm94Lm1heC54IC0gYmJveC5taW4ueCkgKiAwLjA1OwoKICAgICAgICAvKiBGaXJzdCBkZXRlcm1pbmUgcmFuZ2Ugb2YgbGluZSBpbmRpY2VzLiBMaW5lIHdpdGggaW5kZXggMCBnb2VzIHRocm91Z2ggYmFzZSBwb2ludAogICAgICAgICAqICh3aGljaCBpcyBbMDsgMF0gaW4gbGluZSBjb29yZGluYXRlcyBzeXN0ZW0pLiBMaW5lIHdpdGggaW5kZXggYG5gYCBzdGFydHMgaW4gYG5gCiAgICAgICAgICogb2Zmc2V0IHZlY3RvcnMgYWRkZWQgdG8gdGhlIGJhc2UgcG9pbnQuCiAgICAgICAgICovCiAgICAgICAgbGV0IG1pbkxpbmVJZHgsIG1heExpbmVJZHg7CiAgICAgICAgaWYgKG9mZnNldFkgPT0gMCkgewogICAgICAgICAgLyogRGVnZW5lcmF0ZWQgdG8gc2luZ2xlIGxpbmUuICovCiAgICAgICAgICBtaW5MaW5lSWR4ID0gMDsKICAgICAgICAgIG1heExpbmVJZHggPSAwOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBtaW5MaW5lSWR4ID0gTWF0aC5jZWlsKGJib3gubWluLnkgLyBvZmZzZXRZKTsKICAgICAgICAgIG1heExpbmVJZHggPSBNYXRoLmZsb29yKGJib3gubWF4LnkgLyBvZmZzZXRZKTsKICAgICAgICB9CiAgICAgICAgaWYgKG1heExpbmVJZHggLSBtaW5MaW5lSWR4ID4gTUFYX0hBVENIX0xJTkVTKSB7CiAgICAgICAgICBjb25zb2xlLndhcm4oIlRvbyBtYW55IGxpbmVzIHByb2R1Y2VkIGJ5IGhhdGNoaW5nIHBhdHRlcm4iKTsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgICBsZXQgZGFzaFBhdExlbmd0aDsKICAgICAgICBpZiAobGluZS5kYXNoZXMgJiYgbGluZS5kYXNoZXMubGVuZ3RoID4gMSkgewogICAgICAgICAgZGFzaFBhdExlbmd0aCA9IDA7CiAgICAgICAgICBmb3IgKGNvbnN0IGRhc2ggb2YgbGluZS5kYXNoZXMpIHsKICAgICAgICAgICAgaWYgKGRhc2ggPCAwKSB7CiAgICAgICAgICAgICAgZGFzaFBhdExlbmd0aCAtPSBkYXNoOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGRhc2hQYXRMZW5ndGggKz0gZGFzaDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBkYXNoUGF0TGVuZ3RoID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgY29uc3Qgb2NzVHJhbnNmb3JtID0gbGluZVRyYW5zZm9ybS5jbG9uZSgpLmludmVydCgpOwogICAgICAgIGZvciAobGV0IGxpbmVJZHggPSBtaW5MaW5lSWR4OyBsaW5lSWR4IDw9IG1heExpbmVJZHg7IGxpbmVJZHgrKykgewogICAgICAgICAgY29uc3QgeSA9IGxpbmVJZHggKiBvZmZzZXRZOwogICAgICAgICAgY29uc3QgeEJhc2UgPSBsaW5lSWR4ICogb2Zmc2V0WDsKICAgICAgICAgIGNvbnN0IHhTdGFydCA9IGJib3gubWluLnggLSBtYXJnaW47CiAgICAgICAgICBjb25zdCB4RW5kID0gYmJveC5tYXgueCArIG1hcmdpbjsKICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSB4RW5kIC0geFN0YXJ0OwogICAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgVmVjdG9yMih4U3RhcnQsIHkpLmFwcGx5TWF0cml4MyhvY3NUcmFuc2Zvcm0pOwogICAgICAgICAgY29uc3QgZW5kID0gbmV3IFZlY3RvcjIoeEVuZCwgeSkuYXBwbHlNYXRyaXgzKG9jc1RyYW5zZm9ybSk7CiAgICAgICAgICBjb25zdCBsaW5lVmVjID0gZW5kLmNsb25lKCkuc3ViKHN0YXJ0KTsKICAgICAgICAgIGNvbnN0IGNsaXBwZWRTZWdtZW50cyA9IGNhbGMuQ2xpcExpbmUoW3N0YXJ0LCBlbmRdKTsKICAgICAgICAgIGZ1bmN0aW9uIEdldFBhcmFtKHgpIHsKICAgICAgICAgICAgcmV0dXJuICh4IC0geFN0YXJ0KSAvIGxpbmVMZW5ndGg7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBSZW5kZXJTZWdtZW50KHNlZykgewogICAgICAgICAgICBjb25zdCBwMSA9IGxpbmVWZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihzZWdbMF0pLmFkZChzdGFydCk7CiAgICAgICAgICAgIGNvbnN0IHAyID0gbGluZVZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHNlZ1sxXSkuYWRkKHN0YXJ0KTsKICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkgewogICAgICAgICAgICAgIHAxLmFwcGx5TWF0cml4Myh0cmFuc2Zvcm0pOwogICAgICAgICAgICAgIHAyLmFwcGx5TWF0cml4Myh0cmFuc2Zvcm0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzZWdbMV0gLSBzZWdbMF0gPD0gTnVtYmVyLkVQU0lMT04pIHsKICAgICAgICAgICAgICByZXR1cm4gbmV3IEVudGl0eSh7CiAgICAgICAgICAgICAgICB0eXBlOiBFbnRpdHkuVHlwZS5QT0lOVFMsCiAgICAgICAgICAgICAgICB2ZXJ0aWNlczogW3AxXSwKICAgICAgICAgICAgICAgIGxheWVyLAogICAgICAgICAgICAgICAgY29sb3IKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbmV3IEVudGl0eSh7CiAgICAgICAgICAgICAgdHlwZTogRW50aXR5LlR5cGUuTElORV9TRUdNRU5UUywKICAgICAgICAgICAgICB2ZXJ0aWNlczogW3AxLCBwMl0sCiAgICAgICAgICAgICAgbGF5ZXIsCiAgICAgICAgICAgICAgY29sb3IKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CgogICAgICAgICAgLyoqIENsaXAgc2VnbWVudCBhZ2FpbnN0IGBjbGlwcGVkU2VnbWVudHNgLiAqLwogICAgICAgICAgZnVuY3Rpb24qIENsaXBTZWdtZW50KHNlZ1N0YXJ0LCBzZWdFbmQpIHsKICAgICAgICAgICAgZm9yIChjb25zdCBzZWcgb2YgY2xpcHBlZFNlZ21lbnRzKSB7CiAgICAgICAgICAgICAgaWYgKHNlZ1swXSA+PSBzZWdFbmQpIHsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHNlZ1sxXSA8PSBzZWdTdGFydCkgewogICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGNvbnN0IF9zdGFydCA9IE1hdGgubWF4KHNlZ1N0YXJ0LCBzZWdbMF0pOwogICAgICAgICAgICAgIGNvbnN0IF9lbmQgPSBNYXRoLm1pbihzZWdFbmQsIHNlZ1sxXSk7CiAgICAgICAgICAgICAgeWllbGQgW19zdGFydCwgX2VuZF07CiAgICAgICAgICAgICAgc2VnU3RhcnQgPSBfZW5kOwogICAgICAgICAgICB9CiAgICAgICAgICB9CgogICAgICAgICAgLyogRGV0ZXJtaW5lIHJhbmdlIGZvciBzZWdtZW50IGluZGljZXMuIE9uZSBzZWdtZW50IGlzIG9uZSBmdWxsIHNlcXVlbmNlIG9mCiAgICAgICAgICAgKiBkYXNoZXMuIEluIGNhc2UgdGhlcmUgaXMgbm8gZGFzaGVzIChzb2xpZCBsaW5lKSwganVzdCB1c2UgaGF0Y2ggYm91bmRzLgogICAgICAgICAgICovCiAgICAgICAgICBpZiAoZGFzaFBhdExlbmd0aCAhPT0gbnVsbCkgewogICAgICAgICAgICBsZXQgbWluU2VnSWR4ID0gTWF0aC5mbG9vcigoeFN0YXJ0IC0geEJhc2UpIC8gZGFzaFBhdExlbmd0aCk7CiAgICAgICAgICAgIGxldCBtYXhTZWdJZHggPSBNYXRoLmZsb29yKCh4RW5kIC0geEJhc2UpIC8gZGFzaFBhdExlbmd0aCk7CiAgICAgICAgICAgIGlmIChtYXhTZWdJZHggLSBtaW5TZWdJZHggPj0gTUFYX0hBVENIX1NFR01FTlRTKSB7CiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCJUb28gbWFueSBzZWdtZW50cyBwcm9kdWNlZCBieSBoYXRjaGluZyBwYXR0ZXJuIGxpbmUiKTsKICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBmb3IgKGxldCBzZWdJZHggPSBtaW5TZWdJZHg7IHNlZ0lkeCA8PSBtYXhTZWdJZHg7IHNlZ0lkeCsrKSB7CiAgICAgICAgICAgICAgbGV0IHNlZ1N0YXJ0UGFyYW0gPSBHZXRQYXJhbSh4QmFzZSArIHNlZ0lkeCAqIGRhc2hQYXRMZW5ndGgpOwogICAgICAgICAgICAgIGZvciAobGV0IGRhc2hMZW5ndGggb2YgbGluZS5kYXNoZXMpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGlzU3BhY2UgPSBkYXNoTGVuZ3RoIDwgMDsKICAgICAgICAgICAgICAgIGlmIChpc1NwYWNlKSB7CiAgICAgICAgICAgICAgICAgIGRhc2hMZW5ndGggPSAtZGFzaExlbmd0aDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNvbnN0IGRhc2hMZW5ndGhQYXJhbSA9IGRhc2hMZW5ndGggLyBsaW5lTGVuZ3RoOwogICAgICAgICAgICAgICAgaWYgKCFpc1NwYWNlKSB7CiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2VnIG9mIENsaXBTZWdtZW50KHNlZ1N0YXJ0UGFyYW0sIHNlZ1N0YXJ0UGFyYW0gKyBkYXNoTGVuZ3RoUGFyYW0pKSB7CiAgICAgICAgICAgICAgICAgICAgeWllbGQgUmVuZGVyU2VnbWVudChzZWcpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzZWdTdGFydFBhcmFtICs9IGRhc2hMZW5ndGhQYXJhbTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8qIFNpbmdsZSBzb2xpZCBsaW5lLiAqLwogICAgICAgICAgICBmb3IgKGNvbnN0IHNlZyBvZiBjbGlwcGVkU2VnbWVudHMpIHsKICAgICAgICAgICAgICB5aWVsZCBSZW5kZXJTZWdtZW50KHNlZyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CgogIC8qKiBAcmV0dXJuIHtWZWN0b3IyW11bXX0gRWFjaCBsb29wIGlzIGEgbGlzdCBvZiBwb2ludHMgaW4gT0NTIGNvb3JkaW5hdGVzLiAqLwogIF9HZXRIYXRjaEJvdW5kYXJ5TG9vcHMoZW50aXR5KSB7CiAgICBpZiAoIWVudGl0eS5ib3VuZGFyeUxvb3BzKSB7CiAgICAgIHJldHVybiBbXTsKICAgIH0KICAgIGNvbnN0IHJlc3VsdCA9IFtdOwogICAgY29uc3QgQWRkUG9pbnRzID0gKHZlcnRpY2VzLCBwb2ludHMpID0+IHsKICAgICAgY29uc3QgbiA9IHBvaW50cy5sZW5ndGg7CiAgICAgIGlmIChuID09IDApIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA9PSAwKSB7CiAgICAgICAgdmVydGljZXMucHVzaChwb2ludHNbMF0pOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IGxhc3RQdCA9IHZlcnRpY2VzW3ZlcnRpY2VzLmxlbmd0aCAtIDFdOwogICAgICAgIGlmIChsYXN0UHQueCAhPSBwb2ludHNbMF0ueCB8fCBsYXN0UHQueSAhPSBwb2ludHNbMF0ueSkgewogICAgICAgICAgdmVydGljZXMucHVzaChwb2ludHNbMF0pOwogICAgICAgIH0KICAgICAgfQogICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykgewogICAgICAgIHZlcnRpY2VzLnB1c2gocG9pbnRzW2ldKTsKICAgICAgfQogICAgfTsKICAgIGZvciAoY29uc3QgbG9vcCBvZiBlbnRpdHkuYm91bmRhcnlMb29wcykgewogICAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdOwoKICAgICAgLy9YWFggaGFuZGxlIGV4dGVybmFsIHJlZmVyZW5jZXMKCiAgICAgIGlmIChsb29wLnR5cGUgJiAyKSB7CiAgICAgICAgLyogUG9seWxpbmUuICovCiAgICAgICAgZm9yIChsZXQgdnR4SWR4ID0gMDsgdnR4SWR4IDwgbG9vcC5wb2x5bGluZS52ZXJ0aWNlcy5sZW5ndGg7IHZ0eElkeCsrKSB7CiAgICAgICAgICB2YXIgX3Z0eCRidWxnZTsKICAgICAgICAgIGNvbnN0IHZ0eCA9IGxvb3AucG9seWxpbmUudmVydGljZXNbdnR4SWR4XTsKICAgICAgICAgIGlmICgoKF92dHgkYnVsZ2UgPSB2dHguYnVsZ2UpICE9PSBudWxsICYmIF92dHgkYnVsZ2UgIT09IHZvaWQgMCA/IF92dHgkYnVsZ2UgOiAwKSA9PSAwKSB7CiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlY3RvcjIodnR4LngsIHZ0eC55KSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YXIgX3ByZXZWdHgkYnVsZ2U7CiAgICAgICAgICAgIGNvbnN0IHByZXZWdHggPSBsb29wLnBvbHlsaW5lLnZlcnRpY2VzW3Z0eElkeCA9PSAwID8gbG9vcC5wb2x5bGluZS52ZXJ0aWNlcy5sZW5ndGggLSAxIDogdnR4SWR4IC0gMV07CiAgICAgICAgICAgIGlmICgoKF9wcmV2VnR4JGJ1bGdlID0gcHJldlZ0eC5idWxnZSkgIT09IG51bGwgJiYgX3ByZXZWdHgkYnVsZ2UgIT09IHZvaWQgMCA/IF9wcmV2VnR4JGJ1bGdlIDogMCkgPT0gMCkgewogICAgICAgICAgICAgIC8qIFN0YXJ0IHZlcnRleCBpcyBub3QgcHJvZHVjZWQgYnkgX0dlbmVyYXRlQnVsZ2VWZXJ0aWNlcygpLiAqLwogICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlY3RvcjIodnR4LngsIHZ0eC55KSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgbmV4dFZ0eCA9IGxvb3AucG9seWxpbmUudmVydGljZXNbdnR4SWR4ID09IGxvb3AucG9seWxpbmUudmVydGljZXMubGVuZ3RoIC0gMSA/IDAgOiB2dHhJZHggKyAxXTsKICAgICAgICAgICAgdGhpcy5fR2VuZXJhdGVCdWxnZVZlcnRpY2VzKHZlcnRpY2VzLCB2dHgsIG5leHRWdHgsIHZ0eC5idWxnZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKGxvb3AuZWRnZXMgJiYgbG9vcC5lZGdlcy5sZW5ndGggPiAwKSB7CiAgICAgICAgZm9yIChjb25zdCBlZGdlIG9mIGxvb3AuZWRnZXMpIHsKICAgICAgICAgIHN3aXRjaCAoZWRnZS50eXBlKSB7CiAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAvKiBMaW5lIHNlZ21lbnQuICovCiAgICAgICAgICAgICAgQWRkUG9pbnRzKHZlcnRpY2VzLCBbbmV3IFZlY3RvcjIoZWRnZS5zdGFydC54LCBlZGdlLnN0YXJ0LnkpLCBuZXcgVmVjdG9yMihlZGdlLmVuZC54LCBlZGdlLmVuZC55KV0pOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgLyogQ2lyY3VsYXIgYXJjLiAqLwogICAgICAgICAgICAgICAgY29uc3QgYXJjVmVydGljZXMgPSBbXTsKICAgICAgICAgICAgICAgIHRoaXMuX0dlbmVyYXRlQXJjVmVydGljZXMoewogICAgICAgICAgICAgICAgICB2ZXJ0aWNlczogYXJjVmVydGljZXMsCiAgICAgICAgICAgICAgICAgIGNlbnRlcjogZWRnZS5zdGFydCwKICAgICAgICAgICAgICAgICAgcmFkaXVzOiBlZGdlLnJhZGl1cywKICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogZWRnZS5zdGFydEFuZ2xlLAogICAgICAgICAgICAgICAgICBlbmRBbmdsZTogZWRnZS5lbmRBbmdsZSwKICAgICAgICAgICAgICAgICAgY2N3QW5nbGVEaXI6IGVkZ2UuaXNDY3cKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgQWRkUG9pbnRzKHZlcnRpY2VzLCBhcmNWZXJ0aWNlcyk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAvKiBFbGxpcHRpYyBhcmMuICovCiAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSBlZGdlLnN0YXJ0OwogICAgICAgICAgICAgICAgY29uc3QgbWFqb3JBeGlzRW5kUG9pbnQgPSBlZGdlLmVuZDsKICAgICAgICAgICAgICAgIGNvbnN0IHhSID0gTWF0aC5zcXJ0KG1ham9yQXhpc0VuZFBvaW50LnggKiBtYWpvckF4aXNFbmRQb2ludC54ICsgbWFqb3JBeGlzRW5kUG9pbnQueSAqIG1ham9yQXhpc0VuZFBvaW50LnkpOwogICAgICAgICAgICAgICAgY29uc3QgYXhpc1JhdGlvID0gZWRnZS5yYWRpdXM7CiAgICAgICAgICAgICAgICBjb25zdCB5UiA9IHhSICogYXhpc1JhdGlvOwogICAgICAgICAgICAgICAgY29uc3Qgcm90YXRpb24gPSBNYXRoLmF0YW4yKG1ham9yQXhpc0VuZFBvaW50LnksIG1ham9yQXhpc0VuZFBvaW50LngpOwogICAgICAgICAgICAgICAgY29uc3QgYXJjVmVydGljZXMgPSBbXTsKICAgICAgICAgICAgICAgIHRoaXMuX0dlbmVyYXRlQXJjVmVydGljZXMoewogICAgICAgICAgICAgICAgICB2ZXJ0aWNlczogYXJjVmVydGljZXMsCiAgICAgICAgICAgICAgICAgIGNlbnRlciwKICAgICAgICAgICAgICAgICAgcmFkaXVzOiB4UiwKICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogZWRnZS5zdGFydEFuZ2xlLAogICAgICAgICAgICAgICAgICBlbmRBbmdsZTogZWRnZS5lbmRBbmdsZSwKICAgICAgICAgICAgICAgICAgeVJhZGl1czogeVIsCiAgICAgICAgICAgICAgICAgIGNjd0FuZ2xlRGlyOiBlZGdlLmlzQ2N3CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCkgewogICAgICAgICAgICAgICAgICAvL1hYWCBzaG91bGQgYWNjb3VudCBhbmdEaXI/CiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKTsKICAgICAgICAgICAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocm90YXRpb24pOwogICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgYXJjVmVydGljZXMpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHYueCAtIGNlbnRlci54OwogICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5ID0gdi55IC0gY2VudGVyLnk7CiAgICAgICAgICAgICAgICAgICAgLyogUm90YXRlIHRoZSB2ZXJ0ZXggYXJvdW5kIHRoZSBlbGxpcHNlIGNlbnRlciBwb2ludC4gKi8KICAgICAgICAgICAgICAgICAgICB2LnggPSB0eCAqIGNvcyAtIHR5ICogc2luICsgY2VudGVyLng7CiAgICAgICAgICAgICAgICAgICAgdi55ID0gdHggKiBzaW4gKyB0eSAqIGNvcyArIGNlbnRlci55OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBBZGRQb2ludHModmVydGljZXMsIGFyY1ZlcnRpY2VzKTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgIC8qIFNwbGluZS4gKi8KICAgICAgICAgICAgICBjb25zdCBjb250cm9sUG9pbnRzID0gZWRnZS5jb250cm9sUG9pbnRzLm1hcChwID0+IFtwLngsIHAueV0pOwogICAgICAgICAgICAgIGNvbnN0IHN1YmRpdmlzaW9ucyA9IGNvbnRyb2xQb2ludHMubGVuZ3RoICogU1BMSU5FX1NVQkRJVklTSU9OOwogICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSAxIC8gc3ViZGl2aXNpb25zOwogICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHN1YmRpdmlzaW9uczsgaSsrKSB7CiAgICAgICAgICAgICAgICBjb25zdCBwdCA9IHRoaXMuX0ludGVycG9sYXRlU3BsaW5lKGkgKiBzdGVwLCBlZGdlLmRlZ3JlZU9mU3BsaW5lQ3VydmUsIGNvbnRyb2xQb2ludHMsIGVkZ2Uua25vdFZhbHVlcyk7CiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWN0b3IyKHB0WzBdLCBwdFsxXSkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIlVuaGFuZGxlZCBoYXRjaCBib3VuZGFyeSBsb29wIGVkZ2UgdHlwZTogIiArIGVkZ2UudHlwZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPiAyKSB7CiAgICAgICAgY29uc3QgZmlyc3QgPSB2ZXJ0aWNlc1swXTsKICAgICAgICBjb25zdCBsYXN0ID0gdmVydGljZXNbdmVydGljZXMubGVuZ3RoIC0gMV07CiAgICAgICAgaWYgKGxhc3QueCA9PSBmaXJzdC54ICYmIGxhc3QueSA9PSBmaXJzdC55KSB7CiAgICAgICAgICB2ZXJ0aWNlcy5sZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGggLSAxOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAodmVydGljZXMubGVuZ3RoID4gMikgewogICAgICAgIHJlc3VsdC5wdXNoKHZlcnRpY2VzKTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKICB9CiAgX0dldERpbVN0eWxlVmFsdWUodmFsdWVOYW1lLCBlbnRpdHksIHN0eWxlKSB7CiAgICB2YXIgX2VudGl0eSR4ZGF0YTsKICAgIGNvbnN0IGVudHJpZXMgPSBlbnRpdHkgPT09IG51bGwgfHwgZW50aXR5ID09PSB2b2lkIDAgfHwgKF9lbnRpdHkkeGRhdGEgPSBlbnRpdHkueGRhdGEpID09PSBudWxsIHx8IF9lbnRpdHkkeGRhdGEgPT09IHZvaWQgMCB8fCAoX2VudGl0eSR4ZGF0YSA9IF9lbnRpdHkkeGRhdGEuQUNBRCkgPT09IG51bGwgfHwgX2VudGl0eSR4ZGF0YSA9PT0gdm9pZCAwIHx8IChfZW50aXR5JHhkYXRhID0gX2VudGl0eSR4ZGF0YS5EU1RZTEUpID09PSBudWxsIHx8IF9lbnRpdHkkeGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lbnRpdHkkeGRhdGEudmFsdWVzOwogICAgaWYgKGVudHJpZXMpIHsKICAgICAgbGV0IGlzVmFyQ29kZSA9IHRydWU7CiAgICAgIGxldCBmb3VuZCA9IGZhbHNlOwogICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykgewogICAgICAgIGlmIChpc1ZhckNvZGUpIHsKICAgICAgICAgIGlmIChlLmNvZGUgIT0gMTA3MCkgewogICAgICAgICAgICAvKiBVbmV4cGVjdGVkIGdyb3VwIGNvZGUuICovCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGRpbVN0eWxlQ29kZXMuZ2V0KGUudmFsdWUpID09IHZhbHVlTmFtZSkgewogICAgICAgICAgICBmb3VuZCA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChmb3VuZCkgewogICAgICAgICAgcmV0dXJuIGUudmFsdWU7CiAgICAgICAgfQogICAgICAgIGlzVmFyQ29kZSA9ICFpc1ZhckNvZGU7CiAgICAgIH0KICAgIH0KICAgIGlmIChzdHlsZSAmJiBzdHlsZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZU5hbWUpKSB7CiAgICAgIHJldHVybiBzdHlsZVt2YWx1ZU5hbWVdOwogICAgfQogICAgaWYgKHRoaXMudmFycy5oYXModmFsdWVOYW1lKSkgewogICAgICByZXR1cm4gdGhpcy52YXJzLmdldCh2YWx1ZU5hbWUpOwogICAgfQogICAgaWYgKERFRkFVTFRfVkFSUy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZU5hbWUpKSB7CiAgICAgIGNvbnN0IHZhbHVlID0gREVGQVVMVF9WQVJTW3ZhbHVlTmFtZV07CiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7CiAgICAgICAgcmV0dXJuIHZhbHVlLmNhbGwodGhpcyk7CiAgICAgIH0KICAgICAgcmV0dXJuIHZhbHVlOwogICAgfQogICAgcmV0dXJuIG51bGw7CiAgfQoKICAvKioKICAgKiBVcGRhdGVzIGJhdGNoZXMgZGlyZWN0bHkuCiAgICogQHBhcmFtIGVudGl0eQogICAqIEBwYXJhbSBibG9ja0N0eCB7P0Jsb2NrQ29udGV4dH0gTmVzdGVkIGJsb2NrIGluc2VydCB3aGVuIG5vbi1udWxsLgogICAqLwogIF9Qcm9jZXNzSW5zZXJ0KGVudGl0eSwgYmxvY2tDdHggPSBudWxsKSB7CiAgICBpZiAoYmxvY2tDdHgpIHsKICAgICAgLy9YWFggaGFuZGxlIGluZGlyZWN0IHJlY3Vyc2lvbgogICAgICBpZiAoYmxvY2tDdHgubmFtZSA9PT0gZW50aXR5Lm5hbWUpIHsKICAgICAgICBjb25zb2xlLndhcm4oIlJlY3Vyc2l2ZSBibG9jayByZWZlcmVuY2U6ICIgKyBibG9ja0N0eC5uYW1lKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgLyogRmxhdHRlbiBuZXN0ZWQgYmxvY2tzIGRlZmluaXRpb24uICovCiAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5ibG9ja3MuZ2V0KGVudGl0eS5uYW1lKTsKICAgICAgaWYgKCFibG9jaykgewogICAgICAgIGNvbnNvbGUud2FybigiVW5yZXNvbHZlZCBuZXN0ZWQgYmxvY2sgcmVmZXJlbmNlOiAiICsgZW50aXR5Lm5hbWUpOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBjb25zdCBuZXN0ZWRDdHggPSBibG9ja0N0eC5OZXN0ZWRCbG9ja0NvbnRleHQoYmxvY2ssIGVudGl0eSk7CiAgICAgIGlmIChibG9jay5kYXRhLmVudGl0aWVzKSB7CiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgYmxvY2suZGF0YS5lbnRpdGllcykgewogICAgICAgICAgdGhpcy5fUHJvY2Vzc0R4ZkVudGl0eShlbnRpdHksIG5lc3RlZEN0eCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IGJsb2NrID0gdGhpcy5ibG9ja3MuZ2V0KGVudGl0eS5uYW1lKTsKICAgIGlmICghYmxvY2spIHsKICAgICAgY29uc29sZS53YXJuKCJVbnJlc29sdmVkIGJsb2NrIHJlZmVyZW5jZSBpbiBJTlNFUlQ6ICIgKyBlbnRpdHkubmFtZSk7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmICghYmxvY2suSGFzR2VvbWV0cnkoKSkgewogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCBsYXllciA9IHRoaXMuX0dldEVudGl0eUxheWVyKGVudGl0eSwgbnVsbCk7CiAgICBjb25zdCBjb2xvciA9IHRoaXMuX0dldEVudGl0eUNvbG9yKGVudGl0eSwgbnVsbCk7CiAgICBjb25zdCBsaW5lVHlwZSA9IHRoaXMuX0dldExpbmVUeXBlKGVudGl0eSwgbnVsbCwgbnVsbCk7CiAgICAvL1hYWCBhcHBseSBleHRydXNpb24gZGlyZWN0aW9uCiAgICBjb25zdCB0cmFuc2Zvcm0gPSBibG9jay5JbnN0YW50aWF0aW9uQ29udGV4dCgpLkdldEluc2VydGlvblRyYW5zZm9ybShlbnRpdHkpOwoKICAgIC8qIFVwZGF0ZSBib3VuZGluZyBib3ggYW5kIG9yaWdpbiB3aXRoIHRyYW5zZm9ybWVkIGJsb2NrIGJvdW5kcyBjb3JuZXIgcG9pbnRzLiAqLwogICAgY29uc3QgYm91bmRzID0gYmxvY2suYm91bmRzOwogICAgdGhpcy5fVXBkYXRlQm91bmRzKG5ldyBWZWN0b3IyKGJvdW5kcy5taW5YLCBib3VuZHMubWluWSkuYXBwbHlNYXRyaXgzKHRyYW5zZm9ybSkpOwogICAgdGhpcy5fVXBkYXRlQm91bmRzKG5ldyBWZWN0b3IyKGJvdW5kcy5tYXhYLCBib3VuZHMubWF4WSkuYXBwbHlNYXRyaXgzKHRyYW5zZm9ybSkpOwogICAgdGhpcy5fVXBkYXRlQm91bmRzKG5ldyBWZWN0b3IyKGJvdW5kcy5taW5YLCBib3VuZHMubWF4WSkuYXBwbHlNYXRyaXgzKHRyYW5zZm9ybSkpOwogICAgdGhpcy5fVXBkYXRlQm91bmRzKG5ldyBWZWN0b3IyKGJvdW5kcy5tYXhYLCBib3VuZHMubWluWSkuYXBwbHlNYXRyaXgzKHRyYW5zZm9ybSkpOwogICAgdHJhbnNmb3JtLnRyYW5zbGF0ZSgtdGhpcy5vcmlnaW4ueCwgLXRoaXMub3JpZ2luLnkpOwogICAgLy9YWFggZ3JpZCBpbnN0YW5jaW5nIG5vdCBzdXBwb3J0ZWQgeWV0CiAgICBpZiAoYmxvY2suZmxhdHRlbikgewogICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIGJsb2NrLmJhdGNoZXMpIHsKICAgICAgICB0aGlzLl9GbGF0dGVuQmF0Y2goYmF0Y2gsIGxheWVyLCBjb2xvciwgbGluZVR5cGUsIHRyYW5zZm9ybSk7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIGNvbnN0IGtleSA9IG5ldyBCYXRjaGluZ0tleShsYXllciwgZW50aXR5Lm5hbWUsIEJhdGNoaW5nS2V5Lkdlb21ldHJ5VHlwZS5CTE9DS19JTlNUQU5DRSwgY29sb3IsIGxpbmVUeXBlKTsKICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLl9HZXRCYXRjaChrZXkpOwogICAgICBiYXRjaC5QdXNoSW5zdGFuY2VUcmFuc2Zvcm0odHJhbnNmb3JtKTsKICAgIH0KICB9CgogIC8qKiBGbGF0dGVuIGJsb2NrIGRlZmluaXRpb24gYmF0Y2guIEl0IGlzIG1lcmdlZCBpbnRvIHN1aXRhYmxlIGluc3RhbnQgcmVuZGVyaW5nIGJhdGNoLiAqLwogIF9GbGF0dGVuQmF0Y2goYmxvY2tCYXRjaCwgbGF5ZXJOYW1lLCBibG9ja0NvbG9yLCBibG9ja0xpbmVUeXBlLCB0cmFuc2Zvcm0pIHsKICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnMuZ2V0KGxheWVyTmFtZSk7CiAgICBsZXQgY29sb3IsCiAgICAgIGxpbmVUeXBlID0gMDsKICAgIGlmIChibG9ja0JhdGNoLmtleS5jb2xvciA9PT0gQ29sb3JDb2RlLkJZX0JMT0NLKSB7CiAgICAgIGNvbG9yID0gYmxvY2tDb2xvcjsKICAgIH0gZWxzZSBpZiAoYmxvY2tCYXRjaC5rZXkuY29sb3IgPT09IENvbG9yQ29kZS5CWV9MQVlFUikgewogICAgICB2YXIgX2xheWVyJGNvbG9yOwogICAgICBjb2xvciA9IChfbGF5ZXIkY29sb3IgPSBsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIuY29sb3IpICE9PSBudWxsICYmIF9sYXllciRjb2xvciAhPT0gdm9pZCAwID8gX2xheWVyJGNvbG9yIDogMDsKICAgIH0gZWxzZSB7CiAgICAgIGNvbG9yID0gYmxvY2tCYXRjaC5rZXkuY29sb3I7CiAgICB9CiAgICAvL1hYWCBsaW5lIHR5cGUKICAgIGNvbnN0IGtleSA9IG5ldyBCYXRjaGluZ0tleShsYXllck5hbWUsIG51bGwsIGJsb2NrQmF0Y2gua2V5Lmdlb21ldHJ5VHlwZSwgY29sb3IsIGxpbmVUeXBlKTsKICAgIGNvbnN0IGJhdGNoID0gdGhpcy5fR2V0QmF0Y2goa2V5KTsKICAgIGJhdGNoLk1lcmdlKGJsb2NrQmF0Y2gsIHRyYW5zZm9ybSk7CiAgfQoKICAvKioKICAgKiBHZW5lcmF0ZSBlbnRpdGllcyBmb3Igc2hhcGVkIHBvbHlsaW5lIChlLmcuIGxpbmUgcmVzdWx0aW5nIGluIG1lc2gpLiBBbGwgc2VnbWVudHMgYXJlIHNoYXBlZAogICAqIChoYXZlIHN0YXJ0L2VuZCB3aWR0aCkuIFNlZ21lbnRzIG1heSBiZSBidWxnZS4KICAgKiBAcGFyYW0gdmVydGljZXMKICAgKiBAcGFyYW0gbGF5ZXIKICAgKiBAcGFyYW0gY29sb3IKICAgKiBAcGFyYW0gbGluZVR5cGUKICAgKiBAcGFyYW0gc2hhcGUge0Jvb2xlYW59IFRydWUgaWYgY2xvc2VkIHBvbHlsaW5lLgogICAqIEByZXR1cm4ge0dlbmVyYXRvcjxFbnRpdHk+fQogICAqLwogICpfR2VuZXJhdGVTaGFwZWRQb2x5bGluZSh2ZXJ0aWNlcywgbGF5ZXIsIGNvbG9yLCBsaW5lVHlwZSwgc2hhcGUpIHsKICAgIC8vWFhYCiAgICB5aWVsZCBuZXcgRW50aXR5KHsKICAgICAgdHlwZTogRW50aXR5LlR5cGUuUE9MWUxJTkUsCiAgICAgIHZlcnRpY2VzLAogICAgICBsYXllciwKICAgICAgY29sb3IsCiAgICAgIGxpbmVUeXBlLAogICAgICBzaGFwZQogICAgfSk7CiAgfQoKICAvKiogTWlycm9yIGVudGl0eSB2ZXJ0aWNlcyBpZiBuZWNlc3NhcnkgaW4gY2FzZSBvZiBleHRydXNpb25EaXJlY3Rpb24gd2l0aCBuZWdhdGl2ZSBaIHNwZWNpZmllZC4KICAgKgogICAqIEBwYXJhbSBlbnRpdHkgRW50aXR5IHRvIGNoZWNrLgogICAqIEBwYXJhbSB2ZXJ0aWNlcyB7P3t4LHl9W119IFZlcnRpY2VzIGFycmF5IHRvIHVzZSBpbnN0ZWFkIG9mIGVudGl0eSB2ZXJ0aWNlcyBhdHRyaWJ1dGUuCiAgICogQHJldHVybiB7e3gseX1bXX0gVmVydGljZXMgYXJyYXkgd2l0aCBtaXJyb3JlZCBYIGlmIG5lY2Vzc2FyeS4gQWxsIGF0dHJpYnV0ZXMgcHJlc2VydmVkLgogICAqLwogIF9NaXJyb3JFbnRpdHlWZXJ0aWNlcyhlbnRpdHksIHZlcnRpY2VzID0gbnVsbCkgewogICAgaWYgKCFlbnRpdHkuZXh0cnVzaW9uRGlyZWN0aW9uIHx8IGVudGl0eS5leHRydXNpb25EaXJlY3Rpb24ueiA+PSAwKSB7CiAgICAgIHZhciBfdmVydGljZXMyOwogICAgICByZXR1cm4gKF92ZXJ0aWNlczIgPSB2ZXJ0aWNlcykgIT09IG51bGwgJiYgX3ZlcnRpY2VzMiAhPT0gdm9pZCAwID8gX3ZlcnRpY2VzMiA6IGVudGl0eS52ZXJ0aWNlczsKICAgIH0KICAgIGlmICghdmVydGljZXMgfHwgdmVydGljZXMgPT09IGVudGl0eS52ZXJ0aWNlcykgewogICAgICB2ZXJ0aWNlcyA9IGVudGl0eS52ZXJ0aWNlcy5zbGljZSgpOwogICAgfQogICAgY29uc3QgbiA9IHZlcnRpY2VzLmxlbmd0aDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7CiAgICAgIGNvbnN0IHYgPSB2ZXJ0aWNlc1tpXTsKICAgICAgY29uc3QgX3YgPSB7CiAgICAgICAgeDogLXYueAogICAgICB9OwogICAgICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIHYpIHsKICAgICAgICBpZiAoIXYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgaWYgKHByb3BOYW1lICE9PSAieCIpIHsKICAgICAgICAgIF92W3Byb3BOYW1lXSA9IHZbcHJvcE5hbWVdOwogICAgICAgIH0KICAgICAgfQogICAgICB2ZXJ0aWNlc1tpXSA9IF92OwogICAgfQogICAgcmV0dXJuIHZlcnRpY2VzOwogIH0KICAqX0RlY29tcG9zZVBvbHlsaW5lKGVudGl0eSwgYmxvY2tDdHggPSBudWxsKSB7CiAgICBpZiAoZW50aXR5LmlzUG9seWZhY2VNZXNoKSB7CiAgICAgIHlpZWxkKiB0aGlzLl9EZWNvbXBvc2VQb2x5ZmFjZU1lc2goZW50aXR5LCBibG9ja0N0eCk7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGxldCBlbnRpdHlWZXJ0aWNlcywgdmVydGljZXNDb3VudDsKICAgIGlmIChlbnRpdHkuaW5jbHVkZXNDdXJ2ZUZpdFZlcnRpY2VzIHx8IGVudGl0eS5pbmNsdWRlc1NwbGluZUZpdFZlcnRpY2VzKSB7CiAgICAgIGVudGl0eVZlcnRpY2VzID0gZW50aXR5LnZlcnRpY2VzLmZpbHRlcih2ID0+IHYuc3BsaW5lVmVydGV4IHx8IHYuY3VydmVGaXR0aW5nVmVydGV4KTsKICAgICAgdmVydGljZXNDb3VudCA9IGVudGl0eVZlcnRpY2VzLmxlbmd0aDsKICAgIH0gZWxzZSB7CiAgICAgIGVudGl0eVZlcnRpY2VzID0gZW50aXR5LnZlcnRpY2VzOwogICAgICB2ZXJ0aWNlc0NvdW50ID0gZW50aXR5LnZlcnRpY2VzLmxlbmd0aDsKICAgIH0KICAgIGlmICh2ZXJ0aWNlc0NvdW50IDwgMikgewogICAgICByZXR1cm47CiAgICB9CiAgICBlbnRpdHlWZXJ0aWNlcyA9IHRoaXMuX01pcnJvckVudGl0eVZlcnRpY2VzKGVudGl0eSwgZW50aXR5VmVydGljZXMpOwogICAgY29uc3QgY29sb3IgPSB0aGlzLl9HZXRFbnRpdHlDb2xvcihlbnRpdHksIGJsb2NrQ3R4KTsKICAgIGNvbnN0IGxheWVyID0gdGhpcy5fR2V0RW50aXR5TGF5ZXIoZW50aXR5LCBibG9ja0N0eCk7CiAgICBjb25zdCBfdGhpcyA9IHRoaXM7CiAgICBsZXQgc3RhcnRJZHggPSAwOwogICAgbGV0IGN1clBsYWluTGluZSA9IHRoaXMuX0lzUGxhaW5MaW5lKGVudGl0eVZlcnRpY2VzWzBdKTsKICAgIGxldCBjdXJMaW5lVHlwZSA9IHRoaXMuX0dldExpbmVUeXBlKGVudGl0eSwgZW50aXR5VmVydGljZXNbMF0sIGJsb2NrQ3R4KTsKICAgIGxldCBjdXJWZXJ0aWNlcyA9IG51bGw7CiAgICBmdW5jdGlvbiogQ29tbWl0U2VnbWVudChlbmRJZHgpIHsKICAgICAgaWYgKGVuZElkeCA9PT0gc3RhcnRJZHgpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgbGV0IGlzQ2xvc2VkID0gZmFsc2U7CiAgICAgIGxldCB2ZXJ0aWNlcyA9IGN1clZlcnRpY2VzOwogICAgICBpZiAoZW5kSWR4ID09PSB2ZXJ0aWNlc0NvdW50ICYmIHN0YXJ0SWR4ID09PSAwKSB7CiAgICAgICAgaXNDbG9zZWQgPSB0cnVlOwogICAgICAgIGlmICh2ZXJ0aWNlcyA9PT0gbnVsbCkgewogICAgICAgICAgdmVydGljZXMgPSBlbnRpdHlWZXJ0aWNlczsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoZW5kSWR4ID09PSB2ZXJ0aWNlc0NvdW50IC0gMSAmJiBzdGFydElkeCA9PT0gMCkgewogICAgICAgIGlmICh2ZXJ0aWNlcyA9PT0gbnVsbCkgewogICAgICAgICAgdmVydGljZXMgPSBlbnRpdHlWZXJ0aWNlczsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoZW5kSWR4ID09PSB2ZXJ0aWNlc0NvdW50KSB7CiAgICAgICAgaWYgKHZlcnRpY2VzID09PSBudWxsKSB7CiAgICAgICAgICB2ZXJ0aWNlcyA9IGVudGl0eVZlcnRpY2VzLnNsaWNlKHN0YXJ0SWR4LCBlbmRJZHgpOwogICAgICAgICAgdmVydGljZXMucHVzaChlbnRpdHlWZXJ0aWNlc1swXSk7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGlmICh2ZXJ0aWNlcyA9PT0gbnVsbCkgewogICAgICAgICAgdmVydGljZXMgPSBlbnRpdHlWZXJ0aWNlcy5zbGljZShzdGFydElkeCwgZW5kSWR4ICsgMSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChjdXJQbGFpbkxpbmUpIHsKICAgICAgICB5aWVsZCBuZXcgRW50aXR5KHsKICAgICAgICAgIHR5cGU6IEVudGl0eS5UeXBlLlBPTFlMSU5FLAogICAgICAgICAgdmVydGljZXMsCiAgICAgICAgICBsYXllciwKICAgICAgICAgIGNvbG9yLAogICAgICAgICAgbGluZVR5cGU6IGN1ckxpbmVUeXBlLAogICAgICAgICAgc2hhcGU6IGlzQ2xvc2VkCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgeWllbGQqIF90aGlzLl9HZW5lcmF0ZVNoYXBlZFBvbHlsaW5lKHZlcnRpY2VzLCBsYXllciwgY29sb3IsIGN1ckxpbmVUeXBlLCBpc0Nsb3NlZCk7CiAgICAgIH0KICAgICAgc3RhcnRJZHggPSBlbmRJZHg7CiAgICAgIGlmIChlbmRJZHggIT09IHZlcnRpY2VzQ291bnQpIHsKICAgICAgICBjdXJQbGFpbkxpbmUgPSBfdGhpcy5fSXNQbGFpbkxpbmUoZW50aXR5VmVydGljZXNbZW5kSWR4XSk7CiAgICAgICAgY3VyTGluZVR5cGUgPSBfdGhpcy5fR2V0TGluZVR5cGUoZW50aXR5LCBlbnRpdHlWZXJ0aWNlc1tlbmRJZHhdKTsKICAgICAgfQogICAgICBjdXJWZXJ0aWNlcyA9IG51bGw7CiAgICB9CiAgICBmb3IgKGxldCB2SWR4ID0gMTsgdklkeCA8PSB2ZXJ0aWNlc0NvdW50OyB2SWR4KyspIHsKICAgICAgY29uc3QgcHJldlZ0eCA9IGVudGl0eVZlcnRpY2VzW3ZJZHggLSAxXTsKICAgICAgbGV0IHZ0eDsKICAgICAgaWYgKHZJZHggPT09IHZlcnRpY2VzQ291bnQpIHsKICAgICAgICBpZiAoIWVudGl0eS5zaGFwZSkgewogICAgICAgICAgeWllbGQqIENvbW1pdFNlZ21lbnQodklkeCAtIDEpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIHZ0eCA9IGVudGl0eVZlcnRpY2VzWzBdOwogICAgICB9IGVsc2UgewogICAgICAgIHZ0eCA9IGVudGl0eVZlcnRpY2VzW3ZJZHhdOwogICAgICB9CiAgICAgIGlmIChCb29sZWFuKHByZXZWdHguYnVsZ2UpICYmIGN1clBsYWluTGluZSkgewogICAgICAgIGlmIChjdXJWZXJ0aWNlcyA9PT0gbnVsbCkgewogICAgICAgICAgY3VyVmVydGljZXMgPSBlbnRpdHlWZXJ0aWNlcy5zbGljZShzdGFydElkeCwgdklkeCk7CiAgICAgICAgfQogICAgICAgIHRoaXMuX0dlbmVyYXRlQnVsZ2VWZXJ0aWNlcyhjdXJWZXJ0aWNlcywgcHJldlZ0eCwgdnR4LCBwcmV2VnR4LmJ1bGdlKTsKICAgICAgfSBlbHNlIGlmIChjdXJWZXJ0aWNlcyAhPT0gbnVsbCkgewogICAgICAgIGN1clZlcnRpY2VzLnB1c2godnR4KTsKICAgICAgfQogICAgICBpZiAodklkeCA9PT0gdmVydGljZXNDb3VudCkgewogICAgICAgIHlpZWxkKiBDb21taXRTZWdtZW50KHZJZHgpOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGNvbnN0IGlzUGxhaW5MaW5lID0gdGhpcy5fSXNQbGFpbkxpbmUodnR4KTsKICAgICAgY29uc3QgbGluZVR5cGUgPSB0aGlzLl9HZXRMaW5lVHlwZShlbnRpdHksIHZ0eCk7CiAgICAgIGlmIChpc1BsYWluTGluZSAhPT0gY3VyUGxhaW5MaW5lIHx8IC8qIExpbmUgdHlwZSBpcyBhY2NvdW50ZWQgZm9yIHBsYWluIGxpbmVzIG9ubHkuICovCiAgICAgIGN1clBsYWluTGluZSAmJiBsaW5lVHlwZSAhPT0gY3VyTGluZVR5cGUpIHsKICAgICAgICB5aWVsZCogQ29tbWl0U2VnbWVudCh2SWR4KTsKICAgICAgfQogICAgfQogIH0KICAqX0RlY29tcG9zZVBvbHlmYWNlTWVzaChlbnRpdHksIGJsb2NrQ3R4ID0gbnVsbCkgewogICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9HZXRFbnRpdHlMYXllcihlbnRpdHksIGJsb2NrQ3R4KTsKICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fR2V0RW50aXR5Q29sb3IoZW50aXR5LCBibG9ja0N0eCk7CiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdOwogICAgY29uc3QgZmFjZXMgPSBbXTsKICAgIGZvciAoY29uc3QgdiBvZiBlbnRpdHkudmVydGljZXMpIHsKICAgICAgaWYgKHYuZmFjZXMpIHsKICAgICAgICBjb25zdCBmYWNlID0gewogICAgICAgICAgaW5kaWNlczogW10sCiAgICAgICAgICBoaWRkZW5FZGdlczogW10KICAgICAgICB9OwogICAgICAgIGZvciAoY29uc3QgdklkeCBvZiB2LmZhY2VzKSB7CiAgICAgICAgICBpZiAodklkeCA9PSAwKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgZmFjZS5pbmRpY2VzLnB1c2godklkeCA8IDAgPyAtdklkeCAtIDEgOiB2SWR4IC0gMSk7CiAgICAgICAgICBmYWNlLmhpZGRlbkVkZ2VzLnB1c2godklkeCA8IDApOwogICAgICAgIH0KICAgICAgICBpZiAoZmFjZS5pbmRpY2VzLmxlbmd0aCA9PSAzIHx8IGZhY2UuaW5kaWNlcy5sZW5ndGggPT0gNCkgewogICAgICAgICAgZmFjZXMucHVzaChmYWNlKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmVydGljZXMucHVzaChuZXcgVmVjdG9yMih2LngsIHYueSkpOwogICAgICB9CiAgICB9CiAgICBjb25zdCBwb2x5bGluZXMgPSBbXTsKICAgIGNvbnN0IENvbW1pdExpbmVTZWdtZW50ID0gKHN0YXJ0SWR4LCBlbmRJZHgpID0+IHsKICAgICAgaWYgKHBvbHlsaW5lcy5sZW5ndGggPiAwKSB7CiAgICAgICAgY29uc3QgcHJldiA9IHBvbHlsaW5lc1twb2x5bGluZXMubGVuZ3RoIC0gMV07CiAgICAgICAgaWYgKHByZXYuaW5kaWNlc1twcmV2LmluZGljZXMubGVuZ3RoIC0gMV0gPT0gc3RhcnRJZHgpIHsKICAgICAgICAgIHByZXYuaW5kaWNlcy5wdXNoKGVuZElkeCk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGlmIChwcmV2LmluZGljZXNbMF0gPT0gcHJldi5pbmRpY2VzW3ByZXYuaW5kaWNlcy5sZW5ndGggLSAxXSkgewogICAgICAgICAgcHJldi5pc0Nsb3NlZCA9IHRydWU7CiAgICAgICAgfQogICAgICB9CiAgICAgIHBvbHlsaW5lcy5wdXNoKHsKICAgICAgICBpbmRpY2VzOiBbc3RhcnRJZHgsIGVuZElkeF0sCiAgICAgICAgaXNDbG9zZWQ6IGZhbHNlCiAgICAgIH0pOwogICAgfTsKICAgIGZvciAoY29uc3QgZmFjZSBvZiBmYWNlcykgewogICAgICBpZiAodGhpcy5vcHRpb25zLndpcmVmcmFtZU1lc2gpIHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhY2UuaW5kaWNlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgaWYgKGZhY2UuaGlkZGVuRWRnZXNbaV0pIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBuZXh0SWR4ID0gaSA8IGZhY2UuaW5kaWNlcy5sZW5ndGggLSAxID8gaSArIDEgOiAwOwogICAgICAgICAgQ29tbWl0TGluZVNlZ21lbnQoZmFjZS5pbmRpY2VzW2ldLCBmYWNlLmluZGljZXNbbmV4dElkeF0pOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBsZXQgaW5kaWNlczsKICAgICAgICBpZiAoZmFjZS5pbmRpY2VzLmxlbmd0aCA9PSAzKSB7CiAgICAgICAgICBpbmRpY2VzID0gZmFjZS5pbmRpY2VzOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpbmRpY2VzID0gW2ZhY2UuaW5kaWNlc1swXSwgZmFjZS5pbmRpY2VzWzFdLCBmYWNlLmluZGljZXNbMl0sIGZhY2UuaW5kaWNlc1swXSwgZmFjZS5pbmRpY2VzWzJdLCBmYWNlLmluZGljZXNbM11dOwogICAgICAgIH0KICAgICAgICB5aWVsZCBuZXcgRW50aXR5KHsKICAgICAgICAgIHR5cGU6IEVudGl0eS5UeXBlLlRSSUFOR0xFUywKICAgICAgICAgIHZlcnRpY2VzLAogICAgICAgICAgaW5kaWNlcywKICAgICAgICAgIGxheWVyLAogICAgICAgICAgY29sb3IKICAgICAgICB9KTsKICAgICAgfQogICAgfQogICAgaWYgKHRoaXMub3B0aW9ucy53aXJlZnJhbWVNZXNoKSB7CiAgICAgIGZvciAoY29uc3QgcGwgb2YgcG9seWxpbmVzKSB7CiAgICAgICAgaWYgKHBsLmxlbmd0aCA9PSAyKSB7CiAgICAgICAgICB5aWVsZCBuZXcgRW50aXR5KHsKICAgICAgICAgICAgdHlwZTogRW50aXR5LlR5cGUuTElORV9TRUdNRU5UUywKICAgICAgICAgICAgdmVydGljZXM6IFt2ZXJ0aWNlc1twbC5pbmRpY2VzWzBdXSwgdmVydGljZXNbcGwuaW5kaWNlc1sxXV1dLAogICAgICAgICAgICBsYXllciwKICAgICAgICAgICAgY29sb3IKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zdCBfdmVydGljZXMgPSBbXTsKICAgICAgICAgIGZvciAoY29uc3QgdklkeCBvZiBwbC5pbmRpY2VzKSB7CiAgICAgICAgICAgIF92ZXJ0aWNlcy5wdXNoKHZlcnRpY2VzW3ZJZHhdKTsKICAgICAgICAgIH0KICAgICAgICAgIHlpZWxkIG5ldyBFbnRpdHkoewogICAgICAgICAgICB0eXBlOiBFbnRpdHkuVHlwZS5QT0xZTElORSwKICAgICAgICAgICAgdmVydGljZXM6IF92ZXJ0aWNlcywKICAgICAgICAgICAgbGF5ZXIsCiAgICAgICAgICAgIGNvbG9yLAogICAgICAgICAgICBzaGFwZTogcGwuaXNDbG9zZWQKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0KICAqX0RlY29tcG9zZVNwbGluZShlbnRpdHksIGJsb2NrQ3R4ID0gbnVsbCkgewogICAgY29uc3QgY29sb3IgPSB0aGlzLl9HZXRFbnRpdHlDb2xvcihlbnRpdHksIGJsb2NrQ3R4KTsKICAgIGNvbnN0IGxheWVyID0gdGhpcy5fR2V0RW50aXR5TGF5ZXIoZW50aXR5LCBibG9ja0N0eCk7CiAgICBjb25zdCBsaW5lVHlwZSA9IHRoaXMuX0dldExpbmVUeXBlKGVudGl0eSwgbnVsbCwgYmxvY2tDdHgpOwogICAgaWYgKCFlbnRpdHkuY29udHJvbFBvaW50cykgewogICAgICAvL1hYWCBrbm90cyBvciBmaXQgcG9pbnRzIG5vdCBzdXBwb3J0ZWQgeWV0CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IGNvbnRyb2xQb2ludHMgPSBlbnRpdHkuY29udHJvbFBvaW50cy5tYXAocCA9PiBbcC54LCBwLnldKTsKICAgIGNvbnN0IHZlcnRpY2VzID0gW107CiAgICBjb25zdCBzdWJkaXZpc2lvbnMgPSBjb250cm9sUG9pbnRzLmxlbmd0aCAqIFNQTElORV9TVUJESVZJU0lPTjsKICAgIGNvbnN0IHN0ZXAgPSAxIC8gc3ViZGl2aXNpb25zOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc3ViZGl2aXNpb25zOyBpKyspIHsKICAgICAgY29uc3QgcHQgPSB0aGlzLl9JbnRlcnBvbGF0ZVNwbGluZShpICogc3RlcCwgZW50aXR5LmRlZ3JlZU9mU3BsaW5lQ3VydmUsIGNvbnRyb2xQb2ludHMsIGVudGl0eS5rbm90VmFsdWVzKTsKICAgICAgdmVydGljZXMucHVzaCh7CiAgICAgICAgeDogcHRbMF0sCiAgICAgICAgeTogcHRbMV0KICAgICAgfSk7CiAgICB9CiAgICAvL1hYWCBleHRydXNpb25EaXJlY3Rpb24gKG5vcm1hbFZlY3RvcikgdHJhbnNmb3JtPwogICAgeWllbGQgbmV3IEVudGl0eSh7CiAgICAgIHR5cGU6IEVudGl0eS5UeXBlLlBPTFlMSU5FLAogICAgICB2ZXJ0aWNlcywKICAgICAgbGF5ZXIsCiAgICAgIGNvbG9yLAogICAgICBsaW5lVHlwZQogICAgfSk7CiAgfQoKICAvKiogR2V0IGEgcG9pbnQgb24gYSBCLXNwbGluZS4KICAgKiBodHRwczovL2dpdGh1Yi5jb20vdGhpYmF1dHMvYi1zcGxpbmUKICAgKiBAcGFyYW0gdCB7bnVtYmVyfSBQb2ludCBwb3NpdGlvbiBvbiBzcGxpbmUsIFswLi4xXS4KICAgKiBAcGFyYW0gZGVncmVlIHtudW1iZXJ9IEItc3BsaW5lIGRlZ3JlZS4KICAgKiBAcGFyYW0gcG9pbnRzIHtudW1iZXJbXVtdfSBDb250cm9sIHBvaW50cy4gRWFjaCBwb2ludCBzaG91bGQgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24gd2hpY2gKICAgKiAgZGVmaW5lcyBkaW1lbnNpb24gb2YgdGhlIHJlc3VsdC4KICAgKiBAcGFyYW0ga25vdHMgez9udW1iZXJbXX0gS25vdCB2ZWN0b3IuIFNob3VsZCBoYXZlIHNpemUgYHBvaW50cy5sZW5ndGggKyBkZWdyZWUgKyAxYC4gRGVmYXVsdAogICAqICBpcyB1bmlmb3JtIHNwbGluZS4KICAgKiBAcGFyYW0gd2VpZ2h0cyB7P251bWJlcn0gT3B0aW9uYWwgd2VpZ2h0cyB2ZWN0b3IuCiAgICogQHJldHVybiB7bnVtYmVyW119IFJlc3VsdGluZyBwb2ludCBvbiB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLgogICAqLwogIF9JbnRlcnBvbGF0ZVNwbGluZSh0LCBkZWdyZWUsIHBvaW50cywga25vdHMgPSBudWxsLCB3ZWlnaHRzID0gbnVsbCkgewogICAgbGV0IGksIGosIHMsIGw7IC8vIGZ1bmN0aW9uLXNjb3BlZCBpdGVyYXRpb24gdmFyaWFibGVzCiAgICBjb25zdCBuID0gcG9pbnRzLmxlbmd0aDsgLy8gcG9pbnRzIGNvdW50CiAgICBjb25zdCBkID0gcG9pbnRzWzBdLmxlbmd0aDsgLy8gcG9pbnQgZGltZW5zaW9uYWxpdHkKCiAgICBpZiAoZGVncmVlIDwgMSkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkRlZ3JlZSBtdXN0IGJlIGF0IGxlYXN0IDEgKGxpbmVhcikiKTsKICAgIH0KICAgIGlmIChkZWdyZWUgPiBuIC0gMSkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkRlZ3JlZSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBwb2ludCBjb3VudCAtIDEiKTsKICAgIH0KICAgIGlmICghd2VpZ2h0cykgewogICAgICAvLyBidWlsZCB3ZWlnaHQgdmVjdG9yIG9mIGxlbmd0aCBbbl0KICAgICAgd2VpZ2h0cyA9IFtdOwogICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7CiAgICAgICAgd2VpZ2h0c1tpXSA9IDE7CiAgICAgIH0KICAgIH0KICAgIGlmICgha25vdHMpIHsKICAgICAgLy8gYnVpbGQga25vdCB2ZWN0b3Igb2YgbGVuZ3RoIFtuICsgZGVncmVlICsgMV0KICAgICAga25vdHMgPSBbXTsKICAgICAgZm9yIChpID0gMDsgaSA8IG4gKyBkZWdyZWUgKyAxOyBpKyspIHsKICAgICAgICBrbm90c1tpXSA9IGk7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIGlmIChrbm90cy5sZW5ndGggIT09IG4gKyBkZWdyZWUgKyAxKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJCYWQga25vdCB2ZWN0b3IgbGVuZ3RoIik7CiAgICAgIH0KICAgIH0KICAgIGNvbnN0IGRvbWFpbiA9IFtkZWdyZWUsIGtub3RzLmxlbmd0aCAtIDEgLSBkZWdyZWVdOwoKICAgIC8vIHJlbWFwIHQgdG8gdGhlIGRvbWFpbiB3aGVyZSB0aGUgc3BsaW5lIGlzIGRlZmluZWQKICAgIGNvbnN0IGxvdyA9IGtub3RzW2RvbWFpblswXV07CiAgICBjb25zdCBoaWdoID0ga25vdHNbZG9tYWluWzFdXTsKICAgIHQgPSB0ICogKGhpZ2ggLSBsb3cpICsgbG93OwogICAgaWYgKHQgPCBsb3cpIHsKICAgICAgdCA9IGxvdzsKICAgIH0gZWxzZSBpZiAodCA+IGhpZ2gpIHsKICAgICAgdCA9IGhpZ2g7CiAgICB9CgogICAgLy8gZmluZCBzICh0aGUgc3BsaW5lIHNlZ21lbnQpIGZvciB0aGUgW3RdIHZhbHVlIHByb3ZpZGVkCiAgICBmb3IgKHMgPSBkb21haW5bMF07IHMgPCBkb21haW5bMV07IHMrKykgewogICAgICBpZiAodCA+PSBrbm90c1tzXSAmJiB0IDw9IGtub3RzW3MgKyAxXSkgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CgogICAgLy8gY29udmVydCBwb2ludHMgdG8gaG9tb2dlbmVvdXMgY29vcmRpbmF0ZXMKICAgIGNvbnN0IHYgPSBbXTsKICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHsKICAgICAgdltpXSA9IFtdOwogICAgICBmb3IgKGogPSAwOyBqIDwgZDsgaisrKSB7CiAgICAgICAgdltpXVtqXSA9IHBvaW50c1tpXVtqXSAqIHdlaWdodHNbaV07CiAgICAgIH0KICAgICAgdltpXVtkXSA9IHdlaWdodHNbaV07CiAgICB9CgogICAgLy8gbCAobGV2ZWwpIGdvZXMgZnJvbSAxIHRvIHRoZSBjdXJ2ZSBkZWdyZWUgKyAxCiAgICBsZXQgYWxwaGE7CiAgICBmb3IgKGwgPSAxOyBsIDw9IGRlZ3JlZSArIDE7IGwrKykgewogICAgICAvLyBidWlsZCBsZXZlbCBsIG9mIHRoZSBweXJhbWlkCiAgICAgIGZvciAoaSA9IHM7IGkgPiBzIC0gZGVncmVlIC0gMSArIGw7IGktLSkgewogICAgICAgIGFscGhhID0gKHQgLSBrbm90c1tpXSkgLyAoa25vdHNbaSArIGRlZ3JlZSArIDEgLSBsXSAtIGtub3RzW2ldKTsKICAgICAgICAvLyBpbnRlcnBvbGF0ZSBlYWNoIGNvbXBvbmVudAogICAgICAgIGZvciAoaiA9IDA7IGogPCBkICsgMTsgaisrKSB7CiAgICAgICAgICB2W2ldW2pdID0gKDEgLSBhbHBoYSkgKiB2W2kgLSAxXVtqXSArIGFscGhhICogdltpXVtqXTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICAvLyBjb252ZXJ0IGJhY2sgdG8gY2FydGVzaWFuIGFuZCByZXR1cm4KICAgIGNvbnN0IHJlc3VsdCA9IFtdOwogICAgZm9yIChpID0gMDsgaSA8IGQ7IGkrKykgewogICAgICByZXN1bHRbaV0gPSB2W3NdW2ldIC8gdltzXVtkXTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQoKICAvKioKICAgKiBAcGFyYW0gZW50aXR5IHtFbnRpdHl9CiAgICogQHBhcmFtIGJsb2NrQ3R4IHs/QmxvY2tDb250ZXh0fQogICAqLwogIF9Qcm9jZXNzUG9pbnRzKGVudGl0eSwgYmxvY2tDdHggPSBudWxsKSB7CiAgICBjb25zdCBrZXkgPSBuZXcgQmF0Y2hpbmdLZXkoZW50aXR5LmxheWVyLCBibG9ja0N0eCA9PT0gbnVsbCB8fCBibG9ja0N0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvY2tDdHgubmFtZSwgQmF0Y2hpbmdLZXkuR2VvbWV0cnlUeXBlLlBPSU5UUywgZW50aXR5LmNvbG9yLCAwKTsKICAgIGNvbnN0IGJhdGNoID0gdGhpcy5fR2V0QmF0Y2goa2V5KTsKICAgIGZvciAoY29uc3QgdiBvZiBlbnRpdHkudmVydGljZXMpIHsKICAgICAgYmF0Y2guUHVzaFZlcnRleCh0aGlzLl9UcmFuc2Zvcm1WZXJ0ZXgodiwgYmxvY2tDdHgpKTsKICAgIH0KICB9CgogIC8qKgogICAqIEBwYXJhbSBlbnRpdHkge0VudGl0eX0KICAgKiBAcGFyYW0gYmxvY2tDdHggez9CbG9ja0NvbnRleHR9CiAgICovCiAgX1Byb2Nlc3NMaW5lU2VnbWVudHMoZW50aXR5LCBibG9ja0N0eCA9IG51bGwpIHsKICAgIGlmIChlbnRpdHkudmVydGljZXMubGVuZ3RoICUgMiAhPT0gMCkgewogICAgICB0aHJvdyBFcnJvcigiRXZlbiBudW1iZXIgb2YgdmVydGljZXMgZXhwZWN0ZWQiKTsKICAgIH0KICAgIGNvbnN0IGtleSA9IG5ldyBCYXRjaGluZ0tleShlbnRpdHkubGF5ZXIsIGJsb2NrQ3R4ID09PSBudWxsIHx8IGJsb2NrQ3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9ja0N0eC5uYW1lLCBCYXRjaGluZ0tleS5HZW9tZXRyeVR5cGUuTElORVMsIGVudGl0eS5jb2xvciwgZW50aXR5LmxpbmVUeXBlKTsKICAgIGNvbnN0IGJhdGNoID0gdGhpcy5fR2V0QmF0Y2goa2V5KTsKICAgIGZvciAoY29uc3QgdiBvZiBlbnRpdHkudmVydGljZXMpIHsKICAgICAgYmF0Y2guUHVzaFZlcnRleCh0aGlzLl9UcmFuc2Zvcm1WZXJ0ZXgodiwgYmxvY2tDdHgpKTsKICAgIH0KICB9CgogIC8qKgogICAqIEBwYXJhbSBlbnRpdHkge0VudGl0eX0KICAgKiBAcGFyYW0gYmxvY2tDdHggez9CbG9ja0NvbnRleHR9CiAgICovCiAgX1Byb2Nlc3NQb2x5bGluZShlbnRpdHksIGJsb2NrQ3R4ID0gbnVsbCkgewogICAgaWYgKGVudGl0eS52ZXJ0aWNlcy5sZW5ndGggPCAyKSB7CiAgICAgIHJldHVybjsKICAgIH0KICAgIC8qIEl0IGlzIG1vcmUgb3B0aW1hbCB0byByZW5kZXIgc2hvcnQgcG9seWxpbmVzIHVuLWluZGV4ZWQuIEFsc28gRFhGIG9mdGVuIGNvbnRhaW5zCiAgICAgKiBwb2x5bGluZXMgd2l0aCBqdXN0IHR3byBwb2ludHMuCiAgICAgKi8KICAgIGNvbnN0IHZlcnRpY2VzQ291bnQgPSBlbnRpdHkudmVydGljZXMubGVuZ3RoOwogICAgaWYgKHZlcnRpY2VzQ291bnQgPD0gMykgewogICAgICBjb25zdCBrZXkgPSBuZXcgQmF0Y2hpbmdLZXkoZW50aXR5LmxheWVyLCBibG9ja0N0eCA9PT0gbnVsbCB8fCBibG9ja0N0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvY2tDdHgubmFtZSwgQmF0Y2hpbmdLZXkuR2VvbWV0cnlUeXBlLkxJTkVTLCBlbnRpdHkuY29sb3IsIGVudGl0eS5saW5lVHlwZSk7CiAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5fR2V0QmF0Y2goa2V5KTsKICAgICAgbGV0IHByZXYgPSBudWxsOwogICAgICBmb3IgKGNvbnN0IHYgb2YgZW50aXR5LnZlcnRpY2VzKSB7CiAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHsKICAgICAgICAgIGJhdGNoLlB1c2hWZXJ0ZXgodGhpcy5fVHJhbnNmb3JtVmVydGV4KHByZXYsIGJsb2NrQ3R4KSk7CiAgICAgICAgICBiYXRjaC5QdXNoVmVydGV4KHRoaXMuX1RyYW5zZm9ybVZlcnRleCh2LCBibG9ja0N0eCkpOwogICAgICAgIH0KICAgICAgICBwcmV2ID0gdjsKICAgICAgfQogICAgICBpZiAoZW50aXR5LnNoYXBlICYmIHZlcnRpY2VzQ291bnQgPiAyKSB7CiAgICAgICAgYmF0Y2guUHVzaFZlcnRleCh0aGlzLl9UcmFuc2Zvcm1WZXJ0ZXgoZW50aXR5LnZlcnRpY2VzW3ZlcnRpY2VzQ291bnQgLSAxXSwgYmxvY2tDdHgpKTsKICAgICAgICBiYXRjaC5QdXNoVmVydGV4KHRoaXMuX1RyYW5zZm9ybVZlcnRleChlbnRpdHkudmVydGljZXNbMF0sIGJsb2NrQ3R4KSk7CiAgICAgIH0KICAgICAgcmV0dXJuOwogICAgfQogICAgY29uc3Qga2V5ID0gbmV3IEJhdGNoaW5nS2V5KGVudGl0eS5sYXllciwgYmxvY2tDdHggPT09IG51bGwgfHwgYmxvY2tDdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJsb2NrQ3R4Lm5hbWUsIEJhdGNoaW5nS2V5Lkdlb21ldHJ5VHlwZS5JTkRFWEVEX0xJTkVTLCBlbnRpdHkuY29sb3IsIGVudGl0eS5saW5lVHlwZSk7CiAgICBjb25zdCBiYXRjaCA9IHRoaXMuX0dldEJhdGNoKGtleSk7CiAgICAvKiBMaW5lIG1heSBiZSBzcGxpdCBpZiBleGNlZWRzIGNodW5rIGxpbWl0LiAqLwogICAgZm9yIChjb25zdCBsaW5lQ2h1bmsgb2YgZW50aXR5Ll9JdGVyYXRlTGluZUNodW5rcygpKSB7CiAgICAgIGNvbnN0IGNodW5rID0gYmF0Y2guUHVzaENodW5rKGxpbmVDaHVuay52ZXJ0aWNlc0NvdW50KTsKICAgICAgZm9yIChjb25zdCB2IG9mIGxpbmVDaHVuay52ZXJ0aWNlcykgewogICAgICAgIGNodW5rLlB1c2hWZXJ0ZXgodGhpcy5fVHJhbnNmb3JtVmVydGV4KHYsIGJsb2NrQ3R4KSk7CiAgICAgIH0KICAgICAgZm9yIChjb25zdCBpZHggb2YgbGluZUNodW5rLmluZGljZXMpIHsKICAgICAgICBjaHVuay5QdXNoSW5kZXgoaWR4KTsKICAgICAgfQogICAgICBjaHVuay5GaW5pc2goKTsKICAgIH0KICB9CgogIC8qKgogICAqIEBwYXJhbSBlbnRpdHkge0VudGl0eX0KICAgKiBAcGFyYW0gYmxvY2tDdHggez9CbG9ja0NvbnRleHR9CiAgICovCiAgX1Byb2Nlc3NUcmlhbmdsZXMoZW50aXR5LCBibG9ja0N0eCA9IG51bGwpIHsKICAgIGlmIChlbnRpdHkudmVydGljZXMubGVuZ3RoIDwgMykgewogICAgICByZXR1cm47CiAgICB9CiAgICBpZiAoZW50aXR5LmluZGljZXMubGVuZ3RoICUgMyAhPT0gMCkgewogICAgICBjb25zb2xlLmVycm9yKCJVbmV4cGVjdGVkIHNpemUgb2YgaW5kaWNlcyBhcnJheTogIiArIGVudGl0eS5pbmRpY2VzLmxlbmd0aCk7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IGtleSA9IG5ldyBCYXRjaGluZ0tleShlbnRpdHkubGF5ZXIsIGJsb2NrQ3R4ID09PSBudWxsIHx8IGJsb2NrQ3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9ja0N0eC5uYW1lLCBCYXRjaGluZ0tleS5HZW9tZXRyeVR5cGUuSU5ERVhFRF9UUklBTkdMRVMsIGVudGl0eS5jb2xvciwgMCk7CiAgICBjb25zdCBiYXRjaCA9IHRoaXMuX0dldEJhdGNoKGtleSk7CiAgICAvL1hYWCBzcGxpdHRpbmcgaW50byBjaHVua3MgaXMgbm90IHlldCBpbXBsZW1lbnRlZC4gQ3VycmVudGx5IHVzZWQgb25seSBmb3IgdGV4dCBnbHlwaHMgc28KICAgIC8vIHNob3VsZCBmaXQgaW50byBvbmUgY2h1bmsKICAgIGNvbnN0IGNodW5rID0gYmF0Y2guUHVzaENodW5rKGVudGl0eS52ZXJ0aWNlcy5sZW5ndGgpOwogICAgZm9yIChjb25zdCB2IG9mIGVudGl0eS52ZXJ0aWNlcykgewogICAgICBjaHVuay5QdXNoVmVydGV4KHRoaXMuX1RyYW5zZm9ybVZlcnRleCh2LCBibG9ja0N0eCkpOwogICAgfQogICAgZm9yIChjb25zdCBpZHggb2YgZW50aXR5LmluZGljZXMpIHsKICAgICAgY2h1bmsuUHVzaEluZGV4KGlkeCk7CiAgICB9CiAgICBjaHVuay5GaW5pc2goKTsKICB9CgogIC8qKiBSZXNvbHZlIGVudGl0eSBjb2xvci4KICAgKgogICAqIEBwYXJhbSBlbnRpdHkKICAgKiBAcGFyYW0gYmxvY2tDdHggez9CbG9ja0NvbnRleHR9CiAgICogQHJldHVybiB7bnVtYmVyfSBSR0IgY29sb3IgdmFsdWUuIEZvciBibG9jayBlbnRpdHkgaXQgYWxzbyBtYXkgYmUgb25lIG9mIENvbG9yQ29kZSB2YWx1ZXMKICAgKiAgd2hpY2ggYXJlIHJlc29sdmVkIG9uIGJsb2NrIGluc3RhbnRpYXRpb24uCiAgICovCiAgX0dldEVudGl0eUNvbG9yKGVudGl0eSwgYmxvY2tDdHggPSBudWxsKSB7CiAgICBsZXQgY29sb3IgPSBDb2xvckNvZGUuQllfTEFZRVI7CiAgICBpZiAoZW50aXR5LmNvbG9ySW5kZXggPT09IDApIHsKICAgICAgY29sb3IgPSBDb2xvckNvZGUuQllfQkxPQ0s7CiAgICB9IGVsc2UgaWYgKGVudGl0eS5jb2xvckluZGV4ID09PSAyNTYpIHsKICAgICAgY29sb3IgPSBDb2xvckNvZGUuQllfTEFZRVI7CiAgICB9IGVsc2UgaWYgKGVudGl0eS5oYXNPd25Qcm9wZXJ0eSgiY29sb3IiKSkgewogICAgICBjb2xvciA9IGVudGl0eS5jb2xvcjsKICAgIH0KICAgIGlmIChibG9ja0N0eCkgewogICAgICByZXR1cm4gY29sb3I7CiAgICB9CiAgICBpZiAoY29sb3IgPT09IENvbG9yQ29kZS5CWV9MQVlFUiB8fCBjb2xvciA9PT0gQ29sb3JDb2RlLkJZX0JMT0NLKSB7CiAgICAgIC8qIEJZX0JMT0NLIGlzIG5vdCB1c2VmdWwgd2hlbiBub3QgaW4gYmxvY2sgc28gcmVwbGFjZSBpdCBieSBsYXllciBhcyB3ZWxsLiAqLwogICAgICBpZiAoZW50aXR5Lmhhc093blByb3BlcnR5KCJsYXllciIpKSB7CiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVycy5nZXQoZW50aXR5LmxheWVyKTsKICAgICAgICBpZiAobGF5ZXIpIHsKICAgICAgICAgIHJldHVybiBsYXllci5jb2xvcjsKICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBjb2xvcjsKICAgIH0KICAgIC8qIEZhbGxiYWNrIHRvIGJsYWNrLiAqLwogICAgcmV0dXJuIDA7CiAgfQoKICAvKiogQHJldHVybiB7P3N0cmluZ30gTGF5ZXIgbmFtZSwgbnVsbCBmb3IgYmxvY2sgZW50aXR5LiAqLwogIF9HZXRFbnRpdHlMYXllcihlbnRpdHksIGJsb2NrQ3R4ID0gbnVsbCkgewogICAgaWYgKGJsb2NrQ3R4KSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgaWYgKGVudGl0eS5oYXNPd25Qcm9wZXJ0eSgibGF5ZXIiKSkgewogICAgICByZXR1cm4gZW50aXR5LmxheWVyOwogICAgfQogICAgcmV0dXJuICIwIjsKICB9CgogIC8qKiBDaGVjayBleHRydXNpb25EaXJlY3Rpb24gcHJvcGVydHkgb2YgdGhlIGVudGl0eSBhbmQgcmV0dXJuIGNvcnJlc3BvbmRpbmcgdHJhbnNmb3JtIG1hdHJpeC4KICAgKgogICAqIEByZXR1cm4gez9NYXRyaXgzfSBOdWxsIGlmIG5vdCB0cmFuc2Zvcm0gcmVxdWlyZWQuCiAgICovCiAgX0dldEVudGl0eUV4dHJ1c2lvblRyYW5zZm9ybShlbnRpdHkpIHsKICAgIC8vWFhYIEZvciBub3cganVzdCBtaXJyb3IgWCBheGlzIGlmIGV4dHJ1c2lvbiBaIGlzIG5lZ2F0aXZlLiBObyBmdWxsIHN1cHBvcnQgZm9yIGFyYml0cmFyeQogICAgLy8gT0NTIHlldC4KICAgIGlmICghZW50aXR5Lmhhc093blByb3BlcnR5KCJleHRydXNpb25EaXJlY3Rpb24iKSkgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIGlmIChlbnRpdHkuZXh0cnVzaW9uRGlyZWN0aW9uLnogPiAwKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgcmV0dXJuIG5ldyBNYXRyaXgzKCkuc2NhbGUoLTEsIDEpOwogIH0KCiAgLyoqIEByZXR1cm4ge1JlbmRlckJhdGNofSAqLwogIF9HZXRCYXRjaChrZXkpIHsKICAgIGxldCBiYXRjaCA9IHRoaXMuYmF0Y2hlcy5maW5kKHsKICAgICAga2V5CiAgICB9KTsKICAgIGlmIChiYXRjaCAhPT0gbnVsbCkgewogICAgICByZXR1cm4gYmF0Y2g7CiAgICB9CiAgICBiYXRjaCA9IG5ldyBSZW5kZXJCYXRjaChrZXkpOwogICAgdGhpcy5iYXRjaGVzLmluc2VydChiYXRjaCk7CiAgICBpZiAoa2V5LmJsb2NrTmFtZSAhPT0gbnVsbCAmJiAha2V5LklzSW5zdGFuY2VkKCkpIHsKICAgICAgLyogQmxvY2sgZGVmaW5pdGlvbiBiYXRjaC4gKi8KICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmJsb2Nrcy5nZXQoa2V5LmJsb2NrTmFtZSk7CiAgICAgIGlmIChibG9jaykgewogICAgICAgIGJsb2NrLmJhdGNoZXMucHVzaChiYXRjaCk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBiYXRjaDsKICB9CgogIC8qKgogICAqIEFwcGx5IGFsbCBuZWNlc3NhcnkgZmluYWwgdHJhbnNmb3JtcyB0byBhIHZlcnRleCBiZWZvcmUganVzdCBiZWZvcmUgc3RvcmluZyBpdCBpbiBhIHJlbmRlcmluZwogICAqIGJhdGNoLgogICAqIEBwYXJhbSB2IHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fQogICAqIEBwYXJhbSBibG9ja0N0eCB7QmxvY2tDb250ZXh0fQogICAqIEByZXR1cm4ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19CiAgICovCiAgX1RyYW5zZm9ybVZlcnRleCh2LCBibG9ja0N0eCA9IG51bGwpIHsKICAgIGlmIChibG9ja0N0eCkgewogICAgICAvKiBCbG9jayBkZWZpbml0aW9uIGluIGJsb2NrIGNvb3JkaW5hdGVzLiBTbyBpdCBzaG91bGQgbm90IHRvdWNoIGJvdW5kcyBhbmQgb3JpZ2luLiAqLwogICAgICByZXR1cm4gYmxvY2tDdHguVHJhbnNmb3JtVmVydGV4KHYpOwogICAgfQogICAgdGhpcy5fVXBkYXRlQm91bmRzKHYpOwogICAgcmV0dXJuIHsKICAgICAgeDogdi54IC0gdGhpcy5vcmlnaW4ueCwKICAgICAgeTogdi55IC0gdGhpcy5vcmlnaW4ueQogICAgfTsKICB9CgogIC8qKiBAcGFyYW0gdiB7e3gseX19IFZlcnRleCB0byBleHRlbmQgYm91bmRpbmcgYm94IHdpdGggYW5kIHNldCBvcmlnaW4uICovCiAgX1VwZGF0ZUJvdW5kcyh2KSB7CiAgICBpZiAodGhpcy5ib3VuZHMgPT09IG51bGwpIHsKICAgICAgdGhpcy5ib3VuZHMgPSB7CiAgICAgICAgbWluWDogdi54LAogICAgICAgIG1heFg6IHYueCwKICAgICAgICBtaW5ZOiB2LnksCiAgICAgICAgbWF4WTogdi55CiAgICAgIH07CiAgICB9IGVsc2UgewogICAgICBpZiAodi54IDwgdGhpcy5ib3VuZHMubWluWCkgewogICAgICAgIHRoaXMuYm91bmRzLm1pblggPSB2Lng7CiAgICAgIH0gZWxzZSBpZiAodi54ID4gdGhpcy5ib3VuZHMubWF4WCkgewogICAgICAgIHRoaXMuYm91bmRzLm1heFggPSB2Lng7CiAgICAgIH0KICAgICAgaWYgKHYueSA8IHRoaXMuYm91bmRzLm1pblkpIHsKICAgICAgICB0aGlzLmJvdW5kcy5taW5ZID0gdi55OwogICAgICB9IGVsc2UgaWYgKHYueSA+IHRoaXMuYm91bmRzLm1heFkpIHsKICAgICAgICB0aGlzLmJvdW5kcy5tYXhZID0gdi55OwogICAgICB9CiAgICB9CiAgICBpZiAodGhpcy5vcmlnaW4gPT09IG51bGwpIHsKICAgICAgdGhpcy5vcmlnaW4gPSB7CiAgICAgICAgeDogdi54LAogICAgICAgIHk6IHYueQogICAgICB9OwogICAgfQogIH0KICBfQnVpbGRTY2VuZSgpIHsKICAgIGxldCB2ZXJ0aWNlc1NpemUgPSAwOwogICAgbGV0IGluZGljZXNTaXplID0gMDsKICAgIGxldCB0cmFuc2Zvcm1zU2l6ZSA9IDA7CiAgICB0aGlzLmJhdGNoZXMuZWFjaChiID0+IHsKICAgICAgdmVydGljZXNTaXplICs9IGIuR2V0VmVydGljZXNCdWZmZXJTaXplKCk7CiAgICAgIGluZGljZXNTaXplICs9IGIuR2V0SW5kaWNlc0J1ZmZlclNpemUoKTsKICAgICAgdHJhbnNmb3Jtc1NpemUgKz0gYi5HZXRUcmFuc2Zvcm1zU2l6ZSgpOwogICAgfSk7CiAgICBjb25zdCBzY2VuZSA9IHsKICAgICAgdmVydGljZXM6IG5ldyBBcnJheUJ1ZmZlcih2ZXJ0aWNlc1NpemUpLAogICAgICBpbmRpY2VzOiBuZXcgQXJyYXlCdWZmZXIoaW5kaWNlc1NpemUpLAogICAgICB0cmFuc2Zvcm1zOiBuZXcgQXJyYXlCdWZmZXIodHJhbnNmb3Jtc1NpemUpLAogICAgICBiYXRjaGVzOiBbXSwKICAgICAgbGF5ZXJzOiBbXSwKICAgICAgb3JpZ2luOiB0aGlzLm9yaWdpbiwKICAgICAgYm91bmRzOiB0aGlzLmJvdW5kcywKICAgICAgaGFzTWlzc2luZ0NoYXJzOiB0aGlzLmhhc01pc3NpbmdDaGFycwogICAgfTsKICAgIGNvbnN0IGJ1ZmZlcnMgPSB7CiAgICAgIHZlcnRpY2VzOiBuZXcgRmxvYXQzMkFycmF5KHNjZW5lLnZlcnRpY2VzKSwKICAgICAgdmVydGljZXNPZmZzZXQ6IDAsCiAgICAgIGluZGljZXM6IG5ldyBVaW50MTZBcnJheShzY2VuZS5pbmRpY2VzKSwKICAgICAgaW5kaWNlc09mZnNldDogMCwKICAgICAgdHJhbnNmb3JtczogbmV3IEZsb2F0MzJBcnJheShzY2VuZS50cmFuc2Zvcm1zKSwKICAgICAgdHJhbnNmb3Jtc09mZnNldDogMAogICAgfTsKICAgIHRoaXMuYmF0Y2hlcy5lYWNoKGIgPT4gewogICAgICBzY2VuZS5iYXRjaGVzLnB1c2goYi5TZXJpYWxpemUoYnVmZmVycykpOwogICAgfSk7CiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzLnZhbHVlcygpKSB7CiAgICAgIHNjZW5lLmxheWVycy5wdXNoKHsKICAgICAgICBuYW1lOiBsYXllci5uYW1lLAogICAgICAgIGRpc3BsYXlOYW1lOiBsYXllci5kaXNwbGF5TmFtZSwKICAgICAgICBjb2xvcjogbGF5ZXIuY29sb3IKICAgICAgfSk7CiAgICB9CiAgICBzY2VuZS5wb2ludFNoYXBlSGFzRG90ID0gKHRoaXMucGRNb2RlICYgUGRNb2RlLk1BUktfTUFTSykgPT09IFBkTW9kZS5ET1Q7CiAgICByZXR1cm4gc2NlbmU7CiAgfQp9CmNsYXNzIFJlbmRlckJhdGNoIHsKICBjb25zdHJ1Y3RvcihrZXkpIHsKICAgIHRoaXMua2V5ID0ga2V5OwogICAgaWYgKGtleS5Jc0luZGV4ZWQoKSkgewogICAgICB0aGlzLmNodW5rcyA9IFtdOwogICAgfSBlbHNlIGlmIChrZXkuZ2VvbWV0cnlUeXBlID09PSBCYXRjaGluZ0tleS5HZW9tZXRyeVR5cGUuQkxPQ0tfSU5TVEFOQ0UpIHsKICAgICAgdGhpcy50cmFuc2Zvcm1zID0gbmV3IER5bmFtaWNCdWZmZXIoTmF0aXZlVHlwZS5GTE9BVDMyKTsKICAgIH0gZWxzZSB7CiAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgRHluYW1pY0J1ZmZlcihOYXRpdmVUeXBlLkZMT0FUMzIpOwogICAgfQogIH0KICBQdXNoVmVydGV4KHYpIHsKICAgIGNvbnN0IGlkeCA9IHRoaXMudmVydGljZXMuUHVzaCh2LngpOwogICAgdGhpcy52ZXJ0aWNlcy5QdXNoKHYueSk7CiAgICByZXR1cm4gaWR4OwogIH0KCiAgLyoqCiAgICogQHBhcmFtIG1hdHJpeCB7TWF0cml4M30gM3gzIFRyYW5zZm9ybSBtYXRyaXguIEFzc3VtaW5nIDJEIGFmZmluZSB0cmFuc2Zvcm0gc28gb25seSB0b3AgM3gyCiAgICogIHN1Yi1tYXRyaXggaXMgdGFrZW4uCiAgICovCiAgUHVzaEluc3RhbmNlVHJhbnNmb3JtKG1hdHJpeCkgewogICAgLyogU3RvcmluZyBpbiByb3ctbWFqb3Igb3JkZXIgYXMgZXhwZWN0ZWQgYnkgcmVuZGVyZXIuICovCiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCAyOyByb3crKykgewogICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCAzOyBjb2wrKykgewogICAgICAgIHRoaXMudHJhbnNmb3Jtcy5QdXNoKG1hdHJpeC5lbGVtZW50c1tjb2wgKiAzICsgcm93XSk7CiAgICAgIH0KICAgIH0KICB9CgogIC8qKiBUaGlzIG1ldGhvZCBhY3R1YWxseSByZXNlcnZlcyBzcGFjZSBmb3IgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgaW5kZXhlZCB2ZXJ0aWNlcyBpbiBzb21lCiAgICogY2h1bmsuIFRoZSByZXR1cm5lZCBvYmplY3Qgc2hvdWxkIGJlIHVzZWQgdG8gcHVzaCBleGFjdGx5IHRoZSBzYW1lIGFtb3VudCB2ZXJ0aWNlcyBhbmQgYW55CiAgICogbnVtYmVyIG9mIHRoZWlyIHJlZmVycmluZyBpbmRpY2VzLgogICAqIEBwYXJhbSB2ZXJ0aWNlc0NvdW50IE51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgY2h1bmsuCiAgICogQHJldHVybiB7SW5kZXhlZENodW5rV3JpdGVyfQogICAqLwogIFB1c2hDaHVuayh2ZXJ0aWNlc0NvdW50KSB7CiAgICBpZiAodmVydGljZXNDb3VudCA+IElOREVYRURfQ0hVTktfU0laRSkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIlZlcnRpY2VzIGNvdW50IGV4Y2VlZHMgY2h1bmsgbGltaXQ6ICIgKyB2ZXJ0aWNlc0NvdW50KTsKICAgIH0KICAgIC8qIEZpbmQgc3VpdGFibGUgY2h1bmsgd2l0aCBtaW5pbWFsIHJlbWFpbmluZyBzcGFjZSB0byBmaWxsIHRoZW0gYXMgZnVsbHkgYXMgcG9zc2libGUuICovCiAgICBsZXQgY3VyQ2h1bmsgPSBudWxsOwogICAgbGV0IGN1clNwYWNlID0gMDsKICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5jaHVua3MpIHsKICAgICAgY29uc3Qgc3BhY2UgPSBJTkRFWEVEX0NIVU5LX1NJWkUgLSBjaHVuay52ZXJ0aWNlcy5HZXRTaXplKCkgLyAyOwogICAgICBpZiAoc3BhY2UgPCB2ZXJ0aWNlc0NvdW50KSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgaWYgKGN1ckNodW5rID09PSBudWxsIHx8IHNwYWNlIDwgY3VyU3BhY2UpIHsKICAgICAgICBjdXJDaHVuayA9IGNodW5rOwogICAgICAgIGN1clNwYWNlID0gc3BhY2U7CiAgICAgIH0KICAgIH0KICAgIGlmIChjdXJDaHVuayA9PT0gbnVsbCkgewogICAgICBjdXJDaHVuayA9IHRoaXMuX05ld0NodW5rKHZlcnRpY2VzQ291bnQpOwogICAgfQogICAgcmV0dXJuIG5ldyBJbmRleGVkQ2h1bmtXcml0ZXIoY3VyQ2h1bmssIHZlcnRpY2VzQ291bnQpOwogIH0KCiAgLyoqIE1lcmdlIG90aGVyIGJhdGNoIGludG8gdGhpcyBvbmUuIFRoZXkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgZ2VvbWV0cnkgdHlwZS4gSW5zdGFuY2VkIGJhdGNoZXMKICAgKiBhcmUgZGlzYWxsb3dlZC4KICAgKgogICAqIEBwYXJhbSBiYXRjaCB7UmVuZGVyQmF0Y2h9CiAgICogQHBhcmFtIHRyYW5zZm9ybSB7P01hdHJpeDN9IE9wdGlvbmFsIHRyYW5zZm9ybSB0byBhcHBseSBmb3IgbWVyZ2VkIHZlcnRpY2VzLgogICAqLwogIE1lcmdlKGJhdGNoLCB0cmFuc2Zvcm0gPSBudWxsKSB7CiAgICBpZiAodGhpcy5rZXkuZ2VvbWV0cnlUeXBlICE9PSBiYXRjaC5rZXkuZ2VvbWV0cnlUeXBlKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiUmVuZGVyaW5nIGJhdGNoIG1lcmdpbmcgZ2VvbWV0cnkgdHlwZSBtaXNtYXRjaDogIiArIGAke3RoaXMua2V5Lmdlb21ldHJ5VHlwZX0gIT09ICR7YmF0Y2gua2V5Lmdlb21ldHJ5VHlwZX1gKTsKICAgIH0KICAgIGlmICh0aGlzLmtleS5Jc0luc3RhbmNlZCgpKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiQXR0ZW1wdGVkIHRvIG1lcmdlIGluc3RhbmNlZCBiYXRjaCIpOwogICAgfQogICAgaWYgKHRoaXMua2V5LklzSW5kZXhlZCgpKSB7CiAgICAgIC8qIE1lcmdlIGNodW5rcy4gKi8KICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBiYXRjaC5jaHVua3MpIHsKICAgICAgICBjb25zdCB2ZXJ0aWNlc1NpemUgPSBjaHVuay52ZXJ0aWNlcy5zaXplOwogICAgICAgIGNvbnN0IGNodW5rV3JpdGVyID0gdGhpcy5QdXNoQ2h1bmsodmVydGljZXNTaXplIC8gMik7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlc1NpemU7IGkgKz0gMikgewogICAgICAgICAgY29uc3QgdiA9IG5ldyBWZWN0b3IyKGNodW5rLnZlcnRpY2VzLkdldChpKSwgY2h1bmsudmVydGljZXMuR2V0KGkgKyAxKSk7CiAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7CiAgICAgICAgICAgIHYuYXBwbHlNYXRyaXgzKHRyYW5zZm9ybSk7CiAgICAgICAgICB9CiAgICAgICAgICBjaHVua1dyaXRlci5QdXNoVmVydGV4KHYpOwogICAgICAgIH0KICAgICAgICBjb25zdCBudW1JbmRpY2VzID0gY2h1bmsuaW5kaWNlcy5zaXplOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW5kaWNlczsgaSsrKSB7CiAgICAgICAgICBjaHVua1dyaXRlci5QdXNoSW5kZXgoY2h1bmsuaW5kaWNlcy5HZXQoaSkpOwogICAgICAgIH0KICAgICAgICBjaHVua1dyaXRlci5GaW5pc2goKTsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgY29uc3QgbiA9IGJhdGNoLnZlcnRpY2VzLnNpemU7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSArPSAyKSB7CiAgICAgICAgY29uc3QgdiA9IG5ldyBWZWN0b3IyKGJhdGNoLnZlcnRpY2VzLkdldChpKSwgYmF0Y2gudmVydGljZXMuR2V0KGkgKyAxKSk7CiAgICAgICAgaWYgKHRyYW5zZm9ybSkgewogICAgICAgICAgdi5hcHBseU1hdHJpeDModHJhbnNmb3JtKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5QdXNoVmVydGV4KHYpOwogICAgICB9CiAgICB9CiAgfQoKICAvKiogQHJldHVybiBWZXJ0aWNlcyBidWZmZXIgcmVxdWlyZWQgc2l6ZSBpbiBieXRlcy4gKi8KICBHZXRWZXJ0aWNlc0J1ZmZlclNpemUoKSB7CiAgICBpZiAodGhpcy5rZXkuSXNJbmRleGVkKCkpIHsKICAgICAgbGV0IHNpemUgPSAwOwogICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHRoaXMuY2h1bmtzKSB7CiAgICAgICAgc2l6ZSArPSBjaHVuay52ZXJ0aWNlcy5HZXRTaXplKCk7CiAgICAgIH0KICAgICAgcmV0dXJuIHNpemUgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7CiAgICB9IGVsc2UgaWYgKHRoaXMua2V5Lmdlb21ldHJ5VHlwZSA9PT0gQmF0Y2hpbmdLZXkuR2VvbWV0cnlUeXBlLkJMT0NLX0lOU1RBTkNFKSB7CiAgICAgIHJldHVybiAwOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIHRoaXMudmVydGljZXMuR2V0U2l6ZSgpICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UOwogICAgfQogIH0KCiAgLyoqIEByZXR1cm4gSW5kaWNlcyBidWZmZXIgcmVxdWlyZWQgc2l6ZSBpbiBieXRlcy4gKi8KICBHZXRJbmRpY2VzQnVmZmVyU2l6ZSgpIHsKICAgIGlmICh0aGlzLmtleS5Jc0luZGV4ZWQoKSkgewogICAgICBsZXQgc2l6ZSA9IDA7CiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5jaHVua3MpIHsKICAgICAgICBzaXplICs9IGNodW5rLmluZGljZXMuR2V0U2l6ZSgpOwogICAgICB9CiAgICAgIHJldHVybiBzaXplICogVWludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gMDsKICAgIH0KICB9CgogIC8qKiBAcmV0dXJuIEluc3RhbmNlcyB0cmFuc2Zvcm1zIGJ1ZmZlciByZXF1aXJlZCBzaXplIGluIGJ5dGVzLiAqLwogIEdldFRyYW5zZm9ybXNTaXplKCkgewogICAgaWYgKHRoaXMua2V5Lmdlb21ldHJ5VHlwZSA9PT0gQmF0Y2hpbmdLZXkuR2VvbWV0cnlUeXBlLkJMT0NLX0lOU1RBTkNFKSB7CiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybXMuR2V0U2l6ZSgpICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIDA7CiAgICB9CiAgfQogIFNlcmlhbGl6ZShidWZmZXJzKSB7CiAgICBpZiAodGhpcy5rZXkuSXNJbmRleGVkKCkpIHsKICAgICAgY29uc3QgYmF0Y2ggPSB7CiAgICAgICAga2V5OiB0aGlzLmtleSwKICAgICAgICBjaHVua3M6IFtdCiAgICAgIH07CiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5jaHVua3MpIHsKICAgICAgICBiYXRjaC5jaHVua3MucHVzaChjaHVuay5TZXJpYWxpemUoYnVmZmVycykpOwogICAgICB9CiAgICAgIHJldHVybiBiYXRjaDsKICAgIH0gZWxzZSBpZiAodGhpcy5rZXkuZ2VvbWV0cnlUeXBlID09PSBCYXRjaGluZ0tleS5HZW9tZXRyeVR5cGUuQkxPQ0tfSU5TVEFOQ0UpIHsKICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMudHJhbnNmb3Jtcy5HZXRTaXplKCk7CiAgICAgIGNvbnN0IGJhdGNoID0gewogICAgICAgIGtleTogdGhpcy5rZXksCiAgICAgICAgdHJhbnNmb3Jtc09mZnNldDogYnVmZmVycy50cmFuc2Zvcm1zT2Zmc2V0LAogICAgICAgIHRyYW5zZm9ybXNTaXplOiBzaXplCiAgICAgIH07CiAgICAgIHRoaXMudHJhbnNmb3Jtcy5Db3B5VG8oYnVmZmVycy50cmFuc2Zvcm1zLCBidWZmZXJzLnRyYW5zZm9ybXNPZmZzZXQpOwogICAgICBidWZmZXJzLnRyYW5zZm9ybXNPZmZzZXQgKz0gc2l6ZTsKICAgICAgcmV0dXJuIGJhdGNoOwogICAgfSBlbHNlIHsKICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMudmVydGljZXMuR2V0U2l6ZSgpOwogICAgICBjb25zdCBiYXRjaCA9IHsKICAgICAgICBrZXk6IHRoaXMua2V5LAogICAgICAgIHZlcnRpY2VzT2Zmc2V0OiBidWZmZXJzLnZlcnRpY2VzT2Zmc2V0LAogICAgICAgIHZlcnRpY2VzU2l6ZTogc2l6ZQogICAgICB9OwogICAgICB0aGlzLnZlcnRpY2VzLkNvcHlUbyhidWZmZXJzLnZlcnRpY2VzLCBidWZmZXJzLnZlcnRpY2VzT2Zmc2V0KTsKICAgICAgYnVmZmVycy52ZXJ0aWNlc09mZnNldCArPSBzaXplOwogICAgICByZXR1cm4gYmF0Y2g7CiAgICB9CiAgfQogIF9OZXdDaHVuayhpbml0aWFsQ2FwYWNpdHkpIHsKICAgIGNvbnN0IGNodW5rID0gbmV3IEluZGV4ZWRDaHVuayhpbml0aWFsQ2FwYWNpdHkpOwogICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7CiAgICByZXR1cm4gY2h1bms7CiAgfQp9CmNsYXNzIEJsb2NrIHsKICAvKiogQHBhcmFtIGRhdGEge3t9fSBSYXcgRFhGIGVudGl0eS4gKi8KICBjb25zdHJ1Y3RvcihkYXRhKSB7CiAgICB0aGlzLmRhdGEgPSBkYXRhOwogICAgLyogTnVtYmVyIG9mIHRpbWVzIHJlZmVyZW5jZWQgZnJvbSB0b3AtbGV2ZWwgZW50aXRpZXMgKElOU0VSVCkuICovCiAgICB0aGlzLnVzZUNvdW50ID0gMDsKICAgIC8qIE51bWJlciBvZiB0aW1lcyByZWZlcmVuY2VkIGJ5IG90aGVyIGJsb2NrLiAqLwogICAgdGhpcy5uZXN0ZWRVc2VDb3VudCA9IDA7CiAgICAvKiBUb3RhbCBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhpcyBibG9jay4gVXNlZCBmb3IgZmxhdHRlbmluZyBkZWNpc2lvbi4gKi8KICAgIHRoaXMudmVydGljZXNDb3VudCA9IDA7CiAgICAvKiBPZmZzZXQge3gsIHl9IHRvIGFwcGx5IGZvciBhbGwgdmVydGljZXMuIFVzZWQgdG8gbW92ZSBvcmlnaW4gbmVhciB2ZXJ0aWNlcyBsb2NhdGlvbiB0bwogICAgICogbWluaW1pemUgcHJlY2lzaW9uIGxvc3MuCiAgICAgKi8KICAgIHRoaXMub2Zmc2V0ID0gbnVsbDsKICAgIC8qIERlZmluaXRpb24gYmF0Y2hlcy4gVXNlZCBmb3Igcm9vdCBibG9ja3MgZmxhdHRlbmluZy4gKi8KICAgIHRoaXMuYmF0Y2hlcyA9IFtdOwogICAgdGhpcy5mbGF0dGVuID0gZmFsc2U7CiAgICAvKiogQm91bmRzIGluIGJsb2NrIGNvb3JkaW5hdGVzICh3aXRoIG9mZnNldCBhcHBsaWVkKS4gKi8KICAgIHRoaXMuYm91bmRzID0gbnVsbDsKICB9CgogIC8qKiBTZXQgYmxvY2sgZmxhdHRlbmluZyBmbGFnIGJhc2VkIG9uIHVzYWdlIHN0YXRpc3RpY3MuCiAgICogQHJldHVybiB7Qm9vbGVhbn0gTmV3IGZsYXR0ZW4gZmxhZyBzdGF0ZS4KICAgKi8KICBTZXRGbGF0dGVuKCkgewogICAgaWYgKCF0aGlzLkhhc0dlb21ldHJ5KCkpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgLyogRmxhdHRlbiBpZiBhIGJsb2NrIGlzIHVzZWQgb25jZSAocHVyZSBvcHRpbWl6YXRpb24gaWYgc2hhcmVzIGl0cyBsYXllciB3aXRoIG90aGVyCiAgICAgKiBnZW9tZXRyeSkgb3IgaWYgdG90YWwgaW5zdGFuY2VkIHZlcnRpY2VzIG51bWJlciBpcyBsZXNzIHRoYW4gYSB0aHJlc2hvbGQgKHRyYWRlIHNvbWUKICAgICAqIHNwYWNlIGZvciBkcmF3IGNhbGxzIG51bWJlcikuCiAgICAgKi8KICAgIHRoaXMuZmxhdHRlbiA9IHRoaXMudXNlQ291bnQgPT09IDEgfHwgdGhpcy51c2VDb3VudCAqIHRoaXMudmVydGljZXNDb3VudCA8PSBCTE9DS19GTEFUVEVOSU5HX1ZFUlRJQ0VTX1RIUkVTSE9MRDsKICAgIHJldHVybiB0aGlzLmZsYXR0ZW47CiAgfQoKICAvKiogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBoYXMgc29tZXRoaW5nIHRvIGRyYXcuICovCiAgSGFzR2VvbWV0cnkoKSB7CiAgICAvKiBPZmZzZXQgaXMgc2V0IG9uIGZpcnN0IGdlb21ldHJ5IHZlcnRleCBlbmNvdW50ZXJlZC4gKi8KICAgIHJldHVybiB0aGlzLm9mZnNldCAhPT0gbnVsbDsKICB9CgogIC8qKiBAcGFyYW0ge3t9fSBlbnRpdHkgTWF5IGJlIGVpdGhlciBJTlNFUlQgb3IgRElNRU5TSU9OLiAqLwogIFJlZ2lzdGVySW5zZXJ0KGVudGl0eSkgewogICAgdGhpcy51c2VDb3VudCsrOwogIH0KICBSZWdpc3Rlck5lc3RlZFVzZSh1c2VkQnlCbG9jaykgewogICAgdGhpcy5uZXN0ZWRVc2VDb3VudCsrOwogIH0KCiAgLyoqIEByZXR1cm4ge0Jsb2NrQ29udGV4dH0gQ29udGV4dCBmb3IgYmxvY2sgZGVmaW5pdGlvbi4gKi8KICBEZWZpbml0aW9uQ29udGV4dCgpIHsKICAgIHJldHVybiBuZXcgQmxvY2tDb250ZXh0KHRoaXMsIEJsb2NrQ29udGV4dC5UeXBlLkRFRklOSVRJT04pOwogIH0KICBJbnN0YW50aWF0aW9uQ29udGV4dCgpIHsKICAgIHJldHVybiBuZXcgQmxvY2tDb250ZXh0KHRoaXMsIEJsb2NrQ29udGV4dC5UeXBlLklOU1RBTlRJQVRJT04pOwogIH0KICBVcGRhdGVCb3VuZHModikgewogICAgaWYgKHRoaXMuYm91bmRzID09PSBudWxsKSB7CiAgICAgIHRoaXMuYm91bmRzID0gewogICAgICAgIG1pblg6IHYueCwKICAgICAgICBtYXhYOiB2LngsCiAgICAgICAgbWluWTogdi55LAogICAgICAgIG1heFk6IHYueQogICAgICB9OwogICAgfSBlbHNlIHsKICAgICAgaWYgKHYueCA8IHRoaXMuYm91bmRzLm1pblgpIHsKICAgICAgICB0aGlzLmJvdW5kcy5taW5YID0gdi54OwogICAgICB9IGVsc2UgaWYgKHYueCA+IHRoaXMuYm91bmRzLm1heFgpIHsKICAgICAgICB0aGlzLmJvdW5kcy5tYXhYID0gdi54OwogICAgICB9CiAgICAgIGlmICh2LnkgPCB0aGlzLmJvdW5kcy5taW5ZKSB7CiAgICAgICAgdGhpcy5ib3VuZHMubWluWSA9IHYueTsKICAgICAgfSBlbHNlIGlmICh2LnkgPiB0aGlzLmJvdW5kcy5tYXhZKSB7CiAgICAgICAgdGhpcy5ib3VuZHMubWF4WSA9IHYueTsKICAgICAgfQogICAgfQogIH0KfQpjbGFzcyBCbG9ja0NvbnRleHQgewogIGNvbnN0cnVjdG9yKGJsb2NrLCB0eXBlKSB7CiAgICB0aGlzLmJsb2NrID0gYmxvY2s7CiAgICB0aGlzLnR5cGUgPSB0eXBlOwogICAgdGhpcy5vcmlnaW4gPSB0aGlzLmJsb2NrLmRhdGEucG9zaXRpb247CiAgICAvKiBUcmFuc2Zvcm0gdG8gYXBwbHkgZm9yIGJsb2NrIGRlZmluaXRpb24gZW50aXRpZXMgbm90IGluY2x1ZGluZyBibG9jayBvZmZzZXQuICovCiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBNYXRyaXgzKCk7CiAgfQoKICAvKiogQHJldHVybiB7c3RyaW5nfSBCbG9jayBuYW1lICovCiAgZ2V0IG5hbWUoKSB7CiAgICByZXR1cm4gdGhpcy5ibG9jay5kYXRhLm5hbWU7CiAgfQoKICAvKioKICAgKiBAcGFyYW0gdiB7e3gseX19CiAgICogQHJldHVybiB7e3gseX19CiAgICovCiAgVHJhbnNmb3JtVmVydGV4KHYpIHsKICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBWZWN0b3IyKHYueCwgdi55KS5hcHBseU1hdHJpeDModGhpcy50cmFuc2Zvcm0pOwogICAgaWYgKHRoaXMudHlwZSAhPT0gQmxvY2tDb250ZXh0LlR5cGUuREVGSU5JVElPTiAmJiB0aGlzLnR5cGUgIT09IEJsb2NrQ29udGV4dC5UeXBlLk5FU1RFRF9ERUZJTklUSU9OKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiVW5leHBlY3RlZCB0cmFuc2Zvcm0gdHlwZSIpOwogICAgfQogICAgdGhpcy5ibG9jay52ZXJ0aWNlc0NvdW50Kys7CiAgICBpZiAodGhpcy5ibG9jay5vZmZzZXQgPT09IG51bGwpIHsKICAgICAgLyogVGhpcyBpcyB0aGUgZmlyc3QgdmVydGV4LiBUYWtlIGl0IGFzIGEgYmxvY2sgb3JpZ2luLiBTbyB0aGUgcmVzdWx0IGlzIGFsd2F5cyB6ZXJvCiAgICAgICAqIHZlY3RvciBmb3IgdGhlIGZpcnN0IHZlcnRleC4KICAgICAgICovCiAgICAgIHRoaXMuYmxvY2sub2Zmc2V0ID0gcmVzdWx0OwogICAgICBjb25zdCB2ID0gbmV3IFZlY3RvcjIoKTsKICAgICAgdGhpcy5ibG9jay5VcGRhdGVCb3VuZHModik7CiAgICAgIHJldHVybiB2OwogICAgfQogICAgcmVzdWx0LnN1Yih0aGlzLmJsb2NrLm9mZnNldCk7CiAgICB0aGlzLmJsb2NrLlVwZGF0ZUJvdW5kcyhyZXN1bHQpOwogICAgcmV0dXJuIHJlc3VsdDsKICB9CgogIC8qKgogICAqIEdldCB0cmFuc2Zvcm0gZm9yIGJsb2NrIGluc3RhbmNlLgogICAqIEBwYXJhbSBlbnRpdHkgUmF3IERYRiBJTlNFUlQgZW50aXR5LgogICAqIEByZXR1cm4ge01hdHJpeDN9IFRyYW5zZm9ybSBtYXRyaXggZm9yIGJsb2NrIGluc3RhbmNlIHRvIGFwcGx5IHRvIHRoZSBibG9jayBkZWZpbml0aW9uLgogICAqLwogIEdldEluc2VydGlvblRyYW5zZm9ybShlbnRpdHkpIHsKICAgIGNvbnN0IG1JbnNlcnQgPSBuZXcgTWF0cml4MygpLnRyYW5zbGF0ZSgtdGhpcy5vcmlnaW4ueCwgLXRoaXMub3JpZ2luLnkpOwogICAgY29uc3QgeVNjYWxlID0gZW50aXR5LnlTY2FsZSB8fCAxOwogICAgY29uc3QgeFNjYWxlID0gZW50aXR5LnhTY2FsZSB8fCAxOwogICAgY29uc3Qgcm90YXRpb24gPSAtKGVudGl0eS5yb3RhdGlvbiB8fCAwKSAqIE1hdGguUEkgLyAxODA7CiAgICBsZXQgeCA9IGVudGl0eS5wb3NpdGlvbi54OwogICAgY29uc3QgeSA9IGVudGl0eS5wb3NpdGlvbi55OwogICAgbUluc2VydC5zY2FsZSh4U2NhbGUsIHlTY2FsZSk7CiAgICBtSW5zZXJ0LnJvdGF0ZShyb3RhdGlvbik7CiAgICBtSW5zZXJ0LnRyYW5zbGF0ZSh4LCB5KTsKICAgIGlmIChlbnRpdHkuZXh0cnVzaW9uRGlyZWN0aW9uICYmIGVudGl0eS5leHRydXNpb25EaXJlY3Rpb24ueiA8IDApIHsKICAgICAgbUluc2VydC5zY2FsZSgtMSwgMSk7CiAgICB9CiAgICBpZiAodGhpcy50eXBlICE9PSBCbG9ja0NvbnRleHQuVHlwZS5JTlNUQU5USUFUSU9OKSB7CiAgICAgIHJldHVybiBtSW5zZXJ0OwogICAgfQogICAgY29uc3QgbU9mZnNldCA9IG5ldyBNYXRyaXgzKCkudHJhbnNsYXRlKHRoaXMuYmxvY2sub2Zmc2V0LngsIHRoaXMuYmxvY2sub2Zmc2V0LnkpOwogICAgcmV0dXJuIG1JbnNlcnQubXVsdGlwbHkobU9mZnNldCk7CiAgfQoKICAvKioKICAgKiBDcmVhdGUgY29udGV4dCBmb3IgbmVzdGVkIGJsb2NrLgogICAqIEBwYXJhbSBibG9jayB7QmxvY2t9IE5lc3RlZCBibG9jay4KICAgKiBAcGFyYW0gZW50aXR5IFJhdyBEWEYgSU5TRVJUIGVudGl0eS4KICAgKiBAcmV0dXJuIHtCbG9ja0NvbnRleHR9IENvbnRleHQgdG8gdXNlIGZvciBuZXN0ZWQgYmxvY2sgZW50aXRpZXMuCiAgICovCiAgTmVzdGVkQmxvY2tDb250ZXh0KGJsb2NrLCBlbnRpdHkpIHsKICAgIGJsb2NrLlJlZ2lzdGVyTmVzdGVkVXNlKHRoaXMuYmxvY2spOwogICAgY29uc3QgbmVzdGVkQ3R4ID0gbmV3IEJsb2NrQ29udGV4dChibG9jaywgQmxvY2tDb250ZXh0LlR5cGUuTkVTVEVEX0RFRklOSVRJT04pOwogICAgY29uc3QgbmVzdGVkVHJhbnNmb3JtID0gbmVzdGVkQ3R4LkdldEluc2VydGlvblRyYW5zZm9ybShlbnRpdHkpOwogICAgY29uc3QgY3R4ID0gbmV3IEJsb2NrQ29udGV4dCh0aGlzLmJsb2NrLCBCbG9ja0NvbnRleHQuVHlwZS5ORVNURURfREVGSU5JVElPTik7CiAgICBjdHgudHJhbnNmb3JtID0gbmV3IE1hdHJpeDMoKS5tdWx0aXBseU1hdHJpY2VzKHRoaXMudHJhbnNmb3JtLCBuZXN0ZWRUcmFuc2Zvcm0pOwogICAgcmV0dXJuIGN0eDsKICB9Cn0KQmxvY2tDb250ZXh0LlR5cGUgPSBPYmplY3QuZnJlZXplKHsKICBERUZJTklUSU9OOiAwLAogIE5FU1RFRF9ERUZJTklUSU9OOiAxLAogIElOU1RBTlRJQVRJT046IDIKfSk7CmNsYXNzIEluZGV4ZWRDaHVuayB7CiAgY29uc3RydWN0b3IoaW5pdGlhbENhcGFjaXR5KSB7CiAgICBpZiAoaW5pdGlhbENhcGFjaXR5IDwgMTYpIHsKICAgICAgaW5pdGlhbENhcGFjaXR5ID0gMTY7CiAgICB9CiAgICAvKiBBdmVyYWdlIHR3byBpbmRpY2VzIHBlciB2ZXJ0ZXguICovCiAgICB0aGlzLmluZGljZXMgPSBuZXcgRHluYW1pY0J1ZmZlcihOYXRpdmVUeXBlLlVJTlQxNiwgaW5pdGlhbENhcGFjaXR5ICogMik7CiAgICAvKiBUd28gY29tcG9uZW50cyBwZXIgdmVydGV4LiAqLwogICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBEeW5hbWljQnVmZmVyKE5hdGl2ZVR5cGUuRkxPQVQzMiwgaW5pdGlhbENhcGFjaXR5ICogMik7CiAgfQogIFNlcmlhbGl6ZShidWZmZXJzKSB7CiAgICBjb25zdCBjaHVuayA9IHt9OwogICAgewogICAgICBjb25zdCBzaXplID0gdGhpcy52ZXJ0aWNlcy5HZXRTaXplKCk7CiAgICAgIGNodW5rLnZlcnRpY2VzT2Zmc2V0ID0gYnVmZmVycy52ZXJ0aWNlc09mZnNldDsKICAgICAgY2h1bmsudmVydGljZXNTaXplID0gc2l6ZTsKICAgICAgdGhpcy52ZXJ0aWNlcy5Db3B5VG8oYnVmZmVycy52ZXJ0aWNlcywgYnVmZmVycy52ZXJ0aWNlc09mZnNldCk7CiAgICAgIGJ1ZmZlcnMudmVydGljZXNPZmZzZXQgKz0gc2l6ZTsKICAgIH0KICAgIHsKICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuaW5kaWNlcy5HZXRTaXplKCk7CiAgICAgIGNodW5rLmluZGljZXNPZmZzZXQgPSBidWZmZXJzLmluZGljZXNPZmZzZXQ7CiAgICAgIGNodW5rLmluZGljZXNTaXplID0gc2l6ZTsKICAgICAgdGhpcy5pbmRpY2VzLkNvcHlUbyhidWZmZXJzLmluZGljZXMsIGJ1ZmZlcnMuaW5kaWNlc09mZnNldCk7CiAgICAgIGJ1ZmZlcnMuaW5kaWNlc09mZnNldCArPSBzaXplOwogICAgfQogICAgcmV0dXJuIGNodW5rOwogIH0KfQpjbGFzcyBJbmRleGVkQ2h1bmtXcml0ZXIgewogIGNvbnN0cnVjdG9yKGNodW5rLCB2ZXJ0aWNlc0NvdW50KSB7CiAgICB0aGlzLmNodW5rID0gY2h1bms7CiAgICB0aGlzLnZlcnRpY2VzQ291bnQgPSB2ZXJ0aWNlc0NvdW50OwogICAgdGhpcy52ZXJ0aWNlc09mZnNldCA9IHRoaXMuY2h1bmsudmVydGljZXMuR2V0U2l6ZSgpIC8gMjsKICAgIHRoaXMubnVtVmVydGljZXNQdXNoZWQgPSAwOwogIH0KICBQdXNoVmVydGV4KHYpIHsKICAgIGlmICh0aGlzLm51bVZlcnRpY2VzUHVzaGVkID09PSB0aGlzLnZlcnRpY2VzQ291bnQpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCk7CiAgICB9CiAgICB0aGlzLmNodW5rLnZlcnRpY2VzLlB1c2godi54KTsKICAgIHRoaXMuY2h1bmsudmVydGljZXMuUHVzaCh2LnkpOwogICAgdGhpcy5udW1WZXJ0aWNlc1B1c2hlZCsrOwogIH0KICBQdXNoSW5kZXgoaWR4KSB7CiAgICBpZiAoaWR4IDwgMCB8fCBpZHggPj0gdGhpcy52ZXJ0aWNlc0NvdW50KSB7CiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5kZXggb3V0IG9mIHJhbmdlOiAke2lkeH0vJHt0aGlzLnZlcnRpY2VzQ291bnR9YCk7CiAgICB9CiAgICB0aGlzLmNodW5rLmluZGljZXMuUHVzaChpZHggKyB0aGlzLnZlcnRpY2VzT2Zmc2V0KTsKICB9CiAgRmluaXNoKCkgewogICAgaWYgKHRoaXMubnVtVmVydGljZXNQdXNoZWQgIT09IHRoaXMudmVydGljZXNDb3VudCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhbGwgdmVydGljZXMgcHVzaGVkOiAke3RoaXMubnVtVmVydGljZXNQdXNoZWR9LyR7dGhpcy52ZXJ0aWNlc0NvdW50fWApOwogICAgfQogIH0KfQoKLyoqIEludGVybmFsIGVudGl0eSByZXByZXNlbnRhdGlvbi4gRFhGIGZlYXR1cmVzIGFyZSBkZWNvbXBvc2VkIGludG8gdGhlc2Ugc2ltcGxlciBlbnRpdGllcy4gV2hvbGUKICogZW50aXR5IGFsd2F5cyBzaGFyZXMgc2luZ2xlIG1hdGVyaWFsLgogKi8KZXhwb3J0IGNsYXNzIEVudGl0eSB7CiAgLyoqIEBwYXJhbSB0eXBlIHtudW1iZXJ9IFNlZSBFbnRpdHkuVHlwZQogICAqIEBwYXJhbSB2ZXJ0aWNlcyB7e3gsIHl9W119CiAgICogQHBhcmFtIGluZGljZXMgez9udW1iZXJbXX0gSW5kaWNlcyBmb3IgaW5kZXhlZCBnZW9tZXRyeS4KICAgKiBAcGFyYW0gbGF5ZXIgez9zdHJpbmd9CiAgICogQHBhcmFtIGNvbG9yIHtudW1iZXJ9CiAgICogQHBhcmFtIGxpbmVUeXBlIHs/bnVtYmVyfQogICAqIEBwYXJhbSBzaGFwZSB7Qm9vbGVhbn0gdHJ1ZSBpZiBjbG9zZWQgc2hhcGUuCiAgICovCiAgY29uc3RydWN0b3IoewogICAgdHlwZSwKICAgIHZlcnRpY2VzLAogICAgaW5kaWNlcyA9IG51bGwsCiAgICBsYXllciA9IG51bGwsCiAgICBjb2xvciwKICAgIGxpbmVUeXBlID0gMCwKICAgIHNoYXBlID0gZmFsc2UKICB9KSB7CiAgICB0aGlzLnR5cGUgPSB0eXBlOwogICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzOwogICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlczsKICAgIHRoaXMubGF5ZXIgPSBsYXllcjsKICAgIHRoaXMuY29sb3IgPSBjb2xvcjsKICAgIHRoaXMubGluZVR5cGUgPSBsaW5lVHlwZTsKICAgIHRoaXMuc2hhcGUgPSBzaGFwZTsKICB9CiAgKl9JdGVyYXRlVmVydGljZXMoc3RhcnRJbmRleCwgY291bnQpIHsKICAgIGZvciAobGV0IGlkeCA9IHN0YXJ0SW5kZXg7IGlkeCA8IHN0YXJ0SW5kZXggKyBjb3VudDsgaWR4KyspIHsKICAgICAgeWllbGQgdGhpcy52ZXJ0aWNlc1tpZHhdOwogICAgfQogIH0KCiAgLyoqIFNwbGl0IGxpbmUgaW50byBjaHVua3Mgd2l0aCBhdCBtb3N0IElOREVYRURfQ0hVTktfU0laRSB2ZXJ0aWNlcyBpbiBlYWNoIG9uZS4gRWFjaCBjaHVuayBpcwogICAqIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczoKICAgKiAgKiAidmVydGljZXNDb3VudCIgLSBsZW5ndGggb2YgInZlcnRpY2VzIgogICAqICAqICJ2ZXJ0aWNlcyIgLSBpdGVyYXRvciBmb3IgaW5jbHVkZWQgdmVydGljZXMuCiAgICogICogImluZGljZXMiIC0gaXRlcmF0b3IgZm9yIGluZGljZXMuCiAgICogIENsb3NlZCBzaGFwZXMgYXJlIGhhbmRsZWQgcHJvcGVybHkuCiAgICovCiAgKl9JdGVyYXRlTGluZUNodW5rcygpIHsKICAgIGNvbnN0IHZlcnRpY2VzQ291bnQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsKICAgIGlmICh2ZXJ0aWNlc0NvdW50IDwgMikgewogICAgICByZXR1cm47CiAgICB9CiAgICBjb25zdCBfdGhpcyA9IHRoaXM7CiAgICAvKiBjaHVua09mZnNldCA9PSB2ZXJ0aWNlc0NvdW50IGZvciBzaGFwZSBjbG9zaW5nIHZlcnRleC4gKi8KICAgIGZvciAobGV0IGNodW5rT2Zmc2V0ID0gMDsgY2h1bmtPZmZzZXQgPD0gdmVydGljZXNDb3VudDsgY2h1bmtPZmZzZXQgKz0gSU5ERVhFRF9DSFVOS19TSVpFKSB7CiAgICAgIGxldCBjb3VudCA9IHZlcnRpY2VzQ291bnQgLSBjaHVua09mZnNldDsKICAgICAgbGV0IGlzTGFzdDsKICAgICAgaWYgKGNvdW50ID4gSU5ERVhFRF9DSFVOS19TSVpFKSB7CiAgICAgICAgY291bnQgPSBJTkRFWEVEX0NIVU5LX1NJWkU7CiAgICAgICAgaXNMYXN0ID0gZmFsc2U7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaXNMYXN0ID0gdHJ1ZTsKICAgICAgfQogICAgICBpZiAoaXNMYXN0ICYmIHRoaXMuc2hhcGUgJiYgY2h1bmtPZmZzZXQgPiAwICYmIGNvdW50ID09PSBJTkRFWEVEX0NIVU5LX1NJWkUpIHsKICAgICAgICAvKiBDb3JuZXIgY2FzZSAtIHJlcXVpcmVkIHNoYXBlIGNsb3NpbmcgdmVydGV4IGRvZXMgbm90IGZpdCBpbnRvIHRoZSBjaHVuay4gV2lsbAogICAgICAgICogcmVxdWlyZSBhZGRpdGlvbmFsIGNodW5rLgogICAgICAgICovCiAgICAgICAgaXNMYXN0ID0gZmFsc2U7CiAgICAgIH0KICAgICAgaWYgKGNodW5rT2Zmc2V0ID09PSB2ZXJ0aWNlc0NvdW50ICYmICF0aGlzLnNoYXBlKSB7CiAgICAgICAgLyogU2hhcGUgaXMgbm90IGNsb3NlZCBhbmQgaXQgaXMgbGFzdCBjbG9zaW5nIHZlcnRleCBpdGVyYXRpb24uICovCiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgbGV0IHZlcnRpY2VzLCBpbmRpY2VzLCBjaHVua1ZlcnRpY2VzQ291bnQ7CiAgICAgIGlmIChjb3VudCA8IDIpIHsKICAgICAgICAvKiBFaXRoZXIgbGFzdCB2ZXJ0ZXggb3IgbGFzdCBzaGFwZS1jbG9zaW5nIHZlcnRleCwgb3IgYm90aC4gKi8KICAgICAgICBpZiAoY291bnQgPT09IDEgJiYgdGhpcy5zaGFwZSkgewogICAgICAgICAgLyogQm90aC4gKi8KICAgICAgICAgIHZlcnRpY2VzID0gZnVuY3Rpb24qICgpIHsKICAgICAgICAgICAgeWllbGQgdGhpcy52ZXJ0aWNlc1tjaHVua09mZnNldF07CiAgICAgICAgICAgIHlpZWxkIHRoaXMudmVydGljZXNbMF07CiAgICAgICAgICB9KCk7CiAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkgewogICAgICAgICAgLyogSnVzdCBsYXN0IHZlcnRleC4gVGFrZSBwcmV2aW91cyBvbmUgdG8gbWFrZSBhIGxpbmUuICovCiAgICAgICAgICB2ZXJ0aWNlcyA9IGZ1bmN0aW9uKiAoKSB7CiAgICAgICAgICAgIHlpZWxkIHRoaXMudmVydGljZXNbY2h1bmtPZmZzZXQgLSAxXTsKICAgICAgICAgICAgeWllbGQgdGhpcy52ZXJ0aWNlc1tjaHVua09mZnNldF07CiAgICAgICAgICB9KCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8qIEp1c3Qgc2hhcGUtY2xvc2luZyB2ZXJ0ZXguIFRha2UgbGFzdCBvbmUgdG8gbWFrZSBhIGxpbmUuICovCiAgICAgICAgICB2ZXJ0aWNlcyA9IGZ1bmN0aW9uKiAoKSB7CiAgICAgICAgICAgIHlpZWxkIHRoaXMudmVydGljZXNbdmVydGljZXNDb3VudCAtIDFdOwogICAgICAgICAgICB5aWVsZCB0aGlzLnZlcnRpY2VzWzBdOwogICAgICAgICAgfSgpOwogICAgICAgIH0KICAgICAgICBpbmRpY2VzID0gX0l0ZXJhdGVMaW5lSW5kaWNlcygyLCBmYWxzZSk7CiAgICAgICAgY2h1bmtWZXJ0aWNlc0NvdW50ID0gMjsKICAgICAgfSBlbHNlIGlmIChpc0xhc3QgJiYgdGhpcy5zaGFwZSAmJiBjaHVua09mZnNldCA+IDAgJiYgY291bnQgPCBJTkRFWEVEX0NIVU5LX1NJWkUpIHsKICAgICAgICAvKiBBZGRpdGlvbmFsIHZlcnRleCB0byBjbG9zZSB0aGUgc2hhcGUuICovCiAgICAgICAgdmVydGljZXMgPSBmdW5jdGlvbiogKCkgewogICAgICAgICAgeWllbGQqIF90aGlzLl9JdGVyYXRlVmVydGljZXMoY2h1bmtPZmZzZXQsIGNvdW50KTsKICAgICAgICAgIHlpZWxkIHRoaXMudmVydGljZXNbMF07CiAgICAgICAgfSgpOwogICAgICAgIGluZGljZXMgPSBfSXRlcmF0ZUxpbmVJbmRpY2VzKGNvdW50ICsgMSwgZmFsc2UpOwogICAgICAgIGNodW5rVmVydGljZXNDb3VudCA9IGNvdW50ICsgMTsKICAgICAgfSBlbHNlIHsKICAgICAgICB2ZXJ0aWNlcyA9IHRoaXMuX0l0ZXJhdGVWZXJ0aWNlcyhjaHVua09mZnNldCwgY291bnQpOwogICAgICAgIGluZGljZXMgPSBfSXRlcmF0ZUxpbmVJbmRpY2VzKGNvdW50LCBpc0xhc3QgJiYgY2h1bmtPZmZzZXQgPT09IDAgJiYgdGhpcy5zaGFwZSk7CiAgICAgICAgY2h1bmtWZXJ0aWNlc0NvdW50ID0gY291bnQ7CiAgICAgIH0KICAgICAgeWllbGQgewogICAgICAgIHZlcnRpY2VzQ291bnQ6IGNodW5rVmVydGljZXNDb3VudCwKICAgICAgICB2ZXJ0aWNlcywKICAgICAgICBpbmRpY2VzCiAgICAgIH07CiAgICB9CiAgfQp9CkVudGl0eS5UeXBlID0gT2JqZWN0LmZyZWV6ZSh7CiAgUE9JTlRTOiAwLAogIC8qKiBFYWNoIHZlcnRpY2VzIHBhaXIgZGVmaW5lcyBhIHNlZ21lbnQuICovCiAgTElORV9TRUdNRU5UUzogMSwKICBQT0xZTElORTogMiwKICBUUklBTkdMRVM6IDMKfSk7CmZ1bmN0aW9uKiBfSXRlcmF0ZUxpbmVJbmRpY2VzKHZlcnRpY2VzQ291bnQsIGNsb3NlKSB7CiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdmVydGljZXNDb3VudCAtIDE7IGlkeCsrKSB7CiAgICB5aWVsZCBpZHg7CiAgICB5aWVsZCBpZHggKyAxOwogIH0KICBpZiAoY2xvc2UgJiYgdmVydGljZXNDb3VudCA+IDIpIHsKICAgIHlpZWxkIHZlcnRpY2VzQ291bnQgLSAxOwogICAgeWllbGQgMDsKICB9Cn0KCi8qKiBQb2ludCBkaXNwbGF5IG1vZGUsICRQRE1PREUgc3lzdGVtIHZhcmlhYmxlLiAqLwpjb25zdCBQZE1vZGUgPSBPYmplY3QuZnJlZXplKHsKICBET1Q6IDAsCiAgTk9ORTogMSwKICBQTFVTOiAyLAogIENST1NTOiAzLAogIFRJQ0s6IDQsCiAgTUFSS19NQVNLOiAweGYsCiAgQ0lSQ0xFOiAweDIwLAogIFNRVUFSRTogMHg0MCwKICBTSEFQRV9NQVNLOiAweGYwCn0pOwoKLyoqIFNwZWNpYWwgY29sb3IgdmFsdWVzLCB1c2VkIGZvciBibG9jayBlbnRpdGllcy4gUmVndWxhciBlbnRpdGllcyBjb2xvciBpcyByZXNvbHZlZCBpbnN0YW50bHkuICovCmV4cG9ydCBjb25zdCBDb2xvckNvZGUgPSBPYmplY3QuZnJlZXplKHsKICBCWV9MQVlFUjogLTEsCiAgQllfQkxPQ0s6IC0yCn0pOwpEeGZTY2VuZS5EZWZhdWx0T3B0aW9ucyA9IHsKICAvKiogVGFyZ2V0IGFuZ2xlIGZvciBlYWNoIHNlZ21lbnQgb2YgdGVzc2VsbGF0ZWQgYXJjLiAqLwogIGFyY1Rlc3NlbGxhdGlvbkFuZ2xlOiAxMCAvIDE4MCAqIE1hdGguUEksCiAgLyoqIERpdmlkZSBhcmMgdG8gYXQgbGVhc3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc2VnbWVudHMuICovCiAgbWluQXJjVGVzc2VsbGF0aW9uU3ViZGl2aXNpb25zOiA4LAogIC8qKiBSZW5kZXIgbWVzaGVzICgzREZBQ0UgZ3JvdXAsIFBPTFlMSU5FIHBvbHlmYWNlIG1lc2gpIGFzIHdpcmVmcmFtZSBpbnN0ZWFkIG9mIHNvbGlkLiAqLwogIHdpcmVmcmFtZU1lc2g6IGZhbHNlLAogIC8qKiBTdXBwcmVzcyBwYXBlci1zcGFjZSBlbnRpdGllcyB3aGVuIHRydWUgKG9ubHkgbW9kZWwtc3BhY2UgaXMgcmVuZGVyZWQpLiAqLwogIHN1cHByZXNzUGFwZXJTcGFjZTogZmFsc2UsCiAgLyoqIFRleHQgcmVuZGVyaW5nIG9wdGlvbnMuICovCiAgdGV4dE9wdGlvbnM6IFRleHRSZW5kZXJlci5EZWZhdWx0T3B0aW9ucwp9Ow=="},{"version":3,"names":["DynamicBuffer","NativeType","BatchingKey","Matrix3","Vector2","TextRenderer","ParseSpecialChars","HAlign","VAlign","RBTree","MTextFormatParser","dimStyleCodes","LinearDimension","HatchCalculator","HatchStyle","LookupPattern","Pattern","INDEXED_CHUNK_SIZE","POINT_CIRCLE_TESSELLATION_ANGLE","Math","PI","POINT_SHAPE_BLOCK_NAME","BLOCK_FLATTENING_VERTICES_THRESHOLD","SPLINE_SUBDIVISION","MAX_HATCH_LINES","MAX_HATCH_SEGMENTS","DEFAULT_VARS","DIMTXT","DIMASZ","DIMCLRD","DIMCLRE","DIMCLRT","DIMDEC","DIMDLE","DIMDSEP","charCodeAt","DIMEXE","DIMEXO","DIMFXL","DIMFXLON","DIMGAP","DIMLFAC","DIMRND","DIMSAH","DIMSCALE","DIMSD1","DIMSD2","DIMSE1","DIMSE2","DIMSOXD","DIMTSZ","DIMZIN","DxfScene","constructor","options","Object","create","DefaultOptions","assign","sceneOptions","origin","batches","b1","b2","key","Compare","layers","Map","blocks","dimStyles","vars","fontStyles","inserts","bounds","pointShapeBlock","numBlocksFlattened","numEntitiesFiltered","Build","dxf","fontFetchers","_this$vars$get","_this$vars$get2","_this$vars$get3","_this$vars$get4","header","name","value","entries","startsWith","set","slice","angBase","get","angDir","pdSize","isMetric","tables","layer","displayName","dimstyle","style","styles","styleName","block","Block","textRenderer","textOptions","hasMissingChars","_FetchFonts","entity","entities","_FilterEntity","type","handle","RegisterInsert","_entity$block","values","data","hasOwnProperty","blockCtx","DefinitionContext","_ProcessDxfEntity","SetFlatten","console","log","scene","_BuildScene","suppressPaperSpace","inPaperSpace","IsTextEntity","ProcessEntity","ret","FetchFonts","text","parser","Parse","GetText","dim","_CreateLinearDimension","GetTexts","Error","renderEntities","_DecomposeLine","_DecomposePolyline","_DecomposeArc","_DecomposeCircle","_DecomposeEllipse","_DecomposePoint","_DecomposeSpline","_ProcessInsert","_DecomposeText","_DecomposeMText","_Decompose3DFace","_DecomposeSolid","_DecomposeDimension","_DecomposeAttribute","_DecomposeHatch","renderEntity","_ProcessEntity","Entity","Type","POINTS","_ProcessPoints","LINE_SEGMENTS","_ProcessLineSegments","POLYLINE","_ProcessPolyline","TRIANGLES","_ProcessTriangles","_GetLineType","vertex","_IsPlainLine","Boolean","startWidth","endWidth","vertices","length","_GetEntityLayer","color","_GetEntityColor","lineType","_GenerateBulgeVertices","startVtx","endVtx","bulge","a","atan","aAbs","abs","arcTessellationAngle","push","x","y","ha","sha","sin","cha","cos","d","dSq","Number","MIN_VALUE","D","sqrt","R","center","numSegments","floor","minArcTessellationSubdivisions","startAngle","atan2","step","i","v","_GenerateArcVertices","radius","endAngle","tessellationAngle","yRadius","transform","rotation","ccwAngleDir","undefined","isClosed","tmp","arcAngle","rotationTransform","makeRotation","applyMatrix3","add","_GetEntityExtrusionTransform","shape","_entity$startAngle","_entity$endAngle","_entity$endAngle2","xR","majorAxisEndPoint","yR","axisRatio","pdMode","PdMode","NONE","DOT","markType","MARK_MASK","isShaped","SHAPE_MASK","GeometryType","POINT_INSTANCE","batch","_GetBatch","PushVertex","_TransformVertex","position","_CreatePointShapeBlock","_CreatePointMarker","canRender","insertEntity","ownerHandle","Render","fontSize","textHeight","scale","startPos","startPoint","endPos","endPoint","hAlign","horizontalJustification","vAlign","verticalJustification","_this","offsetX","offsetY","_position$x","_position$y","PLUS","CROSS","TICK","warn","offset","ColorCode","BY_BLOCK","SQUARE","r","CIRCLE","_DecomposeFace","wireframeMesh","points","wireframe","IsValidTriangle","v1","v2","v3","e1","subVectors","e2","area","cross","EPSILON","v0","hasFirstTriangle","hasSecondTriangle","_vertices","indices","halign","valign","widthFactor","xScale","RenderMText","formattedText","GetContent","height","direction","attachment","attachmentPoint","lineSpacing","width","dimensionType","linearOrAngularPoint1","linearOrAngularPoint2","anchorPoint","p1","copy","p2","anchor","isAligned","angle","textAnchor","middleOfText","textRotation","valueName","_GetDimStyleValue","GetLineWidth","IsValid","_entity$block2","has","insert","colorIndex","layout","GenerateLayout","line","lines","_line$color","start","end","triangle","triangles","_triangle$color","texts","_text$color","size","CENTER","MIDDLE","_entity$hatchStyle","isSolid","hatchStyle","ODD_PARITY","THROUGH_ENTIRE_AREA","boundaryLoops","_GetHatchBoundaryLoops","calc","pattern","patternName","definitionLines","seedPoints","seedPoint","patTransform","GetPatternTransform","patternAngle","patternScale","_line$angle3","offsetInLineSpace","_line$angle","_line$angle2","lineTransform","GetLineTransform","basePoint","base","bbox","GetBoundingBox","margin","max","min","minLineIdx","maxLineIdx","ceil","dashPatLength","dashes","dash","ocsTransform","clone","invert","lineIdx","xBase","xStart","xEnd","lineLength","lineVec","sub","clippedSegments","ClipLine","GetParam","RenderSegment","seg","multiplyScalar","ClipSegment","segStart","segEnd","_start","_end","minSegIdx","maxSegIdx","segIdx","segStartParam","dashLength","isSpace","dashLengthParam","result","AddPoints","n","lastPt","loop","vtxIdx","polyline","_vtx$bulge","vtx","_prevVtx$bulge","prevVtx","nextVtx","edges","edge","arcVertices","isCcw","tx","ty","controlPoints","map","p","subdivisions","pt","_InterpolateSpline","degreeOfSplineCurve","knotValues","first","last","_entity$xdata","xdata","ACAD","DSTYLE","isVarCode","found","e","code","Function","call","nestedCtx","NestedBlockContext","HasGeometry","InstantiationContext","GetInsertionTransform","_UpdateBounds","minX","minY","maxX","maxY","translate","flatten","_FlattenBatch","BLOCK_INSTANCE","PushInstanceTransform","blockBatch","layerName","blockColor","blockLineType","BY_LAYER","_layer$color","geometryType","Merge","_GenerateShapedPolyline","_MirrorEntityVertices","extrusionDirection","z","_vertices2","_v","propName","isPolyfaceMesh","_DecomposePolyfaceMesh","entityVertices","verticesCount","includesCurveFitVertices","includesSplineFitVertices","filter","splineVertex","curveFittingVertex","startIdx","curPlainLine","curLineType","curVertices","CommitSegment","endIdx","vIdx","isPlainLine","faces","face","hiddenEdges","polylines","CommitLineSegment","prev","nextIdx","pl","t","degree","knots","weights","j","s","l","domain","low","high","alpha","LINES","INDEXED_LINES","lineChunk","_IterateLineChunks","chunk","PushChunk","idx","PushIndex","Finish","error","INDEXED_TRIANGLES","find","RenderBatch","blockName","IsInstanced","TransformVertex","verticesSize","indicesSize","transformsSize","each","b","GetVerticesBufferSize","GetIndicesBufferSize","GetTransformsSize","ArrayBuffer","transforms","buffers","Float32Array","verticesOffset","Uint16Array","indicesOffset","transformsOffset","Serialize","pointShapeHasDot","IsIndexed","chunks","FLOAT32","Push","matrix","row","col","elements","curChunk","curSpace","space","GetSize","_NewChunk","IndexedChunkWriter","chunkWriter","Get","numIndices","BYTES_PER_ELEMENT","CopyTo","initialCapacity","IndexedChunk","useCount","nestedUseCount","RegisterNestedUse","usedByBlock","BlockContext","DEFINITION","INSTANTIATION","UpdateBounds","NESTED_DEFINITION","mInsert","yScale","rotate","mOffset","multiply","nestedTransform","ctx","multiplyMatrices","freeze","UINT16","numVerticesPushed","_IterateVertices","startIndex","count","chunkOffset","isLast","chunkVerticesCount","_IterateLineIndices","close"],"sources":["C:/Users/SDC-8/Desktop/Sowndarya/CMTI- Running Projects/PiWeb Running/PiWeb-CMTI-Pdf trying/1stApril/Trying/PiWeb-CMTI (2)/PiWeb-CMTI/node_modules/dxf-viewer/src/DxfScene.js"],"sourcesContent":["import { DynamicBuffer, NativeType } from \"./DynamicBuffer\"\nimport { BatchingKey } from \"./BatchingKey\"\nimport { Matrix3, Vector2 } from \"three\"\nimport { TextRenderer, ParseSpecialChars, HAlign, VAlign } from \"./TextRenderer\"\nimport { RBTree } from \"./RBTree\"\nimport { MTextFormatParser } from \"./MTextFormatParser\"\nimport dimStyleCodes from './parser/DimStyleCodes'\nimport { LinearDimension } from \"./LinearDimension\"\nimport { HatchCalculator, HatchStyle } from \"./HatchCalculator\"\nimport { LookupPattern, Pattern } from \"./Pattern\"\nimport \"./patterns\"\n\n\n/** Use 16-bit indices for indexed geometry. */\nconst INDEXED_CHUNK_SIZE = 0x10000\n/** Arc angle for tessellating point circle shape. */\nconst POINT_CIRCLE_TESSELLATION_ANGLE = 15 * Math.PI / 180\nconst POINT_SHAPE_BLOCK_NAME = \"__point_shape\"\n/** Flatten a block if its total vertices count in all instances is less than this value. */\nconst BLOCK_FLATTENING_VERTICES_THRESHOLD = 1024\n/** Number of subdivisions per spline point. */\nconst SPLINE_SUBDIVISION = 4\n/** Limit hatch lines number to some reasonable value to mitigate hanging and out-of-memory issues\n * on bad files.\n */\nconst MAX_HATCH_LINES = 20000\n/** Limit hatch segments number per line to some reasonable value to mitigate hanging and\n * out-of-memory issues on bad files.\n */\nconst MAX_HATCH_SEGMENTS = 20000\n\n\n/** Default values for system variables. Entry may be either value or function to call for obtaining\n * a value, the function `this` argument is DxfScene.\n */\nconst DEFAULT_VARS = {\n    /* https://knowledge.autodesk.com/support/autocad/learn-explore/caas/CloudHelp/cloudhelp/2016/ENU/AutoCAD-Core/files/GUID-A17A69D7-25EF-4F57-B4EB-D53A56AB909C-htm.html */\n    DIMTXT: function() {\n        //XXX should select value for imperial or metric units\n        return 2.5 //XXX 0.18 for imperial\n    },\n    DIMASZ: 2.5,//XXX 0.18 for imperial\n    DIMCLRD: 0,\n    DIMCLRE: 0,\n    DIMCLRT: 0,\n    DIMDEC: 2, //XXX 4 for imperial,\n    DIMDLE: 0,\n    DIMDSEP: \".\".charCodeAt(0), //XXX \",\" for imperial,\n    DIMEXE: 1.25, //XXX 0.18 for imperial\n    DIMEXO: 0.625, // XXX 0.0625 for imperial\n    DIMFXL: 1,\n    DIMFXLON: false,\n    DIMGAP: 0.625,//XXX for imperial\n    DIMLFAC: 1,\n    DIMRND: 0,\n    DIMSAH: 0,\n    DIMSCALE: 1,\n    DIMSD1: 0,\n    DIMSD2: 0,\n    DIMSE1: 0,\n    DIMSE2: 0,\n    DIMSOXD: false,\n    DIMTSZ: 0,\n    DIMZIN: 8, //XXX 0 for imperial,\n}\n\n/** This class prepares an internal representation of a DXF file, optimized fo WebGL rendering. It\n * is decoupled in such a way so that it should be possible to build it in a web-worker, effectively\n * transfer it to the main thread, and easily apply it to a Three.js scene there.\n */\nexport class DxfScene {\n\n    constructor(options) {\n        this.options = Object.create(DxfScene.DefaultOptions)\n        if (options) {\n            Object.assign(this.options, options.sceneOptions)\n        }\n\n        /* Scene origin. All input coordinates are made local to this point to minimize precision\n        * loss.\n        */\n        this.origin = null\n        /* RBTree<BatchingKey, RenderBatch> */\n        this.batches = new RBTree((b1, b2) => b1.key.Compare(b2.key))\n        /* Indexed by layer name, value is layer object from parsed DXF. */\n        this.layers = new Map()\n        /* Indexed by block name, value is Block. */\n        this.blocks = new Map()\n        /** Indexed by dimension style name, value is DIMSTYLE object from parsed DXF. */\n        this.dimStyles = new Map()\n        /** Indexed by variable name (without leading '$'). */\n        this.vars = new Map()\n        this.fontStyles = new Map()\n        /* Indexed by entity handle. */\n        this.inserts = new Map()\n        this.bounds = null\n        this.pointShapeBlock = null\n        this.numBlocksFlattened = 0\n        this.numEntitiesFiltered = 0\n    }\n\n    /** Build the scene from the provided parsed DXF.\n     * @param dxf {{}} Parsed DXF file.\n     * @param fontFetchers {?Function[]} List of font fetchers. Fetcher should return promise with\n     *  loaded font object (opentype.js). They are invoked only when necessary. Each glyph is being\n     *  searched sequentially in each provided font.\n     */\n    async Build(dxf, fontFetchers) {\n        const header = dxf.header || {}\n\n        for (const [name, value] of Object.entries(header)) {\n            if (name.startsWith(\"$\")) {\n                this.vars.set(name.slice(1), value)\n            }\n        }\n\n        /* Zero angle direction, 0 is +X. */\n        this.angBase = this.vars.get(\"ANGBASE\") ?? 0\n        /* 0 - CCW, 1 - CW */\n        this.angDir = this.vars.get(\"ANGDIR\") ?? 0\n        this.pdSize = this.vars.get(\"PDSIZE\") ?? 0\n        this.isMetric = (this.vars.get(\"MEASUREMENT\") ?? 1) == 1\n\n        if(dxf.tables && dxf.tables.layer) {\n            for (const [, layer] of Object.entries(dxf.tables.layer.layers)) {\n                layer.displayName = ParseSpecialChars(layer.name)\n                this.layers.set(layer.name, layer)\n            }\n        }\n\n        if(dxf.tables && dxf.tables.dimstyle) {\n            for (const [, style] of Object.entries(dxf.tables.dimstyle.dimStyles)) {\n                this.dimStyles.set(style.name, style)\n            }\n        }\n\n        if (dxf.tables && dxf.tables.style) {\n            for (const [, style] of Object.entries(dxf.tables.style.styles)) {\n                this.fontStyles.set(style.styleName, style);\n            }\n        }\n\n        if (dxf.blocks) {\n            for (const [, block] of Object.entries(dxf.blocks)) {\n                this.blocks.set(block.name, new Block(block))\n            }\n        }\n\n        this.textRenderer = new TextRenderer(fontFetchers, this.options.textOptions)\n        this.hasMissingChars = false\n        await this._FetchFonts(dxf)\n\n        /* Scan all entities to analyze block usage statistics. */\n        for (const entity of dxf.entities) {\n            if (!this._FilterEntity(entity)) {\n                continue\n            }\n            if (entity.type === \"INSERT\") {\n                this.inserts.set(entity.handle, entity)\n                const block = this.blocks.get(entity.name)\n                block?.RegisterInsert(entity)\n\n            } else if (entity.type == \"DIMENSION\") {\n                if ((entity.block ?? null) !== null) {\n                    const block = this.blocks.get(entity.block)\n                    block?.RegisterInsert(entity)\n                }\n            }\n        }\n\n        for (const block of this.blocks.values()) {\n            if (block.data.hasOwnProperty(\"entities\")) {\n                const blockCtx = block.DefinitionContext()\n                for (const entity of block.data.entities) {\n                    if (!this._FilterEntity(entity)) {\n                        continue\n                    }\n                    this._ProcessDxfEntity(entity, blockCtx)\n                }\n            }\n            if (block.SetFlatten()) {\n                this.numBlocksFlattened++\n            }\n        }\n        console.log(`${this.numBlocksFlattened} blocks flattened`)\n\n        for (const entity of dxf.entities) {\n            if (!this._FilterEntity(entity)) {\n                this.numEntitiesFiltered++\n                continue\n            }\n            this._ProcessDxfEntity(entity)\n        }\n        console.log(`${this.numEntitiesFiltered} entities filtered`)\n\n        this.scene = this._BuildScene()\n\n        delete this.batches\n        delete this.layers\n        delete this.blocks\n        delete this.textRenderer\n    }\n\n    /** @return False to suppress the specified entity, true to permit rendering. */\n    _FilterEntity(entity) {\n        return !this.options.suppressPaperSpace || !entity.inPaperSpace\n    }\n\n    async _FetchFonts(dxf) {\n\n        function IsTextEntity(entity) {\n            return entity.type === \"TEXT\" || entity.type === \"MTEXT\" ||\n                   entity.type === \"DIMENSION\" || entity.type === \"ATTDEF\" ||\n                   entity.type === \"ATTRIB\"\n        }\n\n        const ProcessEntity = async (entity) => {\n            if (!this._FilterEntity(entity)) {\n                return\n            }\n            let ret\n            if (entity.type === \"TEXT\" || entity.type === \"ATTRIB\" || entity.type === \"ATTDEF\") {\n                ret = await this.textRenderer.FetchFonts(ParseSpecialChars(entity.text))\n\n            } else if (entity.type === \"MTEXT\") {\n                const parser = new MTextFormatParser()\n                parser.Parse(entity.text)\n                ret = true\n                //XXX formatted MTEXT may specify some fonts explicitly, this is not yet supported\n                for (const text of parser.GetText()) {\n                    if (!await this.textRenderer.FetchFonts(ParseSpecialChars(text))) {\n                        ret = false\n                        break\n                    }\n                }\n\n            } else if (entity.type === \"DIMENSION\") {\n                ret = true\n                const dim = this._CreateLinearDimension(entity)\n                if (dim) {\n                    for (const text of dim.GetTexts()) {\n                        if (!await this.textRenderer.FetchFonts(text)) {\n                            ret = false\n                            break\n                        }\n                    }\n                }\n\n            } else {\n                throw new Error(\"Bad entity type\")\n            }\n            if (!ret) {\n                this.hasMissingChars = true\n            }\n            return ret\n        }\n\n        for (const entity of dxf.entities) {\n            if (IsTextEntity(entity)) {\n                if (!await ProcessEntity(entity)) {\n                    /* Failing to resolve some character means that all fonts have been loaded and\n                     * checked. No mean to check the rest strings. However until it is encountered,\n                     * all strings should be checked, even if all fonts already loaded. This needed\n                     * to properly set hasMissingChars which allows displaying some warning in a\n                     * viewer.\n                     */\n                    return\n                }\n            }\n        }\n        for (const block of this.blocks.values()) {\n            if (block.data.hasOwnProperty(\"entities\")) {\n                for (const entity of block.data.entities) {\n                    if (IsTextEntity(entity)) {\n                        if (!await ProcessEntity(entity)) {\n                            return\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    _ProcessDxfEntity(entity, blockCtx = null) {\n        let renderEntities\n        switch (entity.type) {\n        case \"LINE\":\n            renderEntities = this._DecomposeLine(entity, blockCtx)\n            break\n        case \"POLYLINE\":\n        case \"LWPOLYLINE\":\n            renderEntities = this._DecomposePolyline(entity, blockCtx)\n            break\n        case \"ARC\":\n            renderEntities = this._DecomposeArc(entity, blockCtx)\n            break\n        case \"CIRCLE\":\n            renderEntities = this._DecomposeCircle(entity, blockCtx)\n            break\n        case \"ELLIPSE\":\n            renderEntities = this._DecomposeEllipse(entity, blockCtx)\n            break\n        case \"POINT\":\n            renderEntities = this._DecomposePoint(entity, blockCtx)\n            break\n        case \"SPLINE\":\n            renderEntities = this._DecomposeSpline(entity, blockCtx)\n            break\n        case \"INSERT\":\n            /* Works with rendering batches without intermediate entities. */\n            this._ProcessInsert(entity, blockCtx)\n            return\n        case \"TEXT\":\n            renderEntities = this._DecomposeText(entity, blockCtx)\n            break\n        case \"MTEXT\":\n            renderEntities = this._DecomposeMText(entity, blockCtx)\n            break\n        case \"3DFACE\":\n            renderEntities = this._Decompose3DFace(entity, blockCtx)\n            break\n        case \"SOLID\":\n            renderEntities = this._DecomposeSolid(entity, blockCtx)\n            break\n        case \"DIMENSION\":\n            renderEntities = this._DecomposeDimension(entity, blockCtx)\n            break\n        case \"ATTRIB\":\n            renderEntities = this._DecomposeAttribute(entity, blockCtx)\n            break\n        case \"HATCH\":\n            renderEntities = this._DecomposeHatch(entity, blockCtx)\n            break\n        default:\n            console.log(\"Unhandled entity type: \" + entity.type)\n            return\n        }\n        for (const renderEntity of renderEntities) {\n            this._ProcessEntity(renderEntity, blockCtx)\n        }\n    }\n    /**\n     * @param entity {Entity}\n     * @param blockCtx {?BlockContext}\n     */\n    _ProcessEntity(entity, blockCtx = null) {\n        switch (entity.type) {\n        case Entity.Type.POINTS:\n            this._ProcessPoints(entity, blockCtx)\n            break\n        case Entity.Type.LINE_SEGMENTS:\n            this._ProcessLineSegments(entity, blockCtx)\n            break\n        case Entity.Type.POLYLINE:\n            this._ProcessPolyline(entity, blockCtx)\n            break\n        case Entity.Type.TRIANGLES:\n            this._ProcessTriangles(entity, blockCtx)\n            break\n        default:\n            throw new Error(\"Unhandled entity type: \" + entity.type)\n        }\n    }\n\n    /**\n     * @param entity\n     * @param vertex\n     * @param blockCtx {?BlockContext}\n     * @return {number}\n     */\n    _GetLineType(entity, vertex = null, blockCtx = null) {\n        //XXX lookup\n        return 0\n    }\n\n    /** Check if start/end with are not specified. */\n    _IsPlainLine(entity) {\n        return !Boolean(entity.startWidth || entity.endWidth)\n    }\n\n    *_DecomposeLine(entity, blockCtx) {\n        /* start/end width, bulge - seems cannot be present, at least with current parser */\n        if (entity.vertices.length !== 2) {\n            return\n        }\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const color = this._GetEntityColor(entity, blockCtx)\n        yield new Entity({\n            type: Entity.Type.LINE_SEGMENTS,\n            vertices: entity.vertices,\n            layer, color,\n            lineType: this._GetLineType(entity, entity.vertices[0])\n        })\n    }\n\n    /** Generate vertices for bulged line segment.\n     *\n     * @param vertices Generated vertices pushed here.\n     * @param startVtx Starting vertex. Assuming it is already present in the vertices array.\n     * @param endVtx Ending vertex.\n     * @param bulge Bulge value (see DXF specification).\n     */\n    _GenerateBulgeVertices(vertices, startVtx, endVtx, bulge) {\n        const a = 4 * Math.atan(bulge)\n        const aAbs = Math.abs(a)\n        if (aAbs < this.options.arcTessellationAngle) {\n            vertices.push(new Vector2(endVtx.x, endVtx.y))\n            return\n        }\n        const ha = a / 2\n        const sha = Math.sin(ha)\n        const cha = Math.cos(ha)\n        const d = {x: endVtx.x - startVtx.x, y: endVtx.y - startVtx.y}\n        const dSq = d.x * d.x + d.y * d.y\n        if (dSq < Number.MIN_VALUE * 2) {\n            /* No vertex is pushed since end vertex is duplicate of start vertex. */\n            return\n        }\n        const D = Math.sqrt(dSq)\n        let R = D / 2 / sha\n        d.x /= D\n        d.y /= D\n        const center = {\n            x: (d.x * sha - d.y * cha) * R + startVtx.x,\n            y: (d.x * cha + d.y * sha) * R + startVtx.y\n        }\n\n        let numSegments = Math.floor(aAbs / this.options.arcTessellationAngle)\n        if (numSegments < this.options.minArcTessellationSubdivisions) {\n            numSegments = this.options.minArcTessellationSubdivisions\n        }\n        if (numSegments > 1) {\n            const startAngle = Math.atan2(startVtx.y - center.y, startVtx.x - center.x)\n            const step = a / numSegments\n            if (a < 0) {\n                R = -R\n            }\n            for (let i = 1; i < numSegments; i++) {\n                const a = startAngle + i * step\n                const v = new Vector2(\n                    center.x + R * Math.cos(a),\n                    center.y + R * Math.sin(a)\n                )\n                vertices.push(v)\n            }\n        }\n        vertices.push(new Vector2(endVtx.x, endVtx.y))\n    }\n\n    /** Generate vertices for arc segment.\n     *\n     * @param vertices Generated vertices pushed here.\n     * @param {{x, y}} center  Center vector.\n     * @param {number} radius\n     * @param {?number} startAngle Start angle in radians. Zero if not specified. Arc is drawn in\n     *  CCW direction from start angle towards end angle.\n     * @param {?number} endAngle Optional end angle in radians. Full circle is drawn if not\n     *  specified.\n     * @param {?number} tessellationAngle Arc tessellation angle in radians, default value is taken\n     *  from scene options.\n     * @param {?number} yRadius Specify to get ellipse arc. `radius` parameter used as X radius.\n     * @param {?Matrix3} transform Optional transform matrix for the arc. Applied as last operation.\n     * @param {?number} rotation Optional rotation angle for generated arc. Mostly for ellipses.\n     * @param {?boolean} cwAngleDir Angles counted in clockwise direction from X positive direction.\n     * @return {Vector2[]} List of generated vertices.\n     */\n    _GenerateArcVertices({vertices, center, radius, startAngle = null, endAngle = null,\n                          tessellationAngle = null, yRadius = null, transform = null,\n                          rotation = null, ccwAngleDir = true}) {\n        if (!center || !radius) {\n            return\n        }\n        if (!tessellationAngle) {\n            tessellationAngle = this.options.arcTessellationAngle\n        }\n        if (yRadius === null) {\n            yRadius = radius\n        }\n        /* Normalize angles - make them starting from +X in CCW direction. End angle should be\n         * greater than start angle.\n         */\n        if (startAngle === undefined || startAngle === null) {\n            startAngle = 0\n        } else {\n            startAngle += this.angBase\n        }\n        let isClosed = false\n        if (endAngle === undefined || endAngle === null) {\n            endAngle = startAngle + 2 * Math.PI\n            isClosed = true\n        } else {\n            endAngle += this.angBase\n        }\n\n        //XXX this.angDir - not clear, seem in practice it does not alter arcs rendering.\n        if (!ccwAngleDir) {\n            const tmp = startAngle\n            startAngle = -endAngle\n            endAngle = -tmp\n        }\n\n        while (endAngle <= startAngle) {\n            endAngle += Math.PI * 2\n        }\n\n        const arcAngle = endAngle - startAngle\n\n        let numSegments = Math.floor(arcAngle / tessellationAngle)\n        if (numSegments === 0) {\n            numSegments = 1\n        }\n        const step = arcAngle / numSegments\n\n        let rotationTransform = null\n        if (rotation) {\n            rotationTransform = new Matrix3().makeRotation(rotation)\n        }\n\n        for (let i = 0; i <= numSegments; i++) {\n            if (i === numSegments && isClosed) {\n                break\n            }\n            let a\n            if (ccwAngleDir) {\n                a = startAngle + i * step\n            } else {\n                a = startAngle + (numSegments - i) * step\n            }\n            const v = new Vector2(radius * Math.cos(a), yRadius * Math.sin(a))\n\n            if (rotationTransform) {\n                v.applyMatrix3(rotationTransform)\n            }\n            v.add(center)\n            if (transform) {\n                v.applyMatrix3(transform)\n            }\n            vertices.push(v)\n        }\n    }\n\n    *_DecomposeArc(entity, blockCtx) {\n        const color = this._GetEntityColor(entity, blockCtx)\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const lineType = this._GetLineType(entity, null, blockCtx)\n        const vertices = []\n        this._GenerateArcVertices({vertices, center: entity.center, radius: entity.radius,\n                                   startAngle: entity.startAngle, endAngle: entity.endAngle,\n                                   transform: this._GetEntityExtrusionTransform(entity)})\n        yield new Entity({\n            type: Entity.Type.POLYLINE,\n            vertices, layer, color, lineType,\n            shape: entity.endAngle === undefined\n        })\n    }\n\n    *_DecomposeCircle(entity, blockCtx) {\n        const color = this._GetEntityColor(entity, blockCtx)\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const lineType = this._GetLineType(entity, null, blockCtx)\n        const vertices = []\n        this._GenerateArcVertices({vertices, center: entity.center, radius: entity.radius,\n                                   transform: this._GetEntityExtrusionTransform(entity)})\n        yield new Entity({\n            type: Entity.Type.POLYLINE,\n            vertices, layer, color, lineType,\n            shape: true\n        })\n    }\n\n    *_DecomposeEllipse(entity, blockCtx) {\n        const color = this._GetEntityColor(entity, blockCtx)\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const lineType = this._GetLineType(entity, null, blockCtx)\n        const vertices = []\n        const xR = Math.sqrt(entity.majorAxisEndPoint.x * entity.majorAxisEndPoint.x +\n                                 entity.majorAxisEndPoint.y * entity.majorAxisEndPoint.y)\n        const yR = xR * entity.axisRatio\n        const rotation = Math.atan2(entity.majorAxisEndPoint.y, entity.majorAxisEndPoint.x)\n\n        const startAngle = entity.startAngle ?? 0\n        let endAngle = entity.endAngle ?? startAngle + 2 * Math.PI\n        while (endAngle <= startAngle) {\n            endAngle += Math.PI * 2\n        }\n        const isClosed = (entity.endAngle ?? null) === null ||\n            Math.abs(endAngle - startAngle - 2 * Math.PI) < 1e-6\n\n        this._GenerateArcVertices({vertices, center: entity.center, radius: xR,\n                                   startAngle: entity.startAngle,\n                                   endAngle: isClosed ? null : entity.endAngle,\n                                   yRadius: yR,\n                                   rotation,\n                                   /* Assuming mirror transform if present, for ellipse it just\n                                    * reverses angle direction.\n                                    */\n                                   ccwAngleDir: !this._GetEntityExtrusionTransform(entity)})\n\n        yield new Entity({\n            type: Entity.Type.POLYLINE,\n            vertices, layer, color, lineType,\n            shape: isClosed\n        })\n    }\n\n    *_DecomposePoint(entity, blockCtx) {\n        if (this.pdMode === PdMode.NONE) {\n            /* Points not displayed. */\n            return\n        }\n        if (this.pdMode !== PdMode.DOT && this.pdSize <= 0) {\n            /* Currently not supported. */\n            return\n        }\n        const color = this._GetEntityColor(entity, blockCtx)\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const markType = this.pdMode & PdMode.MARK_MASK\n        const isShaped = (this.pdMode & PdMode.SHAPE_MASK) !== 0\n\n        if (isShaped) {\n            /* Shaped mark should be instanced. */\n            const key = new BatchingKey(layer, POINT_SHAPE_BLOCK_NAME,\n                                        BatchingKey.GeometryType.POINT_INSTANCE, color, 0)\n            const batch = this._GetBatch(key)\n            batch.PushVertex(this._TransformVertex(entity.position))\n            this._CreatePointShapeBlock()\n            return\n        }\n\n        if (markType === PdMode.DOT) {\n            yield new Entity({\n                type: Entity.Type.POINTS,\n                vertices: [entity.position],\n                layer, color,\n                lineType: null\n            })\n            return\n        }\n\n        const vertices = []\n        this._CreatePointMarker(vertices, markType, entity.position)\n        yield new Entity({\n            type: Entity.Type.LINE_SEGMENTS,\n            vertices, layer, color,\n            lineType: null\n        })\n    }\n\n    *_DecomposeAttribute(entity, blockCtx) {\n        if (!this.textRenderer.canRender) {\n            return;\n        }\n\n        const insertEntity = this.inserts.get(entity.ownerHandle)\n        const layer = this._GetEntityLayer(insertEntity ?? entity, blockCtx)\n        const color = this._GetEntityColor(insertEntity ?? entity, blockCtx)\n\n        //XXX lookup font style attributes\n\n        yield* this.textRenderer.Render({\n            text: ParseSpecialChars(entity.text),\n            fontSize: entity.textHeight * entity.scale,\n            startPos: entity.startPoint,\n            endPos: entity.endPoint,\n            rotation: entity.rotation,\n            hAlign: entity.horizontalJustification,\n            vAlign: entity.verticalJustification,\n            color,\n            layer\n        })\n    }\n\n\n    /** Create line segments for point marker.\n     * @param vertices\n     * @param markType\n     * @param position {?{x,y}} point center position, default is zero.\n     */\n    _CreatePointMarker(vertices, markType, position = null) {\n        const _this = this\n        function PushVertex(offsetX, offsetY) {\n            vertices.push({\n                x: (position?.x ?? 0) + offsetX * _this.pdSize * 0.5,\n                y: (position?.y ?? 0) + offsetY * _this.pdSize * 0.5\n            })\n        }\n\n        switch(markType) {\n        case PdMode.PLUS:\n            PushVertex(0, 1.5)\n            PushVertex(0, -1.5)\n            PushVertex(-1.5, 0)\n            PushVertex(1.5, 0)\n            break\n        case PdMode.CROSS:\n            PushVertex(-1, 1)\n            PushVertex(1, -1)\n            PushVertex(1, 1)\n            PushVertex(-1, -1)\n            break\n        case PdMode.TICK:\n            PushVertex(0, 1)\n            PushVertex(0, 0)\n            break\n        default:\n            console.warn(\"Unsupported point display type: \" + markType)\n        }\n    }\n\n    /** Create point shape block if not yet done. */\n    _CreatePointShapeBlock() {\n        if (this.pointShapeBlock) {\n            return\n        }\n        /* This mimics DXF block entity. */\n        this.pointShapeBlock = new Block({\n            name: POINT_SHAPE_BLOCK_NAME,\n            position: { x: 0, y: 0}\n        })\n        /* Fix block origin at zero. */\n        this.pointShapeBlock.offset = new Vector2(0, 0)\n        const blockCtx = this.pointShapeBlock.DefinitionContext()\n\n        const markType = this.pdMode & PdMode.MARK_MASK\n        if (markType !== PdMode.DOT && markType !== PdMode.NONE) {\n            const vertices = []\n            this._CreatePointMarker(vertices, markType)\n            const entity = new Entity({\n                type: Entity.Type.LINE_SEGMENTS,\n                vertices,\n                color: ColorCode.BY_BLOCK\n            })\n            this._ProcessEntity(entity, blockCtx)\n        }\n\n        if (this.pdMode & PdMode.SQUARE) {\n            const r = this.pdSize * 0.5\n            const vertices = [\n                {x: -r, y: r},\n                {x: r, y: r},\n                {x: r, y: -r},\n                {x: -r, y: -r}\n            ]\n            const entity = new Entity({\n                type: Entity.Type.POLYLINE, vertices,\n                color: ColorCode.BY_BLOCK,\n                shape: true\n            })\n            this._ProcessEntity(entity, blockCtx)\n        }\n        if (this.pdMode & PdMode.CIRCLE) {\n            const vertices = []\n            this._GenerateArcVertices({vertices, center: {x: 0, y: 0},\n                                       radius: this.pdSize * 0.5,\n                                       tessellationAngle: POINT_CIRCLE_TESSELLATION_ANGLE})\n            const entity = new Entity({\n                type: Entity.Type.POLYLINE, vertices,\n                color: ColorCode.BY_BLOCK,\n                shape: true\n            })\n            this._ProcessEntity(entity, blockCtx)\n        }\n    }\n\n    *_Decompose3DFace(entity, blockCtx) {\n        yield *this._DecomposeFace(entity, entity.vertices, blockCtx, this.options.wireframeMesh)\n    }\n\n    *_DecomposeSolid(entity, blockCtx) {\n        yield *this._DecomposeFace(entity, entity.points, blockCtx, false,\n                                   this._GetEntityExtrusionTransform(entity))\n    }\n\n    *_DecomposeFace(entity, vertices, blockCtx, wireframe, transform = null) {\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const color = this._GetEntityColor(entity, blockCtx)\n\n        function IsValidTriangle(v1, v2, v3) {\n            const e1 = new Vector2().subVectors(v2, v1)\n            const e2 = new Vector2().subVectors(v3, v1)\n            const area = Math.abs(e1.cross(e2))\n            return area > Number.EPSILON\n        }\n\n        const v0 = new Vector2(vertices[0].x, vertices[0].y)\n        const v1 = new Vector2(vertices[1].x, vertices[1].y)\n        const v2 = new Vector2(vertices[2].x, vertices[2].y)\n        let v3 = null\n\n        let hasFirstTriangle = IsValidTriangle(v0, v1, v2)\n        let hasSecondTriangle = false\n\n        if (vertices.length > 3) {\n            /* Fourth vertex may be the same as one of the previous vertices, so additional triangle\n             * for degeneration.\n             */\n\n            v3 = new Vector2(vertices[3].x, vertices[3].y)\n            hasSecondTriangle = IsValidTriangle(v1, v3, v2)\n            if (transform) {\n                v3.applyMatrix3(transform)\n            }\n        }\n        if (transform) {\n            v0.applyMatrix3(transform)\n            v1.applyMatrix3(transform)\n            v2.applyMatrix3(transform)\n        }\n\n        if (!hasFirstTriangle && !hasSecondTriangle) {\n            return\n        }\n\n        if (wireframe) {\n            const _vertices = []\n            if (hasFirstTriangle && !hasSecondTriangle) {\n                _vertices.push(v0, v1, v2)\n            } else if (!hasFirstTriangle && hasSecondTriangle) {\n                _vertices.push(v1, v3, v2)\n            } else {\n                _vertices.push(v0, v1, v3, v2)\n            }\n            yield new Entity({\n                type: Entity.Type.POLYLINE,\n                vertices: _vertices, layer, color,\n                shape: true\n            })\n\n        } else {\n            const _vertices = []\n            const indices = []\n            if (hasFirstTriangle) {\n                _vertices.push(v0, v1, v2)\n                indices.push(0, 1, 2)\n            }\n            if (hasSecondTriangle) {\n                if (!hasFirstTriangle) {\n                    _vertices.push(v1, v2)\n                    indices.push(0, 1, 2)\n                } else {\n                    indices.push(1, 2, 3)\n                }\n                _vertices.push(v3)\n            }\n            yield new Entity({\n                type: Entity.Type.TRIANGLES,\n                vertices: _vertices, indices, layer, color\n            })\n        }\n    }\n\n    *_DecomposeText(entity, blockCtx) {\n        if (!this.textRenderer.canRender) {\n            return\n        }\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const color = this._GetEntityColor(entity, blockCtx)\n        yield* this.textRenderer.Render({\n            text: ParseSpecialChars(entity.text),\n            fontSize: entity.textHeight,\n            startPos: entity.startPoint,\n            endPos: entity.endPoint,\n            rotation: entity.rotation,\n            hAlign: entity.halign,\n            vAlign: entity.valign,\n            widthFactor: entity.xScale,\n            color, layer\n        })\n    }\n\n    *_DecomposeMText(entity, blockCtx) {\n        if (!this.textRenderer.canRender) {\n            return\n        }\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const color = this._GetEntityColor(entity, blockCtx)\n        const parser = new MTextFormatParser()\n        parser.Parse(ParseSpecialChars(entity.text))\n        yield* this.textRenderer.RenderMText({\n            formattedText: parser.GetContent(),\n            fontSize: entity.height,\n            position: entity.position,\n            rotation: entity.rotation,\n            direction: entity.direction,\n            attachment: entity.attachmentPoint,\n            lineSpacing: entity.lineSpacing,\n            width: entity.width,\n            color, layer\n        })\n    }\n\n    /**\n     * @return {?LinearDimension} Dimension handler instance, null if not possible to create from\n     * the provided entity.\n     */\n    _CreateLinearDimension(entity) {\n        const type = (entity.dimensionType || 0) & 0xf\n        /* For now support linear dimensions only. */\n        if ((type != 0 && type != 1) || !entity.linearOrAngularPoint1 ||\n            !entity.linearOrAngularPoint2 || !entity.anchorPoint) {\n\n            return null\n        }\n\n        let style = null\n        if (entity.hasOwnProperty(\"styleName\")) {\n            style = this.dimStyles.get(entity.styleName)\n        }\n\n        const dim = new LinearDimension({\n            p1: new Vector2().copy(entity.linearOrAngularPoint1),\n            p2: new Vector2().copy(entity.linearOrAngularPoint2),\n            anchor: new Vector2().copy(entity.anchorPoint),\n            isAligned: type == 1,\n            angle: entity.angle,\n            text: entity.text,\n            textAnchor: entity.middleOfText ? new Vector2().copy(entity.middleOfText) : null,\n            textRotation: entity.textRotation\n\n        /* styleResolver */\n        }, valueName => {\n            return this._GetDimStyleValue(valueName, entity, style)\n\n        /* textWidthCalculator */\n        }, (text, fontSize) => {\n            return this.textRenderer.GetLineWidth(text, fontSize)\n        })\n\n        if (!dim.IsValid) {\n            console.warn(\"Invalid dimension geometry detected for \" + entity.handle)\n            return null\n        }\n\n        return dim\n    }\n\n    *_DecomposeDimension(entity, blockCtx) {\n        if ((entity.block ?? null) !== null && this.blocks.has(entity.block)) {\n            /* Dimension may have pre-rendered block attached. Then just render this block instead\n             * of synthesizing dimension geometry from parameters.\n             *\n             * Create dummy INSERT entity.\n             */\n            const insert = {\n                name: entity.block,\n                position: {x: 0, y: 0},\n                layer: entity.layer,\n                color: entity.color,\n                colorIndex: entity.colorIndex\n            }\n            this._ProcessInsert(insert, blockCtx)\n            return\n        }\n\n        /* https://ezdxf.readthedocs.io/en/stable/tutorials/linear_dimension.html\n         * https://ezdxf.readthedocs.io/en/stable/tables/dimstyle_table_entry.html\n         */\n\n        const dim = this._CreateLinearDimension(entity)\n        if (!dim) {\n            return\n        }\n\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const color = this._GetEntityColor(entity, blockCtx)\n        const transform = this._GetEntityExtrusionTransform(entity)\n\n        const layout = dim.GenerateLayout()\n\n        for (const line of layout.lines) {\n            const vertices = []\n\n            if (transform) {\n                line.start.applyMatrix3(transform)\n                line.end.applyMatrix3(transform)\n            }\n            vertices.push(line.start, line.end)\n\n            yield new Entity({\n                type: Entity.Type.LINE_SEGMENTS,\n                vertices,\n                layer,\n                color: line.color ?? color\n            })\n        }\n\n        for (const triangle of layout.triangles) {\n            if (transform) {\n                for (const v of triangle.vertices) {\n                    v.applyMatrix3(transform)\n                }\n            }\n\n            yield new Entity({\n                type: Entity.Type.TRIANGLES,\n                vertices: triangle.vertices,\n                indices: triangle.indices,\n                layer,\n                color: triangle.color ?? color\n            })\n        }\n\n        if (this.textRenderer.canRender) {\n            for (const text of layout.texts) {\n                if (transform) {\n                    //XXX does not affect text rotation and mirroring\n                    text.position.applyMatrix3(transform)\n                }\n                yield* this.textRenderer.Render({\n                    text: text.text,\n                    fontSize: text.size,\n                    startPos: text.position,\n                    rotation: text.angle,\n                    hAlign: HAlign.CENTER,\n                    vAlign: VAlign.MIDDLE,\n                    color: text.color ?? color,\n                    layer\n                })\n            }\n        }\n    }\n\n    *_DecomposeHatch(entity, blockCtx) {\n        if (entity.isSolid) {\n            //XXX solid hatch not yet supported\n            return\n        }\n\n        const style = entity.hatchStyle ?? 0\n\n        if (style != HatchStyle.ODD_PARITY && style != HatchStyle.THROUGH_ENTIRE_AREA) {\n            //XXX other styles not yet supported\n            return\n        }\n\n        const boundaryLoops = this._GetHatchBoundaryLoops(entity)\n        if (boundaryLoops.length == 0) {\n            console.warn(\"HATCH entity with empty boundary loops array \" +\n                \"(perhaps some loop types are not implemented yet)\")\n            return\n        }\n\n        const calc = new HatchCalculator(boundaryLoops, style)\n\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const color = this._GetEntityColor(entity, blockCtx)\n        const transform = this._GetEntityExtrusionTransform(entity)\n\n        let pattern = null\n        if (entity.patternName) {\n            pattern = LookupPattern(entity.patternName, this.isMetric)\n            if (!pattern) {\n                console.log(`Hatch pattern with name ${entity.patternName} not found ` +\n                            `(metric: ${this.isMetric})`)\n            }\n        }\n        if (pattern == null && entity.definitionLines) {\n            pattern = new Pattern(entity.definitionLines, null, false)\n        }\n        if (pattern == null) {\n            pattern = LookupPattern(\"ANSI31\")\n        }\n        if (!pattern) {\n            return\n        }\n\n        const seedPoints = entity.seedPoints ? entity.seedPoints : [{x: 0, y: 0}]\n\n        for (const seedPoint of seedPoints) {\n\n            const patTransform = calc.GetPatternTransform({\n                seedPoint,\n                angle: entity.patternAngle,\n                scale: entity.patternScale\n            })\n\n            for (const line of pattern.lines) {\n\n                let offsetX\n                let offsetY\n                if (pattern.offsetInLineSpace) {\n                    offsetX = line.offset.x\n                    offsetY = line.offset.y\n                } else {\n                    const sin = Math.sin(-(line.angle ?? 0))\n                    const cos = Math.cos(-(line.angle ?? 0))\n                    offsetX = line.offset.x * cos - line.offset.y * sin\n                    offsetY = line.offset.x * sin + line.offset.y * cos\n                }\n\n                /* Normalize offset so that Y is always non-negative. Inverting offset vector\n                 * direction does not change lines positions.\n                 */\n                if (offsetY < 0) {\n                    offsetY = -offsetY\n                    offsetX = -offsetX\n                }\n\n                const lineTransform = calc.GetLineTransform({\n                    patTransform,\n                    basePoint: line.base,\n                    angle: line.angle ?? 0\n                })\n\n                const bbox = calc.GetBoundingBox(lineTransform)\n                const margin = (bbox.max.x - bbox.min.x) * 0.05\n\n                /* First determine range of line indices. Line with index 0 goes through base point\n                 * (which is [0; 0] in line coordinates system). Line with index `n`` starts in `n`\n                 * offset vectors added to the base point.\n                 */\n                let minLineIdx, maxLineIdx\n                if (offsetY == 0) {\n                    /* Degenerated to single line. */\n                    minLineIdx = 0\n                    maxLineIdx = 0\n                } else {\n                    minLineIdx = Math.ceil(bbox.min.y / offsetY)\n                    maxLineIdx = Math.floor(bbox.max.y / offsetY)\n                }\n\n                if (maxLineIdx - minLineIdx > MAX_HATCH_LINES) {\n                    console.warn(\"Too many lines produced by hatching pattern\")\n                    continue\n                }\n\n                let dashPatLength\n                if (line.dashes && line.dashes.length > 1) {\n                    dashPatLength = 0\n                    for (const dash of line.dashes) {\n                        if (dash < 0) {\n                            dashPatLength -= dash\n                        } else {\n                            dashPatLength += dash\n                        }\n                    }\n                } else {\n                    dashPatLength = null\n                }\n\n                const ocsTransform = lineTransform.clone().invert()\n\n                for (let lineIdx = minLineIdx; lineIdx <= maxLineIdx; lineIdx++) {\n                    const y = lineIdx * offsetY\n                    const xBase = lineIdx * offsetX\n\n                    const xStart = bbox.min.x - margin\n                    const xEnd = bbox.max.x + margin\n                    const lineLength = xEnd - xStart\n                    const start = new Vector2(xStart, y).applyMatrix3(ocsTransform)\n                    const end = new Vector2(xEnd, y).applyMatrix3(ocsTransform)\n                    const lineVec = end.clone().sub(start)\n                    const clippedSegments = calc.ClipLine([start, end])\n\n                    function GetParam(x) {\n                        return (x - xStart) / lineLength\n                    }\n\n                    function RenderSegment(seg) {\n                        const p1 = lineVec.clone().multiplyScalar(seg[0]).add(start)\n                        const p2 = lineVec.clone().multiplyScalar(seg[1]).add(start)\n                        if (transform) {\n                            p1.applyMatrix3(transform)\n                            p2.applyMatrix3(transform)\n                        }\n                        if (seg[1] - seg[0] <= Number.EPSILON) {\n                            return new Entity({\n                                type: Entity.Type.POINTS,\n                                vertices: [p1],\n                                layer, color\n                            })\n                        }\n                        return new Entity({\n                            type: Entity.Type.LINE_SEGMENTS,\n                            vertices: [p1, p2],\n                            layer, color\n                        })\n                    }\n\n                    /** Clip segment against `clippedSegments`. */\n                    function *ClipSegment(segStart, segEnd) {\n                        for (const seg of clippedSegments) {\n                            if (seg[0] >= segEnd) {\n                                return\n                            }\n                            if (seg[1] <= segStart) {\n                                continue\n                            }\n                            const _start = Math.max(segStart, seg[0])\n                            const _end = Math.min(segEnd, seg[1])\n                            yield [_start, _end]\n                            segStart = _end\n                        }\n                    }\n\n                    /* Determine range for segment indices. One segment is one full sequence of\n                     * dashes. In case there is no dashes (solid line), just use hatch bounds.\n                     */\n                    if (dashPatLength !== null) {\n                        let minSegIdx = Math.floor((xStart - xBase) / dashPatLength)\n                        let maxSegIdx = Math.floor((xEnd - xBase) / dashPatLength)\n                        if (maxSegIdx - minSegIdx >= MAX_HATCH_SEGMENTS) {\n                            console.warn(\"Too many segments produced by hatching pattern line\")\n                            continue\n                        }\n\n                        for (let segIdx = minSegIdx; segIdx <= maxSegIdx; segIdx++) {\n                            let segStartParam = GetParam(xBase + segIdx * dashPatLength)\n\n                            for (let dashLength of line.dashes) {\n                                const isSpace = dashLength < 0\n                                if (isSpace) {\n                                    dashLength = -dashLength\n                                }\n                                const dashLengthParam = dashLength / lineLength\n                                if (!isSpace) {\n                                    for (const seg of ClipSegment(segStartParam,\n                                                                  segStartParam + dashLengthParam)) {\n                                        yield RenderSegment(seg)\n                                    }\n                                }\n                                segStartParam += dashLengthParam\n                            }\n                        }\n\n                    } else {\n                        /* Single solid line. */\n                        for (const seg of clippedSegments) {\n                            yield RenderSegment(seg)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /** @return {Vector2[][]} Each loop is a list of points in OCS coordinates. */\n    _GetHatchBoundaryLoops(entity) {\n        if (!entity.boundaryLoops) {\n            return []\n        }\n\n        const result = []\n\n        const AddPoints = (vertices, points) => {\n            const n = points.length\n            if (n == 0) {\n                return\n            }\n            if (vertices.length == 0) {\n                vertices.push(points[0])\n            } else {\n                const lastPt = vertices[vertices.length - 1]\n                if (lastPt.x != points[0].x || lastPt.y != points[0].y) {\n                    vertices.push(points[0])\n                }\n            }\n            for (let i = 1; i < n; i++) {\n                vertices.push(points[i])\n            }\n        }\n\n        for (const loop of entity.boundaryLoops) {\n            const vertices = []\n\n            //XXX handle external references\n\n            if (loop.type & 2) {\n                /* Polyline. */\n                for (let vtxIdx = 0; vtxIdx < loop.polyline.vertices.length; vtxIdx++) {\n                    const vtx = loop.polyline.vertices[vtxIdx]\n                    if ((vtx.bulge ?? 0) == 0) {\n                        vertices.push(new Vector2(vtx.x, vtx.y))\n                    } else {\n                        const prevVtx = loop.polyline.vertices[vtxIdx == 0 ?\n                            loop.polyline.vertices.length - 1 : vtxIdx - 1]\n                        if ((prevVtx.bulge ?? 0) == 0) {\n                            /* Start vertex is not produced by _GenerateBulgeVertices(). */\n                            vertices.push(new Vector2(vtx.x, vtx.y))\n                        }\n                        const nextVtx = loop.polyline.vertices[\n                            vtxIdx == loop.polyline.vertices.length - 1 ? 0 : vtxIdx + 1]\n                        this._GenerateBulgeVertices(vertices, vtx, nextVtx, vtx.bulge)\n                    }\n                }\n\n            } else if (loop.edges && loop.edges.length > 0) {\n                for (const edge of loop.edges) {\n                    switch (edge.type) {\n                    case 1:\n                        /* Line segment. */\n                        AddPoints(vertices, [new Vector2(edge.start.x, edge.start.y),\n                                             new Vector2(edge.end.x, edge.end.y)])\n                        break\n                    case 2: {\n                        /* Circular arc. */\n                        const arcVertices = []\n                        this._GenerateArcVertices({\n                            vertices: arcVertices,\n                            center: edge.start,\n                            radius: edge.radius,\n                            startAngle: edge.startAngle,\n                            endAngle: edge.endAngle,\n                            ccwAngleDir: edge.isCcw\n                        })\n                        AddPoints(vertices, arcVertices)\n                        break\n                    }\n                    case 3: {\n                        /* Elliptic arc. */\n                        const center = edge.start\n                        const majorAxisEndPoint = edge.end\n                        const xR = Math.sqrt(majorAxisEndPoint.x * majorAxisEndPoint.x +\n                                             majorAxisEndPoint.y * majorAxisEndPoint.y)\n                        const axisRatio = edge.radius\n                        const yR = xR * axisRatio\n                        const rotation = Math.atan2(majorAxisEndPoint.y, majorAxisEndPoint.x)\n                        const arcVertices = []\n                        this._GenerateArcVertices({\n                            vertices: arcVertices,\n                            center,\n                            radius: xR,\n                            startAngle: edge.startAngle,\n                            endAngle: edge.endAngle,\n                            yRadius: yR,\n                            ccwAngleDir: edge.isCcw\n                        })\n                        if (rotation !== 0) {\n                            //XXX should account angDir?\n                            const cos = Math.cos(rotation)\n                            const sin = Math.sin(rotation)\n                            for (const v of arcVertices) {\n                                const tx = v.x - center.x\n                                const ty = v.y - center.y\n                                /* Rotate the vertex around the ellipse center point. */\n                                v.x = tx * cos - ty * sin + center.x\n                                v.y = tx * sin + ty * cos + center.y\n                            }\n                        }\n                        AddPoints(vertices, arcVertices)\n                        break;\n                    }\n                    case 4:\n                        /* Spline. */\n                        const controlPoints = edge.controlPoints.map(p => [p.x, p.y])\n                        const subdivisions = controlPoints.length * SPLINE_SUBDIVISION\n                        const step = 1 / subdivisions\n                        for (let i = 0; i <= subdivisions; i++) {\n                            const pt = this._InterpolateSpline(i * step, edge.degreeOfSplineCurve,\n                                                               controlPoints,\n                                                               edge.knotValues)\n                            vertices.push(new Vector2(pt[0],pt[1]))\n                        }\n                        break;\n                    default:\n                        console.warn(\"Unhandled hatch boundary loop edge type: \" + edge.type)\n                    }\n                }\n            }\n\n            if (vertices.length > 2) {\n                const first = vertices[0]\n                const last = vertices[vertices.length - 1]\n                if (last.x == first.x && last.y == first.y) {\n                    vertices.length = vertices.length - 1\n                }\n            }\n            if (vertices.length > 2) {\n                result.push(vertices)\n            }\n        }\n\n        return result\n    }\n\n    _GetDimStyleValue(valueName, entity, style) {\n        const entries = entity?.xdata?.ACAD?.DSTYLE?.values\n        if (entries) {\n            let isVarCode = true\n            let found = false\n            for (const e of entries) {\n                if (isVarCode) {\n                    if (e.code != 1070) {\n                        /* Unexpected group code. */\n                        break\n                    }\n                    if (dimStyleCodes.get(e.value) == valueName) {\n                        found = true\n                    }\n                } else if (found) {\n                    return e.value\n                }\n                isVarCode = !isVarCode\n            }\n        }\n        if (style && style.hasOwnProperty(valueName)) {\n            return style[valueName]\n        }\n        if (this.vars.has(valueName)) {\n            return this.vars.get(valueName)\n        }\n        if (DEFAULT_VARS.hasOwnProperty(valueName)) {\n            const value = DEFAULT_VARS[valueName]\n            if (value instanceof Function) {\n                return value.call(this)\n            }\n            return value\n        }\n        return null\n    }\n\n    /**\n     * Updates batches directly.\n     * @param entity\n     * @param blockCtx {?BlockContext} Nested block insert when non-null.\n     */\n    _ProcessInsert(entity, blockCtx = null) {\n        if (blockCtx) {\n            //XXX handle indirect recursion\n            if (blockCtx.name === entity.name) {\n                console.warn(\"Recursive block reference: \" + blockCtx.name)\n                return\n            }\n            /* Flatten nested blocks definition. */\n            const block = this.blocks.get(entity.name)\n            if (!block) {\n                console.warn(\"Unresolved nested block reference: \" + entity.name)\n                return\n            }\n            const nestedCtx = blockCtx.NestedBlockContext(block, entity)\n            if (block.data.entities) {\n                for (const entity of block.data.entities) {\n                    this._ProcessDxfEntity(entity, nestedCtx)\n                }\n            }\n            return\n        }\n\n        const block = this.blocks.get(entity.name)\n        if (!block) {\n            console.warn(\"Unresolved block reference in INSERT: \" + entity.name)\n            return\n        }\n        if (!block.HasGeometry()) {\n            return\n        }\n\n        const layer = this._GetEntityLayer(entity, null)\n        const color = this._GetEntityColor(entity, null)\n        const lineType = this._GetLineType(entity, null, null)\n        //XXX apply extrusion direction\n        const transform = block.InstantiationContext().GetInsertionTransform(entity)\n\n        /* Update bounding box and origin with transformed block bounds corner points. */\n        const bounds = block.bounds\n        this._UpdateBounds(new Vector2(bounds.minX, bounds.minY).applyMatrix3(transform))\n        this._UpdateBounds(new Vector2(bounds.maxX, bounds.maxY).applyMatrix3(transform))\n        this._UpdateBounds(new Vector2(bounds.minX, bounds.maxY).applyMatrix3(transform))\n        this._UpdateBounds(new Vector2(bounds.maxX, bounds.minY).applyMatrix3(transform))\n\n        transform.translate(-this.origin.x, -this.origin.y)\n        //XXX grid instancing not supported yet\n        if (block.flatten) {\n            for (const batch of block.batches) {\n                this._FlattenBatch(batch, layer, color, lineType, transform)\n            }\n        } else {\n            const key = new BatchingKey(layer, entity.name, BatchingKey.GeometryType.BLOCK_INSTANCE,\n                                        color, lineType)\n            const batch = this._GetBatch(key)\n            batch.PushInstanceTransform(transform)\n        }\n    }\n\n    /** Flatten block definition batch. It is merged into suitable instant rendering batch. */\n    _FlattenBatch(blockBatch, layerName, blockColor, blockLineType, transform) {\n        const layer = this.layers.get(layerName)\n        let color, lineType = 0\n        if (blockBatch.key.color === ColorCode.BY_BLOCK) {\n            color = blockColor\n        } else if (blockBatch.key.color === ColorCode.BY_LAYER) {\n            color = layer?.color ?? 0\n        } else {\n            color = blockBatch.key.color\n        }\n        //XXX line type\n        const key = new BatchingKey(layerName, null, blockBatch.key.geometryType, color, lineType)\n        const batch = this._GetBatch(key)\n        batch.Merge(blockBatch, transform)\n    }\n\n    /**\n     * Generate entities for shaped polyline (e.g. line resulting in mesh). All segments are shaped\n     * (have start/end width). Segments may be bulge.\n     * @param vertices\n     * @param layer\n     * @param color\n     * @param lineType\n     * @param shape {Boolean} True if closed polyline.\n     * @return {Generator<Entity>}\n     */\n    *_GenerateShapedPolyline(vertices, layer, color, lineType, shape) {\n        //XXX\n        yield new Entity({\n                             type: Entity.Type.POLYLINE,\n                             vertices,\n                             layer,\n                             color,\n                             lineType,\n                             shape\n                         })\n    }\n\n    /** Mirror entity vertices if necessary in case of extrusionDirection with negative Z specified.\n     *\n     * @param entity Entity to check.\n     * @param vertices {?{x,y}[]} Vertices array to use instead of entity vertices attribute.\n     * @return {{x,y}[]} Vertices array with mirrored X if necessary. All attributes preserved.\n     */\n    _MirrorEntityVertices(entity, vertices = null) {\n        if (!entity.extrusionDirection || entity.extrusionDirection.z >= 0) {\n            return vertices ?? entity.vertices\n        }\n        if (!vertices || vertices === entity.vertices) {\n            vertices = entity.vertices.slice()\n        }\n        const n = vertices.length\n        for (let i = 0; i < n; i++) {\n            const v = vertices[i]\n            const _v = {x: -v.x}\n            for (const propName in v) {\n                if (!v.hasOwnProperty(propName)) {\n                    continue\n                }\n                if (propName !== \"x\") {\n                    _v[propName] = v[propName]\n                }\n            }\n            vertices[i] = _v\n        }\n        return vertices\n    }\n\n    *_DecomposePolyline(entity, blockCtx = null) {\n\n        if (entity.isPolyfaceMesh) {\n            yield *this._DecomposePolyfaceMesh(entity, blockCtx)\n            return\n        }\n\n        let entityVertices, verticesCount\n        if (entity.includesCurveFitVertices || entity.includesSplineFitVertices) {\n            entityVertices = entity.vertices.filter(v => v.splineVertex || v.curveFittingVertex)\n            verticesCount = entityVertices.length\n        } else {\n            entityVertices = entity.vertices\n            verticesCount = entity.vertices.length\n        }\n        if (verticesCount < 2) {\n            return\n        }\n        entityVertices = this._MirrorEntityVertices(entity, entityVertices)\n        const color = this._GetEntityColor(entity, blockCtx)\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const _this = this\n        let startIdx = 0\n        let curPlainLine = this._IsPlainLine(entityVertices[0])\n        let curLineType = this._GetLineType(entity, entityVertices[0], blockCtx)\n        let curVertices = null\n\n        function *CommitSegment(endIdx) {\n            if (endIdx === startIdx) {\n                return\n            }\n            let isClosed = false\n            let vertices = curVertices\n            if (endIdx === verticesCount && startIdx === 0) {\n                isClosed = true\n                if (vertices === null) {\n                    vertices = entityVertices\n                }\n            } else if (endIdx === verticesCount - 1 && startIdx === 0) {\n                if (vertices === null) {\n                    vertices = entityVertices\n                }\n            } else if (endIdx === verticesCount) {\n                if (vertices === null) {\n                    vertices = entityVertices.slice(startIdx, endIdx)\n                    vertices.push(entityVertices[0])\n                }\n            } else {\n                if (vertices === null) {\n                    vertices = entityVertices.slice(startIdx, endIdx + 1)\n                }\n            }\n\n            if (curPlainLine) {\n                yield new Entity({\n                                     type: Entity.Type.POLYLINE,\n                                     vertices, layer, color,\n                                     lineType: curLineType,\n                                     shape: isClosed\n                                 })\n            } else {\n                yield* _this._GenerateShapedPolyline(vertices, layer, color, curLineType, isClosed)\n            }\n\n            startIdx = endIdx\n            if (endIdx !== verticesCount) {\n                curPlainLine = _this._IsPlainLine(entityVertices[endIdx])\n                curLineType = _this._GetLineType(entity, entityVertices[endIdx])\n            }\n            curVertices = null\n        }\n\n        for (let vIdx = 1; vIdx <= verticesCount; vIdx++) {\n            const prevVtx = entityVertices[vIdx - 1]\n            let vtx\n            if (vIdx === verticesCount) {\n                if (!entity.shape) {\n                    yield* CommitSegment(vIdx - 1)\n                    break\n                }\n                vtx = entityVertices[0]\n            } else {\n                vtx = entityVertices[vIdx]\n            }\n\n            if (Boolean(prevVtx.bulge) && curPlainLine) {\n                if (curVertices === null) {\n                    curVertices = entityVertices.slice(startIdx, vIdx)\n                }\n                this._GenerateBulgeVertices(curVertices, prevVtx, vtx, prevVtx.bulge)\n            } else if (curVertices !== null) {\n                curVertices.push(vtx)\n            }\n\n            if (vIdx === verticesCount) {\n                yield* CommitSegment(vIdx)\n                break\n            }\n\n            const isPlainLine = this._IsPlainLine(vtx)\n            const lineType = this._GetLineType(entity, vtx)\n            if (isPlainLine !== curPlainLine ||\n                /* Line type is accounted for plain lines only. */\n                (curPlainLine && lineType !== curLineType)) {\n\n                yield* CommitSegment(vIdx)\n            }\n        }\n    }\n\n    *_DecomposePolyfaceMesh(entity, blockCtx = null) {\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const color = this._GetEntityColor(entity, blockCtx)\n\n        const vertices = []\n        const faces = []\n\n        for (const v of entity.vertices) {\n            if (v.faces) {\n                const face = {\n                    indices: [],\n                    hiddenEdges: []\n                }\n                for (const vIdx of v.faces) {\n                    if (vIdx == 0) {\n                        break\n                    }\n                    face.indices.push(vIdx < 0 ? -vIdx - 1 : vIdx - 1)\n                    face.hiddenEdges.push(vIdx < 0)\n                }\n                if (face.indices.length == 3 || face.indices.length == 4) {\n                    faces.push(face)\n                }\n            } else {\n                vertices.push(new Vector2(v.x, v.y))\n            }\n        }\n\n        const polylines = []\n        const CommitLineSegment = (startIdx, endIdx) => {\n            if (polylines.length > 0) {\n                const prev = polylines[polylines.length - 1]\n                if (prev.indices[prev.indices.length - 1] == startIdx) {\n                    prev.indices.push(endIdx)\n                    return\n                }\n                if (prev.indices[0] == prev.indices[prev.indices.length - 1]) {\n                    prev.isClosed = true\n                }\n            }\n            polylines.push({\n                indices: [startIdx, endIdx],\n                isClosed: false\n            })\n        }\n\n        for (const face of faces) {\n\n            if (this.options.wireframeMesh) {\n                for (let i = 0; i < face.indices.length; i++) {\n                    if (face.hiddenEdges[i]) {\n                        continue\n                    }\n                    const nextIdx = i < face.indices.length - 1 ? i + 1 : 0\n                    CommitLineSegment(face.indices[i], face.indices[nextIdx])\n                }\n\n            } else {\n                let indices\n                if (face.indices.length == 3) {\n                    indices = face.indices\n                } else {\n                    indices = [face.indices[0], face.indices[1], face.indices[2],\n                               face.indices[0], face.indices[2], face.indices[3]]\n                }\n                yield new Entity({\n                    type: Entity.Type.TRIANGLES,\n                    vertices, indices, layer, color\n                })\n            }\n        }\n\n        if (this.options.wireframeMesh) {\n            for (const pl of polylines) {\n                if (pl.length == 2) {\n                    yield new Entity({\n                        type: Entity.Type.LINE_SEGMENTS,\n                        vertices: [vertices[pl.indices[0]], vertices[pl.indices[1]]],\n                        layer, color\n                    })\n                } else {\n                    const _vertices = []\n                    for (const vIdx of pl.indices) {\n                        _vertices.push(vertices[vIdx])\n                    }\n                    yield new Entity({\n                        type: Entity.Type.POLYLINE,\n                        vertices: _vertices, layer, color,\n                        shape: pl.isClosed\n                    })\n                }\n            }\n        }\n    }\n\n    *_DecomposeSpline(entity, blockCtx = null) {\n        const color = this._GetEntityColor(entity, blockCtx)\n        const layer = this._GetEntityLayer(entity, blockCtx)\n        const lineType = this._GetLineType(entity, null, blockCtx)\n        if (!entity.controlPoints) {\n            //XXX knots or fit points not supported yet\n            return\n        }\n        const controlPoints = entity.controlPoints.map(p => [p.x, p.y])\n        const vertices = []\n        const subdivisions = controlPoints.length * SPLINE_SUBDIVISION\n        const step = 1 / subdivisions\n        for (let i = 0; i <= subdivisions; i++) {\n            const pt = this._InterpolateSpline(i * step, entity.degreeOfSplineCurve, controlPoints,\n                                               entity.knotValues)\n            vertices.push({x: pt[0], y: pt[1]})\n        }\n        //XXX extrusionDirection (normalVector) transform?\n        yield new Entity({type: Entity.Type.POLYLINE, vertices, layer, color, lineType})\n    }\n\n    /** Get a point on a B-spline.\n     * https://github.com/thibauts/b-spline\n     * @param t {number} Point position on spline, [0..1].\n     * @param degree {number} B-spline degree.\n     * @param points {number[][]} Control points. Each point should have the same dimension which\n     *  defines dimension of the result.\n     * @param knots {?number[]} Knot vector. Should have size `points.length + degree + 1`. Default\n     *  is uniform spline.\n     * @param weights {?number} Optional weights vector.\n     * @return {number[]} Resulting point on the specified position.\n     */\n    _InterpolateSpline(t, degree, points, knots = null, weights = null) {\n        let i, j, s, l             // function-scoped iteration variables\n        const n = points.length    // points count\n        const d = points[0].length // point dimensionality\n\n        if (degree < 1) {\n            throw new Error(\"Degree must be at least 1 (linear)\")\n        }\n        if (degree > (n - 1)) {\n            throw new Error(\"Degree must be less than or equal to point count - 1\")\n        }\n\n        if (!weights) {\n            // build weight vector of length [n]\n            weights = []\n            for(i = 0; i < n; i++) {\n                weights[i] = 1\n            }\n        }\n\n        if (!knots) {\n            // build knot vector of length [n + degree + 1]\n            knots = []\n            for(i = 0; i < n + degree + 1; i++) {\n                knots[i] = i\n            }\n        } else {\n            if (knots.length !== n + degree + 1) {\n                throw new Error(\"Bad knot vector length\")\n            }\n        }\n\n        const domain = [\n            degree,\n            knots.length-1 - degree\n        ]\n\n        // remap t to the domain where the spline is defined\n        const low  = knots[domain[0]]\n        const high = knots[domain[1]]\n        t = t * (high - low) + low\n\n        if (t < low) {\n            t = low\n        } else if (t > high) {\n            t = high\n        }\n\n        // find s (the spline segment) for the [t] value provided\n        for (s = domain[0]; s < domain[1]; s++) {\n            if (t >= knots[s] && t <= knots[s + 1]) {\n                break\n            }\n        }\n\n        // convert points to homogeneous coordinates\n        const v = []\n        for (i = 0; i < n; i++) {\n            v[i] = []\n            for (j = 0; j < d; j++) {\n                v[i][j] = points[i][j] * weights[i]\n            }\n            v[i][d] = weights[i]\n        }\n\n        // l (level) goes from 1 to the curve degree + 1\n        let alpha\n        for (l = 1; l <= degree + 1; l++) {\n            // build level l of the pyramid\n            for(i = s; i > s - degree - 1 + l; i--) {\n                alpha = (t - knots[i]) / (knots[i + degree + 1 - l] - knots[i])\n                // interpolate each component\n                for(j = 0; j < d + 1; j++) {\n                    v[i][j] = (1 - alpha) * v[i - 1][j] + alpha * v[i][j]\n                }\n            }\n        }\n\n        // convert back to cartesian and return\n        const result = []\n        for(i = 0; i < d; i++) {\n            result[i] = v[s][i] / v[s][d]\n        }\n        return result\n    }\n\n    /**\n     * @param entity {Entity}\n     * @param blockCtx {?BlockContext}\n     */\n    _ProcessPoints(entity, blockCtx = null) {\n        const key = new BatchingKey(entity.layer, blockCtx?.name,\n                                    BatchingKey.GeometryType.POINTS, entity.color, 0)\n        const batch = this._GetBatch(key)\n        for (const v of entity.vertices) {\n            batch.PushVertex(this._TransformVertex(v, blockCtx))\n        }\n    }\n\n    /**\n     * @param entity {Entity}\n     * @param blockCtx {?BlockContext}\n     */\n    _ProcessLineSegments(entity, blockCtx = null) {\n        if (entity.vertices.length % 2 !== 0) {\n            throw Error(\"Even number of vertices expected\")\n        }\n        const key = new BatchingKey(entity.layer, blockCtx?.name,\n                                    BatchingKey.GeometryType.LINES, entity.color, entity.lineType)\n        const batch = this._GetBatch(key)\n        for (const v of entity.vertices) {\n            batch.PushVertex(this._TransformVertex(v, blockCtx))\n        }\n    }\n\n    /**\n     * @param entity {Entity}\n     * @param blockCtx {?BlockContext}\n     */\n    _ProcessPolyline(entity, blockCtx = null) {\n        if (entity.vertices.length < 2) {\n            return\n        }\n        /* It is more optimal to render short polylines un-indexed. Also DXF often contains\n         * polylines with just two points.\n         */\n        const verticesCount = entity.vertices.length\n        if (verticesCount <= 3) {\n            const key = new BatchingKey(entity.layer, blockCtx?.name,\n                                        BatchingKey.GeometryType.LINES, entity.color,\n                                        entity.lineType)\n            const batch = this._GetBatch(key)\n            let prev = null\n            for (const v of entity.vertices) {\n                if (prev !== null) {\n                    batch.PushVertex(this._TransformVertex(prev, blockCtx))\n                    batch.PushVertex(this._TransformVertex(v, blockCtx))\n                }\n                prev = v\n            }\n            if (entity.shape && verticesCount > 2) {\n                batch.PushVertex(this._TransformVertex(entity.vertices[verticesCount - 1], blockCtx))\n                batch.PushVertex(this._TransformVertex(entity.vertices[0], blockCtx))\n            }\n            return\n        }\n\n        const key = new BatchingKey(entity.layer, blockCtx?.name,\n                                    BatchingKey.GeometryType.INDEXED_LINES,\n                                    entity.color, entity.lineType)\n        const batch = this._GetBatch(key)\n        /* Line may be split if exceeds chunk limit. */\n        for (const lineChunk of entity._IterateLineChunks()) {\n            const chunk = batch.PushChunk(lineChunk.verticesCount)\n            for (const v of lineChunk.vertices) {\n                chunk.PushVertex(this._TransformVertex(v, blockCtx))\n            }\n            for (const idx of lineChunk.indices) {\n                chunk.PushIndex(idx)\n            }\n            chunk.Finish()\n        }\n    }\n\n    /**\n     * @param entity {Entity}\n     * @param blockCtx {?BlockContext}\n     */\n    _ProcessTriangles(entity, blockCtx = null) {\n        if (entity.vertices.length < 3) {\n            return\n        }\n        if (entity.indices.length % 3 !== 0) {\n            console.error(\"Unexpected size of indices array: \" + entity.indices.length)\n            return\n        }\n        const key = new BatchingKey(entity.layer, blockCtx?.name,\n                                    BatchingKey.GeometryType.INDEXED_TRIANGLES,\n                                    entity.color, 0)\n        const batch = this._GetBatch(key)\n        //XXX splitting into chunks is not yet implemented. Currently used only for text glyphs so\n        // should fit into one chunk\n        const chunk = batch.PushChunk(entity.vertices.length)\n        for (const v of entity.vertices) {\n            chunk.PushVertex(this._TransformVertex(v, blockCtx))\n        }\n        for (const idx of entity.indices) {\n            chunk.PushIndex(idx)\n        }\n        chunk.Finish()\n    }\n\n    /** Resolve entity color.\n     *\n     * @param entity\n     * @param blockCtx {?BlockContext}\n     * @return {number} RGB color value. For block entity it also may be one of ColorCode values\n     *  which are resolved on block instantiation.\n     */\n    _GetEntityColor(entity, blockCtx = null) {\n        let color = ColorCode.BY_LAYER\n        if (entity.colorIndex === 0) {\n            color = ColorCode.BY_BLOCK\n        } else if (entity.colorIndex === 256) {\n            color = ColorCode.BY_LAYER\n        } else if (entity.hasOwnProperty(\"color\")) {\n            color = entity.color\n        }\n\n        if (blockCtx) {\n            return color\n        }\n        if (color === ColorCode.BY_LAYER || color === ColorCode.BY_BLOCK) {\n            /* BY_BLOCK is not useful when not in block so replace it by layer as well. */\n            if (entity.hasOwnProperty(\"layer\")) {\n                const layer = this.layers.get(entity.layer)\n                if (layer) {\n                    return layer.color\n                }\n            }\n        } else {\n            return color\n        }\n        /* Fallback to black. */\n        return 0\n    }\n\n    /** @return {?string} Layer name, null for block entity. */\n    _GetEntityLayer(entity, blockCtx = null) {\n        if (blockCtx) {\n            return null\n        }\n        if (entity.hasOwnProperty(\"layer\")) {\n            return entity.layer\n        }\n        return \"0\"\n    }\n\n    /** Check extrusionDirection property of the entity and return corresponding transform matrix.\n     *\n     * @return {?Matrix3} Null if not transform required.\n     */\n    _GetEntityExtrusionTransform(entity) {\n        //XXX For now just mirror X axis if extrusion Z is negative. No full support for arbitrary\n        // OCS yet.\n        if (!entity.hasOwnProperty(\"extrusionDirection\")) {\n            return null\n        }\n        if (entity.extrusionDirection.z > 0) {\n            return null\n        }\n        return new Matrix3().scale(-1, 1)\n    }\n\n    /** @return {RenderBatch} */\n    _GetBatch(key) {\n        let batch = this.batches.find({key})\n        if (batch !== null) {\n            return batch\n        }\n        batch = new RenderBatch(key)\n        this.batches.insert(batch)\n        if (key.blockName !== null && !key.IsInstanced()) {\n            /* Block definition batch. */\n            const block = this.blocks.get(key.blockName)\n            if (block) {\n                block.batches.push(batch)\n            }\n        }\n        return batch\n    }\n\n    /**\n     * Apply all necessary final transforms to a vertex before just before storing it in a rendering\n     * batch.\n     * @param v {{x: number, y: number}}\n     * @param blockCtx {BlockContext}\n     * @return {{x: number, y: number}}\n     */\n    _TransformVertex(v, blockCtx = null) {\n        if (blockCtx) {\n            /* Block definition in block coordinates. So it should not touch bounds and origin. */\n            return blockCtx.TransformVertex(v)\n        }\n        this._UpdateBounds(v)\n        return { x: v.x - this.origin.x, y: v.y - this.origin.y }\n    }\n\n    /** @param v {{x,y}} Vertex to extend bounding box with and set origin. */\n    _UpdateBounds(v) {\n        if (this.bounds === null) {\n            this.bounds = { minX: v.x, maxX: v.x, minY: v.y, maxY: v.y }\n        } else {\n            if (v.x < this.bounds.minX) {\n                this.bounds.minX = v.x\n            } else if (v.x > this.bounds.maxX) {\n                this.bounds.maxX = v.x\n            }\n            if (v.y < this.bounds.minY) {\n                this.bounds.minY = v.y\n            } else if (v.y > this.bounds.maxY) {\n                this.bounds.maxY = v.y\n            }\n        }\n        if (this.origin === null) {\n            this.origin = { x: v.x, y: v.y }\n        }\n    }\n\n    _BuildScene() {\n        let verticesSize = 0\n        let indicesSize = 0\n        let transformsSize = 0\n        this.batches.each(b => {\n            verticesSize += b.GetVerticesBufferSize()\n            indicesSize += b.GetIndicesBufferSize()\n            transformsSize += b.GetTransformsSize()\n        })\n\n        const scene = {\n            vertices: new ArrayBuffer(verticesSize),\n            indices: new ArrayBuffer(indicesSize),\n            transforms: new ArrayBuffer(transformsSize),\n            batches: [],\n            layers: [],\n            origin: this.origin,\n            bounds: this.bounds,\n            hasMissingChars: this.hasMissingChars\n        }\n\n        const buffers = {\n            vertices: new Float32Array(scene.vertices),\n            verticesOffset: 0,\n            indices: new Uint16Array(scene.indices),\n            indicesOffset: 0,\n            transforms: new Float32Array(scene.transforms),\n            transformsOffset: 0\n        }\n\n        this.batches.each(b => {\n            scene.batches.push(b.Serialize(buffers))\n        })\n\n        for (const layer of this.layers.values()) {\n            scene.layers.push({\n                name: layer.name,\n                displayName: layer.displayName,\n                color: layer.color\n            })\n        }\n\n        scene.pointShapeHasDot = (this.pdMode & PdMode.MARK_MASK) === PdMode.DOT\n\n        return scene\n    }\n}\n\nclass RenderBatch {\n    constructor(key) {\n        this.key = key\n        if (key.IsIndexed()) {\n            this.chunks = []\n        } else if (key.geometryType === BatchingKey.GeometryType.BLOCK_INSTANCE) {\n            this.transforms = new DynamicBuffer(NativeType.FLOAT32)\n        } else {\n            this.vertices = new DynamicBuffer(NativeType.FLOAT32)\n        }\n    }\n\n    PushVertex(v) {\n        const idx = this.vertices.Push(v.x)\n        this.vertices.Push(v.y)\n        return idx\n    }\n\n    /**\n     * @param matrix {Matrix3} 3x3 Transform matrix. Assuming 2D affine transform so only top 3x2\n     *  sub-matrix is taken.\n     */\n    PushInstanceTransform(matrix) {\n        /* Storing in row-major order as expected by renderer. */\n        for (let row = 0; row < 2; row++) {\n            for (let col = 0; col < 3; col++) {\n                this.transforms.Push(matrix.elements[col * 3 + row])\n            }\n        }\n    }\n\n    /** This method actually reserves space for the specified number of indexed vertices in some\n     * chunk. The returned object should be used to push exactly the same amount vertices and any\n     * number of their referring indices.\n     * @param verticesCount Number of vertices in the chunk.\n     * @return {IndexedChunkWriter}\n     */\n    PushChunk(verticesCount) {\n        if (verticesCount > INDEXED_CHUNK_SIZE) {\n            throw new Error(\"Vertices count exceeds chunk limit: \" + verticesCount)\n        }\n        /* Find suitable chunk with minimal remaining space to fill them as fully as possible. */\n        let curChunk = null\n        let curSpace = 0\n        for (const chunk of this.chunks) {\n            const space = INDEXED_CHUNK_SIZE - chunk.vertices.GetSize() / 2\n            if (space < verticesCount) {\n                continue\n            }\n            if (curChunk === null || space < curSpace) {\n                curChunk = chunk\n                curSpace = space\n            }\n        }\n        if (curChunk === null) {\n            curChunk = this._NewChunk(verticesCount)\n        }\n        return new IndexedChunkWriter(curChunk, verticesCount)\n    }\n\n    /** Merge other batch into this one. They should have the same geometry type. Instanced batches\n     * are disallowed.\n     *\n     * @param batch {RenderBatch}\n     * @param transform {?Matrix3} Optional transform to apply for merged vertices.\n     */\n    Merge(batch, transform = null) {\n        if (this.key.geometryType !== batch.key.geometryType) {\n            throw new Error(\"Rendering batch merging geometry type mismatch: \" +\n                            `${this.key.geometryType} !== ${batch.key.geometryType}`)\n        }\n        if (this.key.IsInstanced()) {\n            throw new Error(\"Attempted to merge instanced batch\")\n        }\n        if (this.key.IsIndexed()) {\n            /* Merge chunks. */\n            for (const chunk of batch.chunks) {\n                const verticesSize = chunk.vertices.size\n                const chunkWriter = this.PushChunk(verticesSize / 2)\n                for (let i = 0; i < verticesSize; i += 2) {\n                    const v = new Vector2(chunk.vertices.Get(i), chunk.vertices.Get(i + 1))\n                    if (transform) {\n                        v.applyMatrix3(transform)\n                    }\n                    chunkWriter.PushVertex(v)\n                }\n                const numIndices = chunk.indices.size\n                for (let i = 0; i < numIndices; i ++) {\n                    chunkWriter.PushIndex(chunk.indices.Get(i))\n                }\n                chunkWriter.Finish()\n            }\n        } else {\n            const n = batch.vertices.size\n            for (let i = 0; i < n; i += 2) {\n                const v = new Vector2(batch.vertices.Get(i), batch.vertices.Get(i + 1))\n                if (transform) {\n                    v.applyMatrix3(transform)\n                }\n                this.PushVertex(v)\n            }\n        }\n    }\n\n    /** @return Vertices buffer required size in bytes. */\n    GetVerticesBufferSize() {\n        if (this.key.IsIndexed()) {\n            let size = 0\n            for (const chunk of this.chunks) {\n                size += chunk.vertices.GetSize()\n            }\n            return size * Float32Array.BYTES_PER_ELEMENT\n        } else if (this.key.geometryType === BatchingKey.GeometryType.BLOCK_INSTANCE) {\n            return 0\n        } else {\n            return this.vertices.GetSize() * Float32Array.BYTES_PER_ELEMENT\n        }\n    }\n\n    /** @return Indices buffer required size in bytes. */\n    GetIndicesBufferSize() {\n        if (this.key.IsIndexed()) {\n            let size = 0\n            for (const chunk of this.chunks) {\n                size += chunk.indices.GetSize()\n            }\n            return size * Uint16Array.BYTES_PER_ELEMENT\n        } else {\n            return 0\n        }\n    }\n\n    /** @return Instances transforms buffer required size in bytes. */\n    GetTransformsSize() {\n        if (this.key.geometryType === BatchingKey.GeometryType.BLOCK_INSTANCE) {\n            return this.transforms.GetSize() * Float32Array.BYTES_PER_ELEMENT\n        } else {\n            return 0\n        }\n    }\n\n    Serialize(buffers) {\n        if (this.key.IsIndexed()) {\n            const batch = {\n                key: this.key,\n                chunks: []\n            }\n            for (const chunk of this.chunks) {\n                batch.chunks.push(chunk.Serialize(buffers))\n            }\n            return batch\n\n        } else if (this.key.geometryType === BatchingKey.GeometryType.BLOCK_INSTANCE) {\n            const size = this.transforms.GetSize()\n            const batch = {\n                key: this.key,\n                transformsOffset: buffers.transformsOffset,\n                transformsSize: size\n            }\n            this.transforms.CopyTo(buffers.transforms, buffers.transformsOffset)\n            buffers.transformsOffset += size\n            return batch\n\n        } else {\n            const size = this.vertices.GetSize()\n            const batch = {\n                key: this.key,\n                verticesOffset: buffers.verticesOffset,\n                verticesSize: size\n            }\n            this.vertices.CopyTo(buffers.vertices, buffers.verticesOffset)\n            buffers.verticesOffset += size\n            return batch\n        }\n    }\n\n    _NewChunk(initialCapacity) {\n        const chunk = new IndexedChunk(initialCapacity)\n        this.chunks.push(chunk)\n        return chunk\n    }\n}\n\nclass Block {\n    /** @param data {{}} Raw DXF entity. */\n    constructor(data) {\n        this.data = data\n        /* Number of times referenced from top-level entities (INSERT). */\n        this.useCount = 0\n        /* Number of times referenced by other block. */\n        this.nestedUseCount = 0\n        /* Total number of vertices in this block. Used for flattening decision. */\n        this.verticesCount = 0\n        /* Offset {x, y} to apply for all vertices. Used to move origin near vertices location to\n         * minimize precision loss.\n         */\n        this.offset = null\n        /* Definition batches. Used for root blocks flattening. */\n        this.batches = []\n        this.flatten = false\n        /** Bounds in block coordinates (with offset applied). */\n        this.bounds = null\n    }\n\n    /** Set block flattening flag based on usage statistics.\n     * @return {Boolean} New flatten flag state.\n     */\n    SetFlatten() {\n        if (!this.HasGeometry()) {\n            return false\n        }\n        /* Flatten if a block is used once (pure optimization if shares its layer with other\n         * geometry) or if total instanced vertices number is less than a threshold (trade some\n         * space for draw calls number).\n         */\n        this.flatten = this.useCount === 1 ||\n                       this.useCount * this.verticesCount <= BLOCK_FLATTENING_VERTICES_THRESHOLD\n        return this.flatten\n    }\n\n    /** @return {Boolean} True if has something to draw. */\n    HasGeometry() {\n        /* Offset is set on first geometry vertex encountered. */\n        return this.offset !== null\n    }\n\n    /** @param {{}} entity May be either INSERT or DIMENSION. */\n    RegisterInsert(entity) {\n        this.useCount++\n    }\n\n    RegisterNestedUse(usedByBlock) {\n        this.nestedUseCount++\n    }\n\n    /** @return {BlockContext} Context for block definition. */\n    DefinitionContext() {\n        return new BlockContext(this, BlockContext.Type.DEFINITION)\n    }\n\n    InstantiationContext() {\n        return new BlockContext(this, BlockContext.Type.INSTANTIATION)\n    }\n\n    UpdateBounds(v) {\n        if (this.bounds === null) {\n            this.bounds = { minX: v.x, maxX: v.x, minY: v.y, maxY: v.y }\n        } else {\n            if (v.x < this.bounds.minX) {\n                this.bounds.minX = v.x\n            } else if (v.x > this.bounds.maxX) {\n                this.bounds.maxX = v.x\n            }\n            if (v.y < this.bounds.minY) {\n                this.bounds.minY = v.y\n            } else if (v.y > this.bounds.maxY) {\n                this.bounds.maxY = v.y\n            }\n        }\n    }\n}\n\nclass BlockContext {\n    constructor(block, type) {\n        this.block = block\n        this.type = type\n        this.origin = this.block.data.position\n        /* Transform to apply for block definition entities not including block offset. */\n        this.transform = new Matrix3()\n    }\n\n    /** @return {string} Block name */\n    get name() {\n        return this.block.data.name\n    }\n\n    /**\n     * @param v {{x,y}}\n     * @return {{x,y}}\n     */\n    TransformVertex(v) {\n        const result = new Vector2(v.x, v.y).applyMatrix3(this.transform)\n        if (this.type !== BlockContext.Type.DEFINITION &&\n            this.type !== BlockContext.Type.NESTED_DEFINITION) {\n\n            throw new Error(\"Unexpected transform type\")\n        }\n        this.block.verticesCount++\n        if (this.block.offset === null) {\n            /* This is the first vertex. Take it as a block origin. So the result is always zero\n             * vector for the first vertex.\n             */\n            this.block.offset = result\n            const v = new Vector2()\n            this.block.UpdateBounds(v)\n            return v\n        }\n        result.sub(this.block.offset)\n        this.block.UpdateBounds(result)\n        return result\n    }\n\n    /**\n     * Get transform for block instance.\n     * @param entity Raw DXF INSERT entity.\n     * @return {Matrix3} Transform matrix for block instance to apply to the block definition.\n     */\n    GetInsertionTransform(entity) {\n        const mInsert = new Matrix3().translate(-this.origin.x, -this.origin.y)\n        const yScale = entity.yScale || 1\n        const xScale = entity.xScale || 1\n        const rotation = -(entity.rotation || 0) * Math.PI / 180\n        let x = entity.position.x\n        const y = entity.position.y\n        mInsert.scale(xScale, yScale)\n        mInsert.rotate(rotation)\n        mInsert.translate(x, y)\n        if (entity.extrusionDirection && entity.extrusionDirection.z < 0) {\n            mInsert.scale(-1, 1)\n        }\n        if (this.type !== BlockContext.Type.INSTANTIATION) {\n            return mInsert\n        }\n        const mOffset = new Matrix3().translate(this.block.offset.x, this.block.offset.y)\n        return mInsert.multiply(mOffset)\n    }\n\n    /**\n     * Create context for nested block.\n     * @param block {Block} Nested block.\n     * @param entity Raw DXF INSERT entity.\n     * @return {BlockContext} Context to use for nested block entities.\n     */\n    NestedBlockContext(block, entity) {\n        block.RegisterNestedUse(this.block)\n        const nestedCtx = new BlockContext(block, BlockContext.Type.NESTED_DEFINITION)\n        const nestedTransform = nestedCtx.GetInsertionTransform(entity)\n        const ctx = new BlockContext(this.block, BlockContext.Type.NESTED_DEFINITION)\n        ctx.transform = new Matrix3().multiplyMatrices(this.transform, nestedTransform)\n        return ctx\n    }\n}\n\nBlockContext.Type = Object.freeze({\n    DEFINITION: 0,\n    NESTED_DEFINITION: 1,\n    INSTANTIATION: 2\n})\n\nclass IndexedChunk {\n    constructor(initialCapacity) {\n        if (initialCapacity < 16) {\n            initialCapacity = 16\n        }\n        /* Average two indices per vertex. */\n        this.indices = new DynamicBuffer(NativeType.UINT16, initialCapacity * 2)\n        /* Two components per vertex. */\n        this.vertices = new DynamicBuffer(NativeType.FLOAT32, initialCapacity * 2)\n    }\n\n    Serialize(buffers) {\n        const chunk = {}\n        {\n            const size = this.vertices.GetSize()\n            chunk.verticesOffset = buffers.verticesOffset\n            chunk.verticesSize = size\n            this.vertices.CopyTo(buffers.vertices, buffers.verticesOffset)\n            buffers.verticesOffset += size\n        }\n        {\n            const size = this.indices.GetSize()\n            chunk.indicesOffset = buffers.indicesOffset\n            chunk.indicesSize = size\n            this.indices.CopyTo(buffers.indices, buffers.indicesOffset)\n            buffers.indicesOffset += size\n        }\n        return chunk\n    }\n}\n\nclass IndexedChunkWriter {\n    constructor(chunk, verticesCount) {\n        this.chunk = chunk\n        this.verticesCount = verticesCount\n        this.verticesOffset = this.chunk.vertices.GetSize() / 2\n        this.numVerticesPushed = 0\n    }\n\n    PushVertex(v) {\n        if (this.numVerticesPushed === this.verticesCount) {\n            throw new Error()\n        }\n        this.chunk.vertices.Push(v.x)\n        this.chunk.vertices.Push(v.y)\n        this.numVerticesPushed++\n    }\n\n    PushIndex(idx) {\n        if (idx < 0 || idx >= this.verticesCount) {\n            throw new Error(`Index out of range: ${idx}/${this.verticesCount}`)\n        }\n        this.chunk.indices.Push(idx + this.verticesOffset)\n    }\n\n    Finish() {\n        if (this.numVerticesPushed !== this.verticesCount) {\n            throw new Error(`Not all vertices pushed: ${this.numVerticesPushed}/${this.verticesCount}`)\n        }\n    }\n}\n\n/** Internal entity representation. DXF features are decomposed into these simpler entities. Whole\n * entity always shares single material.\n */\nexport class Entity {\n    /** @param type {number} See Entity.Type\n     * @param vertices {{x, y}[]}\n     * @param indices {?number[]} Indices for indexed geometry.\n     * @param layer {?string}\n     * @param color {number}\n     * @param lineType {?number}\n     * @param shape {Boolean} true if closed shape.\n     */\n    constructor({type, vertices, indices = null, layer = null, color, lineType = 0, shape = false}) {\n        this.type = type\n        this.vertices = vertices\n        this.indices = indices\n        this.layer = layer\n        this.color = color\n        this.lineType = lineType\n        this.shape = shape\n    }\n\n    *_IterateVertices(startIndex, count) {\n        for (let idx = startIndex; idx < startIndex + count; idx++) {\n            yield this.vertices[idx]\n        }\n    }\n\n    /** Split line into chunks with at most INDEXED_CHUNK_SIZE vertices in each one. Each chunk is\n     * an object with the following properties:\n     *  * \"verticesCount\" - length of \"vertices\"\n     *  * \"vertices\" - iterator for included vertices.\n     *  * \"indices\" - iterator for indices.\n     *  Closed shapes are handled properly.\n     */\n    *_IterateLineChunks() {\n        const verticesCount = this.vertices.length\n        if (verticesCount < 2) {\n            return\n        }\n        const _this = this\n        /* chunkOffset == verticesCount for shape closing vertex. */\n        for (let chunkOffset = 0; chunkOffset <= verticesCount; chunkOffset += INDEXED_CHUNK_SIZE) {\n            let count = verticesCount - chunkOffset\n            let isLast\n            if (count > INDEXED_CHUNK_SIZE) {\n                count = INDEXED_CHUNK_SIZE\n                isLast = false\n            } else {\n                isLast = true\n            }\n            if (isLast && this.shape && chunkOffset > 0 && count === INDEXED_CHUNK_SIZE) {\n                /* Corner case - required shape closing vertex does not fit into the chunk. Will\n                * require additional chunk.\n                */\n                isLast = false\n            }\n            if (chunkOffset === verticesCount && !this.shape) {\n                /* Shape is not closed and it is last closing vertex iteration. */\n                break\n            }\n\n            let vertices, indices, chunkVerticesCount\n            if (count < 2) {\n                /* Either last vertex or last shape-closing vertex, or both. */\n                if (count === 1 && this.shape) {\n                    /* Both. */\n                    vertices = (function*() {\n                        yield this.vertices[chunkOffset]\n                        yield this.vertices[0]\n                    })()\n                } else if (count === 1) {\n                    /* Just last vertex. Take previous one to make a line. */\n                    vertices = (function*() {\n                        yield this.vertices[chunkOffset - 1]\n                        yield this.vertices[chunkOffset]\n                    })()\n                } else {\n                    /* Just shape-closing vertex. Take last one to make a line. */\n                    vertices = (function*() {\n                        yield this.vertices[verticesCount - 1]\n                        yield this.vertices[0]\n                    })()\n                }\n                indices = _IterateLineIndices(2, false)\n                chunkVerticesCount = 2\n            } else if (isLast && this.shape && chunkOffset > 0 && count < INDEXED_CHUNK_SIZE) {\n                /* Additional vertex to close the shape. */\n                vertices = (function*() {\n                    yield* _this._IterateVertices(chunkOffset, count)\n                    yield this.vertices[0]\n                })()\n                indices = _IterateLineIndices(count + 1, false)\n                chunkVerticesCount = count + 1\n            } else {\n                vertices = this._IterateVertices(chunkOffset, count)\n                indices = _IterateLineIndices(count,\n                                              isLast && chunkOffset === 0 && this.shape)\n                chunkVerticesCount = count\n            }\n            yield {\n                verticesCount: chunkVerticesCount,\n                vertices,\n                indices\n            }\n        }\n    }\n}\n\nEntity.Type = Object.freeze({\n    POINTS: 0,\n    /** Each vertices pair defines a segment. */\n    LINE_SEGMENTS: 1,\n    POLYLINE: 2,\n    TRIANGLES: 3\n})\n\nfunction* _IterateLineIndices(verticesCount, close) {\n    for (let idx = 0; idx < verticesCount - 1; idx++) {\n        yield idx\n        yield idx + 1\n    }\n    if (close && verticesCount > 2) {\n        yield verticesCount - 1\n        yield 0\n    }\n}\n\n/** Point display mode, $PDMODE system variable. */\nconst PdMode = Object.freeze({\n    DOT: 0,\n    NONE: 1,\n    PLUS: 2,\n    CROSS: 3,\n    TICK: 4,\n    MARK_MASK: 0xf,\n\n    CIRCLE: 0x20,\n    SQUARE: 0x40,\n\n    SHAPE_MASK: 0xf0\n})\n\n/** Special color values, used for block entities. Regular entities color is resolved instantly. */\nexport const ColorCode = Object.freeze({\n    BY_LAYER: -1,\n    BY_BLOCK: -2\n})\n\nDxfScene.DefaultOptions = {\n    /** Target angle for each segment of tessellated arc. */\n    arcTessellationAngle: 10 / 180 * Math.PI,\n    /** Divide arc to at least the specified number of segments. */\n    minArcTessellationSubdivisions: 8,\n    /** Render meshes (3DFACE group, POLYLINE polyface mesh) as wireframe instead of solid. */\n    wireframeMesh: false,\n    /** Suppress paper-space entities when true (only model-space is rendered). */\n    suppressPaperSpace: false,\n    /** Text rendering options. */\n    textOptions: TextRenderer.DefaultOptions,\n}\n"],"mappings":"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"}]}