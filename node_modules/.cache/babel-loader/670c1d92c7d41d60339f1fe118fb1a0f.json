{"remainingRequest":"C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\node_modules\\dxf-viewer\\src\\HatchCalculator.js","dependencies":[{"path":"C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\node_modules\\dxf-viewer\\src\\HatchCalculator.js","mtime":1704432456000},{"path":"C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\babel.config.js","mtime":1694764762000},{"path":"C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1704432454000},{"path":"C:\\Users\\SDC-8\\Desktop\\Sowndarya\\CMTI- Running Projects\\PiWeb Running\\PiWeb-CMTI-Pdf trying\\1stApril\\Trying\\PiWeb-CMTI (2)\\PiWeb-CMTI\\node_modules\\babel-loader\\lib\\index.js","mtime":1704432454000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:ZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH0KZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCAic3RyaW5nIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSAic3ltYm9sIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9CmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSAib2JqZWN0IiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCAiZGVmYXVsdCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gIm9iamVjdCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuIik7IH0gcmV0dXJuIChoaW50ID09PSAic3RyaW5nIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9CmltcG9ydCB7IFZlY3RvcjIsIE1hdHJpeDMsIEJveDIgfSBmcm9tICJ0aHJlZSI7CmltcG9ydCB7IEludGVyc2VjdFNlZ21lbnRzUGFyYW1ldHJpYyB9IGZyb20gIi4vbWF0aC91dGlscyI7CmV4cG9ydCBjb25zdCBIYXRjaFN0eWxlID0gT2JqZWN0LmZyZWV6ZSh7CiAgT0REX1BBUklUWTogMCwKICBPVVRFUk1PU1Q6IDEsCiAgVEhST1VHSF9FTlRJUkVfQVJFQTogMgp9KTsKCi8qKiBGb3JjZSBpbnRlcnNlY3Rpb24gYXQgdGhpcyBkaXN0YW5jZSBmcm9tIGVkZ2UgZW5kcG9pbnQgKHBhcmFtZXRlciB2YWx1ZSkuICovCmNvbnN0IEVORFBPSU5UX01BUkdJTiA9IDFlLTQ7CgovKiogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBib3RoIGVkZ2VzIGNyb3NzZWQgZnJvbSB0aGUgc2FtZSBzaWRlLCBmYWxzZSBvdGhlcndpc2UuICovCmZ1bmN0aW9uIEVkZ2VTYW1lU2lkZShlMSwgZTIpIHsKICByZXR1cm4gKGUxLmludGVyc2VjdGlvblsyXSA+IDAgJiYgZTIuaW50ZXJzZWN0aW9uWzJdKSA+IDAgfHwgZTEuaW50ZXJzZWN0aW9uWzJdIDwgMCAmJiBlMi5pbnRlcnNlY3Rpb25bMl0gPCAwOwp9CgovKiogQ29udGV4dCBmb3Igb25lIGxpbmUgY2xpcHBpbmcgY2FsY3VsYXRpb25zLiAqLwpjbGFzcyBDbGlwQ2FsY3VsYXRvciB7CiAgY29uc3RydWN0b3IoYm91bmRhcnlMb29wcywgc3R5bGUsIGxpbmUpIHsKICAgIHRoaXMuc3R5bGUgPSBzdHlsZTsKICAgIHRoaXMubGluZSA9IGxpbmU7CiAgICB0aGlzLmxpbmVEaXIgPSBsaW5lWzFdLmNsb25lKCkuc3ViKGxpbmVbMF0pLm5vcm1hbGl6ZSgpOwogICAgdGhpcy5sb29wcyA9IFtdOwogICAgZm9yIChsZXQgbG9vcElkeCA9IDA7IGxvb3BJZHggPCBib3VuZGFyeUxvb3BzLmxlbmd0aDsgbG9vcElkeCsrKSB7CiAgICAgIGNvbnN0IGxvb3AgPSBib3VuZGFyeUxvb3BzW2xvb3BJZHhdOwogICAgICBjb25zdCBfbG9vcCA9IFtdOwogICAgICBmb3IgKGxldCB2dHhJZHggPSAwOyB2dHhJZHggPCBsb29wLmxlbmd0aDsgdnR4SWR4KyspIHsKICAgICAgICBfbG9vcC5wdXNoKHsKICAgICAgICAgIGlkeDogdnR4SWR4LAogICAgICAgICAgc3RhcnQ6IGxvb3BbdnR4SWR4XSwKICAgICAgICAgIGVuZDogbG9vcFt2dHhJZHggPT0gbG9vcC5sZW5ndGggLSAxID8gMCA6IHZ0eElkeCArIDFdLAogICAgICAgICAgbG9vcElkeAogICAgICAgIH0pOwogICAgICB9CiAgICAgIHRoaXMubG9vcHMucHVzaChfbG9vcCk7CiAgICB9CiAgfQoKICAvKioKICAgKiBAcmV0dXJuIHtudW1iZXJbMl1bXX0gTGlzdCBvZiByZXN1bHRpbmcgbGluZSBzZWdtZW50cyBpbiBwYXJhbWV0cmljIGZvcm0uIFBhcmFtZXRlciB2YWx1ZSAwCiAgICogIGNvcnJlc3BvbmRzIHRvIHRoZSBwcm92aWRlZCBsaW5lIHN0YXJ0IHBvaW50LCAxIC0gdG8gZW5kIHBvaW50LgogICAqLwogIENhbGN1bGF0ZSgpIHsKICAgIHRoaXMuX1Byb2Nlc3NFZGdlcygpOwogICAgdGhpcy5fQ3JlYXRlTm9kZXMoKTsKICAgIC8qIFNvcnQgZnJvbSBsaW5lIHN0YXJ0IHRvd2FyZHMgZW5kLiAqLwogICAgdGhpcy5ub2Rlcy5zb3J0KChlMSwgZTIpID0+IGUxLmludGVyc2VjdGlvblswXSAtIGUyLmludGVyc2VjdGlvblswXSk7CiAgICBpZiAodGhpcy5zdHlsZSA9PSBIYXRjaFN0eWxlLk9ERF9QQVJJVFkpIHsKICAgICAgcmV0dXJuIHRoaXMuX0dlbmVyYXRlT2RkUGFyaXR5U2VnbWVudHMoKTsKICAgIH0KICAgIC8vWFhYIGFzc3VtZSB0aHJvdWdoIGFsbCBmb3IgYWxsIHRoZSByZXNldCBzdHlsZQogICAgcmV0dXJuIHRoaXMuX0dlbmVyYXRlVGhyb3VnaEFsbFNlZ21lbnRzKCk7CiAgfQogIF9Qcm9jZXNzRWRnZXMoKSB7CiAgICBmb3IgKGNvbnN0IGxvb3Agb2YgdGhpcy5sb29wcykgewogICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgbG9vcCkgewogICAgICAgIGNvbnN0IGVkZ2VWZWMgPSBlZGdlLmVuZC5jbG9uZSgpLnN1YihlZGdlLnN0YXJ0KTsKICAgICAgICBjb25zdCBsZW4gPSBlZGdlVmVjLmxlbmd0aCgpOwogICAgICAgIGVkZ2UuaXNaZXJvID0gbGVuIDw9IE51bWJlci5FUFNJTE9OOwogICAgICAgIGlmIChlZGdlLmlzWmVybykgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQogICAgICAgIGVkZ2VWZWMuZGl2aWRlU2NhbGFyKGxlbik7CiAgICAgICAgY29uc3QgYSA9IGVkZ2VWZWMuY3Jvc3ModGhpcy5saW5lRGlyKTsKICAgICAgICBlZGdlLmlzUGFyYWxsZWwgPSBNYXRoLmFicyhhKSA8PSAxZS02OwogICAgICAgIGlmIChlZGdlLmlzUGFyYWxsZWwpIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgICBlZGdlLmludGVyc2VjdGlvbiA9IEludGVyc2VjdFNlZ21lbnRzUGFyYW1ldHJpYyh0aGlzLmxpbmVbMF0sIHRoaXMubGluZVsxXSwgZWRnZS5zdGFydCwgZWRnZS5lbmQsIHRydWUpOwogICAgICB9CiAgICB9CiAgfQoKICAvKiogQ3JlYXRlIGludGVyc2VjdGlvbiBub2Rlcy4gRWFjaCBub2RlIHdpdGggYHRvZ2dsZWAgcHJvcGVydHkgc2V0IGNhdXNlcyBsaW5lIHN0YXRlIGNoYW5nZSwgc28KICAgKiB1bm5lY2Vzc2FyeSBjaGFuZ2VzIHNob3VsZCBiZSBmaWx0ZXJlZCBvdXQgaW5zaWRlIHRoaXMgbWV0aG9kLiBOb2RlIGFsc28gY2FuIHN1cHByZXNzIG9yCiAgICogdW4tc3VwcHJlc3MgbGluZSBpZiBjdXJyZW50bHkgZW5hYmxlZCwgdGhpcyBpcyBkb25lIGJ5IHNldHRpbmcgYHN1cHByZXNzYCBhbmQKICAgKiBgdW5zdXBwcmVzc2AgcHJvcGVydGllcyBvbiB0aGUgZWRnZS4KICAgKi8KICBfQ3JlYXRlTm9kZXMoKSB7CiAgICB0aGlzLm5vZGVzID0gW107CiAgICBmb3IgKGNvbnN0IGxvb3Agb2YgdGhpcy5sb29wcykgewogICAgICBmb3IgKGxldCBlZGdlIG9mIGxvb3ApIHsKICAgICAgICBpZiAoZWRnZS5pc1plcm8gfHwgZWRnZS5pc1BhcmFsbGVsIHx8IGVkZ2UuaXNQcm9jZXNzZWQgfHwgIWVkZ2UuaW50ZXJzZWN0aW9uKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgaWYgKGVkZ2UuaW50ZXJzZWN0aW9uWzFdIDwgLUVORFBPSU5UX01BUkdJTiB8fCBlZGdlLmludGVyc2VjdGlvblsxXSA+IDEgKyBFTkRQT0lOVF9NQVJHSU4pIHsKICAgICAgICAgIC8qIE5vIGludGVyc2VjdGlvbi4gKi8KICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KCiAgICAgICAgLyogU29tZSBpbnRlcnNlY3Rpb24gZXhpc3RzLCBjaGVjayBpZiBuZWFyIGVuZHBvaW50cy4gKi8KICAgICAgICBjb25zdCBpc1N0YXJ0VnR4ID0gZWRnZS5pbnRlcnNlY3Rpb25bMV0gPD0gRU5EUE9JTlRfTUFSR0lOOwogICAgICAgIGlmIChpc1N0YXJ0VnR4IHx8IGVkZ2UuaW50ZXJzZWN0aW9uWzFdID49IDEgLSBFTkRQT0lOVF9NQVJHSU4pIHsKICAgICAgICAgIC8qIEludGVyc2VjdGlvbiBuZWFyIHN0YXJ0IG9yIGVuZCB2ZXJ0ZXgsIGZvcmNlIGNvbm5lY3RlZCBlZGdlIGNoZWNrLiAqLwogICAgICAgICAgbGV0IFtjb25uRWRnZSwgaXNEaXJlY3RdID0gdGhpcy5fR2V0Q29ubmVjdGVkRWRnZShlZGdlLCBpc1N0YXJ0VnR4KTsKICAgICAgICAgIGlmICghY29ubkVkZ2UpIHsKICAgICAgICAgICAgLyogU29tZSBpbnZhbGlkIGNhc2UsIGlnbm9yZS4gKi8KICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CiAgICAgICAgICBlZGdlLmlzUHJvY2Vzc2VkID0gdHJ1ZTsKICAgICAgICAgIGNvbm5FZGdlLmlzUHJvY2Vzc2VkID0gdHJ1ZTsKICAgICAgICAgIGlmIChpc0RpcmVjdCkgewogICAgICAgICAgICBpZiAoRWRnZVNhbWVTaWRlKGVkZ2UsIGNvbm5FZGdlKSkgewogICAgICAgICAgICAgIGVkZ2UudG9nZ2xlID0gdHJ1ZTsKICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2goZWRnZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8qKiBDb25uZWN0ZWQgdGhyb3VnaCBjb2xpbmVhciBlZGdlKHMpLiBNYXJrIHRoZSBmaXJzdCBlZGdlIHRvIHRlbXBvcmFyaWx5CiAgICAgICAgICAgICAqIGRpc2FibGUgbGluZSBpZiBpdCBpcyBlbmFibGVkLiBTZWNvbmQgZWRnZSBlaXRoZXIgdG9nZ2xlcyB0aGUgc3RhdGUgb3IKICAgICAgICAgICAgICogcmVzdG9yZXMgcHJldmlvdXMgb25lLgogICAgICAgICAgICAgKi8KICAgICAgICAgICAgaWYgKGVkZ2UuaW50ZXJzZWN0aW9uWzBdID4gY29ubkVkZ2UuaW50ZXJzZWN0aW9uWzBdKSB7CiAgICAgICAgICAgICAgLyogU2V0IHByb3BlciBvcmRlciwgYGVkZ2VgIGlzIHRoZSBmaXJzdCBpbnRlcnNlY3Rpb24sIGBjb25uRWRnZWAgLSB0aGUKICAgICAgICAgICAgICAgKiBzZWNvbmQgb25lLgogICAgICAgICAgICAgICAqLwogICAgICAgICAgICAgIGNvbnN0IHRtcCA9IGNvbm5FZGdlOwogICAgICAgICAgICAgIGNvbm5FZGdlID0gZWRnZTsKICAgICAgICAgICAgICBlZGdlID0gdG1wOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVkZ2Uuc3VwcHJlc3MgPSB0cnVlOwogICAgICAgICAgICBjb25uRWRnZS51bnN1cHByZXNzID0gdHJ1ZTsKICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGVkZ2UpOwogICAgICAgICAgICBpZiAoRWRnZVNhbWVTaWRlKGVkZ2UsIGNvbm5FZGdlKSkgewogICAgICAgICAgICAgIGNvbm5FZGdlLnRvZ2dsZSA9IHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGNvbm5FZGdlKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgLyogQ2xlYW4gaW5uZXIgaW50ZXJzZWN0aW9uLiAqLwogICAgICAgICAgZWRnZS5pc1Byb2Nlc3NlZCA9IHRydWU7CiAgICAgICAgICBlZGdlLnRvZ2dsZSA9IHRydWU7CiAgICAgICAgICB0aGlzLm5vZGVzLnB1c2goZWRnZSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQoKICAvKioKICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2UKICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RhcnRWdHggVHJ1ZSBmb3IgY29ubmVjdGVkIHRocm91Z2ggc3RhcnQgdmVydGV4LCBmYWxzZSBmb3IgZW5kIHZlcnRleC4KICAgKiBAcmV0dXJuIHtbP0VkZ2UsIGJvb2xlYW5dfSBDb25uZWN0ZWQgdmFsaWQgZWRnZSBpZiBmb3VuZCwgbnVsbCBpZiBub3QgZm91bmQgKGUuZy4gaXMgdGhlIHNhbWUKICAgKiAgZWRnZSBmb3Igc29tZSByZWFzb24pLiBTZWNvbmQgdmFsdWUgaXMgdHJ1ZSBpZiBkaXJlY3RseSBjb25uZWN0ZWQsIGZhbHNlIGlmIHRob3VnaCBjb2xpbmVhcgogICAqICBlZGdlcy4KICAgKi8KICBfR2V0Q29ubmVjdGVkRWRnZShlZGdlLCBpc1N0YXJ0VnR4KSB7CiAgICBjb25zdCBsb29wID0gdGhpcy5sb29wc1tlZGdlLmxvb3BJZHhdOwogICAgbGV0IGkgPSBlZGdlLmlkeDsKICAgIGxldCBpc0RpcmVjdCA9IHRydWU7CiAgICBkbyB7CiAgICAgIGlmIChpc1N0YXJ0VnR4KSB7CiAgICAgICAgaWYgKGkgPT0gMCkgewogICAgICAgICAgaSA9IGxvb3AubGVuZ3RoIC0gMTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaS0tOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAoaSA9PSBsb29wLmxlbmd0aCAtIDEpIHsKICAgICAgICAgIGkgPSAwOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpKys7CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnN0IGNvbm5FZGdlID0gbG9vcFtpXTsKICAgICAgaWYgKGNvbm5FZGdlLmlzWmVybyB8fCBjb25uRWRnZS5pc1BhcmFsbGVsKSB7CiAgICAgICAgaXNEaXJlY3QgPSBmYWxzZTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gW2Nvbm5FZGdlLCBpc0RpcmVjdF07CiAgICAgIH0KICAgIH0gd2hpbGUgKGkgIT0gZWRnZS5pZHgpOwogICAgcmV0dXJuIFtudWxsLCBmYWxzZV07CiAgfQogIF9HZW5lcmF0ZU9kZFBhcml0eVNlZ21lbnRzKCkgewogICAgY29uc3QgcmVzdWx0ID0gW107CiAgICBsZXQgc3RhdGUgPSBmYWxzZTsKICAgIC8qIEluY3JlbWVudGVkIHdpdGggZWFjaCBzdXBwcmVzc2lvbiwgZGVjcmVtZW50ZWQgd2l0aCBlYWNoIHVuLXN1cHByZXNzaW9uLiAqLwogICAgbGV0IHN1cHByZXNzID0gMDsKICAgIC8qIFByZXZpb3VzIG5vZGUgd2hlbiBsaW5lIHdhcyBlbmFibGVkLiAqLwogICAgbGV0IHByZXZOb2RlID0gbnVsbDsKICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLm5vZGVzKSB7CiAgICAgIGlmIChub2RlLnN1cHByZXNzKSB7CiAgICAgICAgc3VwcHJlc3MrKzsKICAgICAgfQogICAgICBpZiAobm9kZS51bnN1cHByZXNzKSB7CiAgICAgICAgc3VwcHJlc3MtLTsKICAgICAgfQogICAgICBpZiAobm9kZS50b2dnbGUpIHsKICAgICAgICBzdGF0ZSA9ICFzdGF0ZTsKICAgICAgfQogICAgICBpZiAoc3VwcHJlc3MgPT0gMCAmJiBzdGF0ZSAmJiAobm9kZS51bnN1cHByZXNzIHx8IG5vZGUudG9nZ2xlKSkgewogICAgICAgIC8qIEp1c3Qgc3RhcnRlZCBuZXcgc2VnbWVudC4gKi8KICAgICAgICBwcmV2Tm9kZSA9IG5vZGU7CiAgICAgIH0gZWxzZSBpZiAoKHN1cHByZXNzIHx8ICFzdGF0ZSkgJiYgcHJldk5vZGUpIHsKICAgICAgICBpZiAobm9kZS5pbnRlcnNlY3Rpb25bMF0gLSBwcmV2Tm9kZS5pbnRlcnNlY3Rpb25bMF0gPiBOdW1iZXIuRVBTSUxPTikgewogICAgICAgICAgcmVzdWx0LnB1c2goW3ByZXZOb2RlLmludGVyc2VjdGlvblswXSwgbm9kZS5pbnRlcnNlY3Rpb25bMF1dKTsKICAgICAgICB9CiAgICAgICAgcHJldk5vZGUgPSBudWxsOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICBfR2VuZXJhdGVUaHJvdWdoQWxsU2VnbWVudHMoKSB7CiAgICBjb25zdCByZXN1bHQgPSBbXTsKICAgIC8qIEluY3JlbWVudGVkIHdpdGggZWFjaCBzdXBwcmVzc2lvbiwgZGVjcmVtZW50ZWQgd2l0aCBlYWNoIHVuLXN1cHByZXNzaW9uLiAqLwogICAgbGV0IHN1cHByZXNzID0gMDsKICAgIC8qIFByZXZpb3VzIG5vZGUgd2hlbiBsaW5lIHdhcyBlbmFibGVkLiAqLwogICAgbGV0IHByZXZOb2RlID0gbnVsbDsKICAgIC8qKiBGb3IgZWFjaCBsb29wIGNvdW50IG51bWJlciBvZiBjcm9zc2luZyBmcm9tIGVhY2ggc2lkZS4gT25lIHNpZGUgaW5jcmVtZW50cyBjb3JyZXNwb25kaW5nCiAgICAgKiBsb29wIHZhbHVlLCBvdGhlciBkZWNyZW1lbnRzLiBXaGVuIGFsbCB2YWx1ZXMgYXJlIHplcm8sIGxpbmUgaXMgb3V0c2lkZSBvZiBhbnkgbG9vcCBhbmQKICAgICAqIHNob3VsZCBub3QgYmUgcmVuZGVyZWQuCiAgICAgKi8KICAgIGNvbnN0IGxvb3BTdGFjayA9IG5ldyBBcnJheSh0aGlzLmxvb3BzLmxlbmd0aCkuZmlsbCgwKTsKICAgIGZ1bmN0aW9uIElzT3V0c2lkZSgpIHsKICAgICAgZm9yIChjb25zdCBuIG9mIGxvb3BTdGFjaykgewogICAgICAgIGlmIChuICE9IDApIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ub2RlcykgewogICAgICBpZiAobm9kZS5zdXBwcmVzcykgewogICAgICAgIHN1cHByZXNzKys7CiAgICAgIH0KICAgICAgaWYgKG5vZGUudW5zdXBwcmVzcykgewogICAgICAgIHN1cHByZXNzLS07CiAgICAgIH0KICAgICAgY29uc3Qgd2FzT3V0c2lkZSA9IElzT3V0c2lkZSgpOwogICAgICBpZiAobm9kZS50b2dnbGUpIHsKICAgICAgICBpZiAobm9kZS5pbnRlcnNlY3Rpb25bMl0gPiAwKSB7CiAgICAgICAgICBsb29wU3RhY2tbbm9kZS5sb29wSWR4XSsrOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBsb29wU3RhY2tbbm9kZS5sb29wSWR4XS0tOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoc3VwcHJlc3MgPT0gMCAmJiAhSXNPdXRzaWRlKCkgJiYgKG5vZGUudW5zdXBwcmVzcyB8fCB3YXNPdXRzaWRlKSkgewogICAgICAgIC8qIEp1c3Qgc3RhcnRlZCBuZXcgc2VnbWVudC4gKi8KICAgICAgICBwcmV2Tm9kZSA9IG5vZGU7CiAgICAgIH0gZWxzZSBpZiAoKHN1cHByZXNzIHx8IElzT3V0c2lkZSgpKSAmJiBwcmV2Tm9kZSkgewogICAgICAgIGlmIChub2RlLmludGVyc2VjdGlvblswXSAtIHByZXZOb2RlLmludGVyc2VjdGlvblswXSA+IE51bWJlci5FUFNJTE9OKSB7CiAgICAgICAgICByZXN1bHQucHVzaChbcHJldk5vZGUuaW50ZXJzZWN0aW9uWzBdLCBub2RlLmludGVyc2VjdGlvblswXV0pOwogICAgICAgIH0KICAgICAgICBwcmV2Tm9kZSA9IG51bGw7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQp9CmV4cG9ydCBjbGFzcyBIYXRjaENhbGN1bGF0b3IgewogIC8qKgogICAqIEFycmF5cyBvZiBgUGF0aGAgdG8gdXNlIGFzIGJvdW5kYXJ5LCBhbmQgZWFjaCBgUGF0aGAgaXMgYXJyYXkgb2YgYFBvaW50YC4KICAgKgogICAqIEBwYXJhbSB7VmVjdG9yMltdW119IGJvdW5kYXJ5TG9vcHMKICAgKiBAcGFyYW0ge0hhdGNoU3R5bGV9IHN0eWxlCiAgICovCiAgY29uc3RydWN0b3IoYm91bmRhcnlMb29wcywgc3R5bGUpIHsKICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCAiYm91bmRhcnlMb29wcyIsIHZvaWQgMCk7CiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgInN0eWxlIiwgdm9pZCAwKTsKICAgIHRoaXMuYm91bmRhcnlMb29wcyA9IGJvdW5kYXJ5TG9vcHM7CiAgICB0aGlzLnN0eWxlID0gc3R5bGU7CiAgfQoKICAvKioKICAgKiBDbGlwIGBsaW5lYCB1c2luZyBzdHJhdGVneSBkZWZpbmVkIGJ5IGB0aGlzLnN0eWxlYAogICAqCiAgICogQHBhcmFtIHtbVmVjdG9yMiwgVmVjdG9yMl19IGxpbmUgTGluZSBzZWdtZW50IGRlZmluZWQgYnkgc3RhcnQgYW5kIGVuZCBwb2ludHMuIEFzc3VtaW5nIHN0YXJ0CiAgICogIGFuZCBlbmQgcG9pbnRzIGxpZSBvdXQgb2YgdGhlIGJvdW5kYXJ5IGxvb3BzIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuCiAgICogQHJldHVybnMge1tWZWN0b3IyLCBWZWN0b3IyXVtdfSBjbGlwcGVkIGxpbmUgc2VnbWVudHMKICAgKi8KICBDbGlwTGluZShsaW5lKSB7CiAgICByZXR1cm4gbmV3IENsaXBDYWxjdWxhdG9yKHRoaXMuYm91bmRhcnlMb29wcywgdGhpcy5zdHlsZSwgbGluZSkuQ2FsY3VsYXRlKCk7CiAgfQoKICAvKioKICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHNlZWRQb2ludCBQYXR0ZXJuIHNlZWQgcG9pbnQgY29vcmRpbmF0ZXMgaW4gT0NTLgogICAqIEBwYXJhbSB7P251bWJlcn0gYW5nbGUgUGF0dGVybiByb3RhdGlvbiBhbmdsZSBpbiByYWRpYW5zLgogICAqIEBwYXJhbSB7P251bWJlcn0gc2NhbGUgUGF0dGVybiBzY2FsZS4KICAgKiBAcmV0dXJuIHtNYXRyaXgzfSBUcmFuc2Zvcm1hdGlvbiBmcm9tIE9DUyB0byBwYXR0ZXJuIHNwYWNlLgogICAqLwogIEdldFBhdHRlcm5UcmFuc2Zvcm0oewogICAgc2VlZFBvaW50LAogICAgYW5nbGUsCiAgICBzY2FsZQogIH0pIHsKICAgIGNvbnN0IG0gPSBuZXcgTWF0cml4MygpLm1ha2VUcmFuc2xhdGlvbigtc2VlZFBvaW50LngsIC1zZWVkUG9pbnQueSk7CiAgICBpZiAoYW5nbGUpIHsKICAgICAgLyogTWF0cml4My5yb3RhdGUoKSBpbnZlcnRzIGFuZ2xlIHNpZ24uICovCiAgICAgIG0ucm90YXRlKGFuZ2xlKTsKICAgIH0KICAgIGlmICgoc2NhbGUgIT09IG51bGwgJiYgc2NhbGUgIT09IHZvaWQgMCA/IHNjYWxlIDogMSkgIT0gMSkgewogICAgICBtLnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTsKICAgIH0KICAgIHJldHVybiBtOwogIH0KCiAgLyoqCiAgICogQHBhcmFtIHtNYXRyaXgzfSBwYXRUcmFuc2Zvcm0gVHJhbnNmb3JtYXRpb24gZnJvbSBPQ1MgdG8gcGF0dGVybiBzcGFjZSBwcmV2aW91c2x5IG9idGFpbmVkIGJ5CiAgICogICAgICBHZXRQYXR0ZXJuVHJhbnNmb3JtKCkgbWV0aG9kLgogICAqIEBwYXJhbSB7P1ZlY3RvcjJ9IGJhc2VQb2ludCBMaW5lIGJhc2UgcG9pbnQgY29vcmRpbmF0ZSBpbiBwYXR0ZXJuIHNwYWNlLgogICAqIEBwYXJhbSB7P251bWJlcn0gYW5nbGUgTGluZSBkaXJlY3Rpb24gYW5nbGUgaW4gcmFkaWFucywgQ0NXIGZyb20gK1ggZGlyZWN0aW9uLgogICAqIEByZXR1cm4ge01hdHJpeDN9IFRyYW5zZm9ybWF0aW9uIGZyb20gT0NTIHRvIHBhdHRlcm4gbGluZSBzcGFjZS4gTGluZSBpcyBzdGFydGVkIGF0IG9yaWdpbgogICAqICBhbmQgZGlyZWN0ZWQgaW50byBwb3NpdGlvbiBYIGF4aXMgZGlyZWN0aW9uLgogICAqLwogIEdldExpbmVUcmFuc2Zvcm0oewogICAgcGF0VHJhbnNmb3JtLAogICAgYmFzZVBvaW50LAogICAgYW5nbGUKICB9KSB7CiAgICBjb25zdCBtID0gcGF0VHJhbnNmb3JtLmNsb25lKCk7CiAgICBpZiAoYmFzZVBvaW50KSB7CiAgICAgIG0udHJhbnNsYXRlKC1iYXNlUG9pbnQueCwgLWJhc2VQb2ludC55KTsKICAgIH0KICAgIGlmIChhbmdsZSkgewogICAgICAvKiBNYXRyaXgzLnJvdGF0ZSgpIGludmVydHMgYW5nbGUgc2lnbi4gKi8KICAgICAgbS5yb3RhdGUoYW5nbGUpOwogICAgfQogICAgcmV0dXJuIG07CiAgfQoKICAvKioKICAgKiBAcGFyYW0ge01hdHJpeDN9IHRyYW5zZm9ybSBUcmFuc2Zvcm1hdGlvbiBmcm9tIE9DUyB0byB0YXJnZXQgY29vcmRpbmF0ZXMgc3BhY2UuCiAgICogQHJldHVybiB7Qm94Mn0gUGF0dGVybiBBQUJCIGluIHRhcmdldCBjb29yZGluYXRlIHNwYWNlLgogICAqLwogIEdldEJvdW5kaW5nQm94KHRyYW5zZm9ybSkgewogICAgY29uc3QgYm94ID0gbmV3IEJveDIoKTsKICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLmJvdW5kYXJ5TG9vcHMpIHsKICAgICAgZm9yIChjb25zdCB2IG9mIHBhdGgpIHsKICAgICAgICBib3guZXhwYW5kQnlQb2ludCh2LmNsb25lKCkuYXBwbHlNYXRyaXgzKHRyYW5zZm9ybSkpOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gYm94OwogIH0KfQ=="},{"version":3,"names":["Vector2","Matrix3","Box2","IntersectSegmentsParametric","HatchStyle","Object","freeze","ODD_PARITY","OUTERMOST","THROUGH_ENTIRE_AREA","ENDPOINT_MARGIN","EdgeSameSide","e1","e2","intersection","ClipCalculator","constructor","boundaryLoops","style","line","lineDir","clone","sub","normalize","loops","loopIdx","length","loop","_loop","vtxIdx","push","idx","start","end","Calculate","_ProcessEdges","_CreateNodes","nodes","sort","_GenerateOddParitySegments","_GenerateThroughAllSegments","edge","edgeVec","len","isZero","Number","EPSILON","divideScalar","a","cross","isParallel","Math","abs","isProcessed","isStartVtx","connEdge","isDirect","_GetConnectedEdge","toggle","tmp","suppress","unsuppress","i","result","state","prevNode","node","loopStack","Array","fill","IsOutside","n","wasOutside","HatchCalculator","_defineProperty","ClipLine","GetPatternTransform","seedPoint","angle","scale","m","makeTranslation","x","y","rotate","GetLineTransform","patTransform","basePoint","translate","GetBoundingBox","transform","box","path","v","expandByPoint","applyMatrix3"],"sources":["C:/Users/SDC-8/Desktop/Sowndarya/CMTI- Running Projects/PiWeb Running/PiWeb-CMTI-Pdf trying/1stApril/Trying/PiWeb-CMTI (2)/PiWeb-CMTI/node_modules/dxf-viewer/src/HatchCalculator.js"],"sourcesContent":["import { Vector2, Matrix3, Box2 } from \"three\"\nimport { IntersectSegmentsParametric } from \"./math/utils\"\n\nexport const HatchStyle = Object.freeze({\n    ODD_PARITY: 0,\n    OUTERMOST: 1,\n    THROUGH_ENTIRE_AREA: 2\n})\n\n/** Force intersection at this distance from edge endpoint (parameter value). */\nconst ENDPOINT_MARGIN = 1e-4\n\n/** @return {boolean} True if both edges crossed from the same side, false otherwise. */\nfunction EdgeSameSide(e1, e2) {\n    return (e1.intersection[2] > 0 && e2.intersection[2]) > 0 ||\n        (e1.intersection[2] < 0 && e2.intersection[2] < 0)\n}\n\n/** Context for one line clipping calculations. */\nclass ClipCalculator {\n\n    constructor(boundaryLoops, style, line) {\n        this.style = style\n        this.line = line\n        this.lineDir = line[1].clone().sub(line[0]).normalize()\n\n        this.loops = []\n        for (let loopIdx = 0; loopIdx < boundaryLoops.length; loopIdx++) {\n            const loop = boundaryLoops[loopIdx]\n            const _loop = []\n            for (let vtxIdx = 0; vtxIdx < loop.length; vtxIdx++) {\n                _loop.push({\n                    idx: vtxIdx,\n                    start: loop[vtxIdx],\n                    end: loop[vtxIdx == loop.length - 1 ? 0 : vtxIdx + 1],\n                    loopIdx\n                })\n            }\n            this.loops.push(_loop)\n        }\n    }\n\n    /**\n     * @return {number[2][]} List of resulting line segments in parametric form. Parameter value 0\n     *  corresponds to the provided line start point, 1 - to end point.\n     */\n    Calculate() {\n        this._ProcessEdges()\n        this._CreateNodes()\n        /* Sort from line start towards end. */\n        this.nodes.sort((e1, e2) => e1.intersection[0] - e2.intersection[0])\n        if (this.style == HatchStyle.ODD_PARITY) {\n            return this._GenerateOddParitySegments()\n        }\n        //XXX assume through all for all the reset style\n        return this._GenerateThroughAllSegments()\n    }\n\n    _ProcessEdges() {\n        for (const loop of this.loops) {\n            for (const edge of loop) {\n                const edgeVec = edge.end.clone().sub(edge.start)\n                const len = edgeVec.length()\n                edge.isZero = len <= Number.EPSILON\n                if (edge.isZero) {\n                    continue\n                }\n                edgeVec.divideScalar(len)\n                const a = edgeVec.cross(this.lineDir)\n                edge.isParallel = Math.abs(a) <= 1e-6\n                if (edge.isParallel) {\n                    continue\n                }\n                edge.intersection = IntersectSegmentsParametric(this.line[0], this.line[1],\n                    edge.start, edge.end, true)\n            }\n        }\n    }\n\n    /** Create intersection nodes. Each node with `toggle` property set causes line state change, so\n     * unnecessary changes should be filtered out inside this method. Node also can suppress or\n     * un-suppress line if currently enabled, this is done by setting `suppress` and\n     * `unsuppress` properties on the edge.\n     */\n    _CreateNodes() {\n        this.nodes = []\n        for (const loop of this.loops) {\n            for (let edge of loop) {\n                if (edge.isZero || edge.isParallel || edge.isProcessed || !edge.intersection) {\n                    continue\n                }\n\n                if (edge.intersection[1] < -ENDPOINT_MARGIN ||\n                    edge.intersection[1] > 1 + ENDPOINT_MARGIN) {\n                    /* No intersection. */\n                    continue\n                }\n\n                /* Some intersection exists, check if near endpoints. */\n                const isStartVtx = edge.intersection[1] <= ENDPOINT_MARGIN\n                if (isStartVtx || edge.intersection[1] >= 1 - ENDPOINT_MARGIN) {\n                    /* Intersection near start or end vertex, force connected edge check. */\n                    let [connEdge, isDirect] = this._GetConnectedEdge(edge, isStartVtx)\n                    if (!connEdge) {\n                        /* Some invalid case, ignore. */\n                        continue\n                    }\n                    edge.isProcessed = true\n                    connEdge.isProcessed = true\n                    if (isDirect) {\n                        if (EdgeSameSide(edge, connEdge)) {\n                            edge.toggle = true\n                            this.nodes.push(edge)\n                        }\n                    } else {\n                        /** Connected through colinear edge(s). Mark the first edge to temporarily\n                         * disable line if it is enabled. Second edge either toggles the state or\n                         * restores previous one.\n                         */\n                        if (edge.intersection[0] > connEdge.intersection[0]) {\n                            /* Set proper order, `edge` is the first intersection, `connEdge` - the\n                             * second one.\n                             */\n                            const tmp = connEdge\n                            connEdge = edge\n                            edge = tmp\n                        }\n\n                        edge.suppress = true\n                        connEdge.unsuppress = true\n\n                        this.nodes.push(edge)\n\n                        if (EdgeSameSide(edge, connEdge)) {\n                            connEdge.toggle = true\n                        }\n                        this.nodes.push(connEdge)\n                    }\n\n                } else {\n                    /* Clean inner intersection. */\n                    edge.isProcessed = true\n                    edge.toggle = true\n                    this.nodes.push(edge)\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {Edge} edge\n     * @param {boolean} isStartVtx True for connected through start vertex, false for end vertex.\n     * @return {[?Edge, boolean]} Connected valid edge if found, null if not found (e.g. is the same\n     *  edge for some reason). Second value is true if directly connected, false if though colinear\n     *  edges.\n     */\n    _GetConnectedEdge(edge, isStartVtx) {\n        const loop = this.loops[edge.loopIdx]\n        let i = edge.idx\n        let isDirect = true\n        do {\n            if (isStartVtx) {\n                if (i == 0) {\n                    i = loop.length - 1\n                } else {\n                    i--\n                }\n            } else {\n                if (i == loop.length - 1) {\n                    i = 0\n                } else {\n                    i++\n                }\n            }\n            const connEdge = loop[i]\n            if (connEdge.isZero || connEdge.isParallel) {\n                isDirect = false\n            } else {\n                return [connEdge, isDirect]\n            }\n        } while (i != edge.idx)\n        return [null, false]\n    }\n\n    _GenerateOddParitySegments() {\n        const result = []\n        let state = false\n        /* Incremented with each suppression, decremented with each un-suppression. */\n        let suppress = 0\n        /* Previous node when line was enabled. */\n        let prevNode = null\n\n        for (const node of this.nodes) {\n            if (node.suppress) {\n                suppress++\n            }\n            if (node.unsuppress) {\n                suppress--\n            }\n            if (node.toggle) {\n                state = !state\n            }\n            if (suppress == 0 && state && (node.unsuppress || node.toggle)) {\n                /* Just started new segment. */\n                prevNode = node\n            } else if ((suppress || !state) && prevNode) {\n                if (node.intersection[0] - prevNode.intersection[0] > Number.EPSILON) {\n                    result.push([prevNode.intersection[0], node.intersection[0]])\n                }\n                prevNode = null\n            }\n        }\n\n        return result\n    }\n\n    _GenerateThroughAllSegments() {\n        const result = []\n        /* Incremented with each suppression, decremented with each un-suppression. */\n        let suppress = 0\n        /* Previous node when line was enabled. */\n        let prevNode = null\n        /** For each loop count number of crossing from each side. One side increments corresponding\n         * loop value, other decrements. When all values are zero, line is outside of any loop and\n         * should not be rendered.\n         */\n        const loopStack = new Array(this.loops.length).fill(0);\n\n        function IsOutside() {\n            for (const n of loopStack) {\n                if (n != 0) {\n                    return false\n                }\n            }\n            return true\n        }\n\n        for (const node of this.nodes) {\n            if (node.suppress) {\n                suppress++\n            }\n            if (node.unsuppress) {\n                suppress--\n            }\n            const wasOutside = IsOutside()\n            if (node.toggle) {\n                if (node.intersection[2] > 0) {\n                    loopStack[node.loopIdx]++\n                } else {\n                    loopStack[node.loopIdx]--\n                }\n            }\n            if (suppress == 0 && !IsOutside() && (node.unsuppress || wasOutside)) {\n                /* Just started new segment. */\n                prevNode = node\n            } else if ((suppress || IsOutside()) && prevNode) {\n                if (node.intersection[0] - prevNode.intersection[0] > Number.EPSILON) {\n                    result.push([prevNode.intersection[0], node.intersection[0]])\n                }\n                prevNode = null\n            }\n        }\n\n        return result\n    }\n}\n\nexport class HatchCalculator {\n    boundaryLoops\n    style\n\n    /**\n     * Arrays of `Path` to use as boundary, and each `Path` is array of `Point`.\n     *\n     * @param {Vector2[][]} boundaryLoops\n     * @param {HatchStyle} style\n     */\n    constructor(boundaryLoops, style) {\n        this.boundaryLoops = boundaryLoops\n        this.style = style\n    }\n\n    /**\n     * Clip `line` using strategy defined by `this.style`\n     *\n     * @param {[Vector2, Vector2]} line Line segment defined by start and end points. Assuming start\n     *  and end points lie out of the boundary loops specified in the constructor.\n     * @returns {[Vector2, Vector2][]} clipped line segments\n     */\n    ClipLine(line) {\n        return new ClipCalculator(this.boundaryLoops, this.style, line).Calculate()\n    }\n\n    /**\n     * @param {Vector2} seedPoint Pattern seed point coordinates in OCS.\n     * @param {?number} angle Pattern rotation angle in radians.\n     * @param {?number} scale Pattern scale.\n     * @return {Matrix3} Transformation from OCS to pattern space.\n     */\n    GetPatternTransform({seedPoint, angle, scale}) {\n        const m = new Matrix3().makeTranslation(-seedPoint.x, -seedPoint.y)\n        if (angle) {\n            /* Matrix3.rotate() inverts angle sign. */\n            m.rotate(angle)\n        }\n        if ((scale ?? 1) != 1) {\n            m.scale(1 / scale, 1 / scale)\n        }\n        return m\n    }\n\n    /**\n     * @param {Matrix3} patTransform Transformation from OCS to pattern space previously obtained by\n     *      GetPatternTransform() method.\n     * @param {?Vector2} basePoint Line base point coordinate in pattern space.\n     * @param {?number} angle Line direction angle in radians, CCW from +X direction.\n     * @return {Matrix3} Transformation from OCS to pattern line space. Line is started at origin\n     *  and directed into position X axis direction.\n     */\n    GetLineTransform({patTransform, basePoint, angle}) {\n        const m = patTransform.clone()\n        if (basePoint) {\n            m.translate(-basePoint.x, -basePoint.y)\n        }\n        if (angle) {\n            /* Matrix3.rotate() inverts angle sign. */\n            m.rotate(angle)\n        }\n        return m\n    }\n\n    /**\n     * @param {Matrix3} transform Transformation from OCS to target coordinates space.\n     * @return {Box2} Pattern AABB in target coordinate space.\n     */\n    GetBoundingBox(transform) {\n        const box = new Box2()\n        for (const path of this.boundaryLoops) {\n            for (const v of path) {\n                box.expandByPoint(v.clone().applyMatrix3(transform))\n            }\n        }\n        return box\n    }\n}\n"],"mappings":"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"}]}